'use strict';

var reactTable = require('@tanstack/react-table');
var matchSorterUtils = require('@tanstack/match-sorter-utils');
var react = require('react');
var jsxRuntime = require('react/jsx-runtime');
var core = require('@mantine/core');
var clsx = require('clsx');
var iconsReact = require('@tabler/icons-react');
var reactVirtual = require('@tanstack/react-virtual');
var dates = require('@mantine/dates');
var hooks = require('@mantine/hooks');

const getColumnId = (columnDef) => { var _a, _b, _c, _d; return (_d = (_a = columnDef.id) !== null && _a !== void 0 ? _a : (_c = (_b = columnDef.accessorKey) === null || _b === void 0 ? void 0 : _b.toString) === null || _c === void 0 ? void 0 : _c.call(_b)) !== null && _d !== void 0 ? _d : columnDef.header; };
const getAllLeafColumnDefs = (columns) => {
    const allLeafColumnDefs = [];
    const getLeafColumns = (cols) => {
        cols.forEach((col) => {
            if (col.columns) {
                getLeafColumns(col.columns);
            }
            else {
                allLeafColumnDefs.push(col);
            }
        });
    };
    getLeafColumns(columns);
    return allLeafColumnDefs;
};
const prepareColumns = ({ columnDefs, tableOptions, }) => {
    const { aggregationFns = {}, defaultDisplayColumn, filterFns = {}, sortingFns = {}, state: { columnFilterFns = {} } = {}, } = tableOptions;
    return columnDefs.map((columnDef) => {
        var _a, _b;
        //assign columnId
        if (!columnDef.id)
            columnDef.id = getColumnId(columnDef);
        //assign columnDefType
        if (!columnDef.columnDefType)
            columnDef.columnDefType = 'data';
        if ((_a = columnDef.columns) === null || _a === void 0 ? void 0 : _a.length) {
            columnDef.columnDefType = 'group';
            //recursively prepare columns if this is a group column
            columnDef.columns = prepareColumns({
                columnDefs: columnDef.columns,
                tableOptions,
            });
        }
        else if (columnDef.columnDefType === 'data') {
            //assign aggregationFns if multiple aggregationFns are provided
            if (Array.isArray(columnDef.aggregationFn)) {
                const aggFns = columnDef.aggregationFn;
                columnDef.aggregationFn = (columnId, leafRows, childRows) => aggFns.map((fn) => { var _a; return (_a = aggregationFns[fn]) === null || _a === void 0 ? void 0 : _a.call(aggregationFns, columnId, leafRows, childRows); });
            }
            //assign filterFns
            if (Object.keys(filterFns).includes(columnFilterFns[columnDef.id])) {
                columnDef.filterFn =
                    (_b = filterFns[columnFilterFns[columnDef.id]]) !== null && _b !== void 0 ? _b : filterFns.fuzzy;
                columnDef._filterFn =
                    columnFilterFns[columnDef.id];
            }
            //assign sortingFns
            if (Object.keys(sortingFns).includes(columnDef.sortingFn)) {
                // @ts-ignore
                columnDef.sortingFn = sortingFns[columnDef.sortingFn];
            }
        }
        else if (columnDef.columnDefType === 'display') {
            columnDef = Object.assign(Object.assign({}, defaultDisplayColumn), columnDef);
        }
        return columnDef;
    });
};
const reorderColumn = (draggedColumn, targetColumn, columnOrder) => {
    if (draggedColumn.getCanPin()) {
        draggedColumn.pin(targetColumn.getIsPinned());
    }
    const newColumnOrder = [...columnOrder];
    newColumnOrder.splice(newColumnOrder.indexOf(targetColumn.id), 0, newColumnOrder.splice(newColumnOrder.indexOf(draggedColumn.id), 1)[0]);
    return newColumnOrder;
};
const getDefaultColumnFilterFn = (columnDef) => {
    const { filterVariant } = columnDef;
    if (filterVariant === 'multi-select')
        return 'arrIncludesSome';
    if (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.includes('range'))
        return 'betweenInclusive';
    if (['checkbox', 'date', 'select'].includes(filterVariant || ''))
        return 'equals';
    return 'fuzzy';
};

const flexRender = reactTable.flexRender;
function createMRTColumnHelper() {
    return {
        accessor: (accessor, column) => {
            return typeof accessor === 'function'
                ? Object.assign(Object.assign({}, column), { accessorFn: accessor })
                : Object.assign(Object.assign({}, column), { accessorKey: accessor });
        },
        display: (column) => column,
        group: (column) => column,
    };
}
const createRow = (table, originalRow, rowIndex = -1, depth = 0, subRows, parentId) => reactTable.createRow(table, 'mrt-row-create', originalRow !== null && originalRow !== void 0 ? originalRow : Object.assign({}, ...getAllLeafColumnDefs(table.options.columns).map((col) => ({
    [getColumnId(col)]: '',
}))), rowIndex, depth, subRows, parentId);

function defaultDisplayColumnProps({ header, id, size, tableOptions, }) {
    const { defaultDisplayColumn, displayColumnDefOptions, localization } = tableOptions;
    return Object.assign(Object.assign(Object.assign(Object.assign({}, defaultDisplayColumn), { header: header ? localization[header] : '', size }), displayColumnDefOptions === null || displayColumnDefOptions === void 0 ? void 0 : displayColumnDefOptions[id]), { id });
}
const showRowPinningColumn = (tableOptions) => {
    const { enableRowPinning, rowPinningDisplayMode } = tableOptions;
    return !!(enableRowPinning && !(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.startsWith('select')));
};
const showRowDragColumn = (tableOptions) => {
    const { enableRowDragging, enableRowOrdering } = tableOptions;
    return !!(enableRowDragging || enableRowOrdering);
};
const showRowExpandColumn = (tableOptions) => {
    const { enableExpanding, enableGrouping, renderDetailPanel, state: { grouping }, } = tableOptions;
    return !!(enableExpanding ||
        (enableGrouping && (grouping === null || grouping === void 0 ? void 0 : grouping.length)) ||
        renderDetailPanel);
};
const showRowActionsColumn = (tableOptions) => {
    const { createDisplayMode, editDisplayMode, enableEditing, enableRowActions, state: { creatingRow }, } = tableOptions;
    return !!(enableRowActions ||
        (creatingRow && createDisplayMode === 'row') ||
        (enableEditing && ['modal', 'row'].includes(editDisplayMode !== null && editDisplayMode !== void 0 ? editDisplayMode : '')));
};
const showRowSelectionColumn = (tableOptions) => !!tableOptions.enableRowSelection;
const showRowNumbersColumn = (tableOptions) => !!tableOptions.enableRowNumbers;
const showRowSpacerColumn = (tableOptions) => tableOptions.layoutMode === 'grid-no-grow';
const getLeadingDisplayColumnIds = (tableOptions) => [
    showRowPinningColumn(tableOptions) && 'mrt-row-pin',
    showRowDragColumn(tableOptions) && 'mrt-row-drag',
    tableOptions.positionActionsColumn === 'first' &&
        showRowActionsColumn(tableOptions) &&
        'mrt-row-actions',
    tableOptions.positionExpandColumn === 'first' &&
        showRowExpandColumn(tableOptions) &&
        'mrt-row-expand',
    showRowSelectionColumn(tableOptions) && 'mrt-row-select',
    showRowNumbersColumn(tableOptions) && 'mrt-row-numbers',
].filter(Boolean);
const getTrailingDisplayColumnIds = (tableOptions) => [
    tableOptions.positionActionsColumn === 'last' &&
        showRowActionsColumn(tableOptions) &&
        'mrt-row-actions',
    tableOptions.positionExpandColumn === 'last' &&
        showRowExpandColumn(tableOptions) &&
        'mrt-row-expand',
    showRowSpacerColumn(tableOptions) && 'mrt-row-spacer',
].filter(Boolean);
const getDefaultColumnOrderIds = (tableOptions, reset = false) => {
    const { state: { columnOrder: currentColumnOrderIds = [] }, } = tableOptions;
    const leadingDisplayColIds = getLeadingDisplayColumnIds(tableOptions);
    const trailingDisplayColIds = getTrailingDisplayColumnIds(tableOptions);
    const defaultColumnDefIds = getAllLeafColumnDefs(tableOptions.columns).map((columnDef) => getColumnId(columnDef));
    let allLeafColumnDefIds = reset
        ? defaultColumnDefIds
        : Array.from(new Set([...currentColumnOrderIds, ...defaultColumnDefIds]));
    allLeafColumnDefIds = allLeafColumnDefIds.filter((colId) => !leadingDisplayColIds.includes(colId) &&
        !trailingDisplayColIds.includes(colId));
    return [
        ...leadingDisplayColIds,
        ...allLeafColumnDefIds,
        ...trailingDisplayColIds,
    ];
};

const fuzzy$1 = (rowA, rowB, columnId) => {
    let dir = 0;
    if (rowA.columnFiltersMeta[columnId]) {
        dir = matchSorterUtils.compareItems(rowA.columnFiltersMeta[columnId], rowB.columnFiltersMeta[columnId]);
    }
    // Provide a fallback for when the item ranks are equal
    return dir === 0
        ? reactTable.sortingFns.alphanumeric(rowA, rowB, columnId)
        : dir;
};
const MRT_SortingFns = Object.assign(Object.assign({}, reactTable.sortingFns), { fuzzy: fuzzy$1 });
const rankGlobalFuzzy = (rowA, rowB) => Math.max(...Object.values(rowB.columnFiltersMeta).map((v) => v.rank)) -
    Math.max(...Object.values(rowA.columnFiltersMeta).map((v) => v.rank));

const parseFromValuesOrFunc = (fn, arg) => (fn instanceof Function ? fn(arg) : fn);

const getMRT_Rows = (table, all) => {
    const { getCenterRows, getPrePaginationRowModel, getRowModel, getState, getTopRows, options: { createDisplayMode, enablePagination, enableRowPinning, manualPagination, positionCreatingRow, rowPinningDisplayMode, }, } = table;
    const { creatingRow, pagination } = getState();
    const isRankingRows = getIsRankingRows(table);
    let rows = [];
    if (!isRankingRows) {
        rows =
            !enableRowPinning || (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky'))
                ? all
                    ? getPrePaginationRowModel().rows
                    : getRowModel().rows
                : getCenterRows();
    }
    else {
        // fuzzy ranking adjustments
        rows = getPrePaginationRowModel().rows.sort((a, b) => rankGlobalFuzzy(a, b));
        if (enablePagination && !manualPagination && !all) {
            const start = pagination.pageIndex * pagination.pageSize;
            rows = rows.slice(start, start + pagination.pageSize);
        }
        if (enableRowPinning && !(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky'))) {
            // "re-center-ize" the rows (no top or bottom pinned rows unless sticky)
            rows = rows.filter((row) => !row.getIsPinned());
        }
    }
    // row pinning adjustments
    if (enableRowPinning && (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky'))) {
        const centerPinnedRowIds = rows
            .filter((row) => row.getIsPinned())
            .map((r) => r.id);
        rows = [
            ...getTopRows().filter((row) => !centerPinnedRowIds.includes(row.id)),
            ...rows,
        ];
    }
    // blank inserted creating row adjustments
    if (positionCreatingRow !== undefined &&
        creatingRow &&
        createDisplayMode === 'row') {
        const creatingRowIndex = !isNaN(+positionCreatingRow)
            ? +positionCreatingRow
            : positionCreatingRow === 'top'
                ? 0
                : rows.length;
        rows = [
            ...rows.slice(0, creatingRowIndex),
            creatingRow,
            ...rows.slice(creatingRowIndex),
        ];
    }
    return rows;
};
const getCanRankRows = (table) => {
    const { getState, options: { enableGlobalFilterRankedResults, manualExpanding, manualFiltering, manualGrouping, manualSorting, }, } = table;
    const { expanded, globalFilterFn } = getState();
    return (!manualExpanding &&
        !manualFiltering &&
        !manualGrouping &&
        !manualSorting &&
        enableGlobalFilterRankedResults &&
        globalFilterFn === 'fuzzy' &&
        expanded !== true &&
        !Object.values(expanded).some(Boolean));
};
const getIsRankingRows = (table) => {
    const { globalFilter, sorting } = table.getState();
    return (getCanRankRows(table) &&
        globalFilter &&
        !Object.values(sorting).some(Boolean));
};
const getIsRowSelected = ({ row, table, }) => {
    const { options: { enableRowSelection }, } = table;
    return (row.getIsSelected() ||
        (parseFromValuesOrFunc(enableRowSelection, row) &&
            row.getCanSelectSubRows() &&
            row.getIsAllSubRowsSelected()));
};
const getMRT_RowSelectionHandler = ({ renderedRowIndex = 0, row, table, }) => (event, value) => {
    var _a;
    const { getState, options: { enableBatchRowSelection, enableMultiRowSelection, enableRowPinning, manualPagination, rowPinningDisplayMode, }, refs: { lastSelectedRowId: lastSelectedRowId }, } = table;
    const { pagination: { pageIndex, pageSize }, } = getState();
    const paginationOffset = manualPagination ? 0 : pageSize * pageIndex;
    const wasCurrentRowChecked = getIsRowSelected({ row, table });
    // toggle selection of this row
    row.toggleSelected(value !== null && value !== void 0 ? value : !wasCurrentRowChecked);
    const changedRowIds = new Set([row.id]);
    // if shift key is pressed, select all rows between last selected and this one
    if (enableBatchRowSelection &&
        enableMultiRowSelection &&
        event.nativeEvent.shiftKey &&
        lastSelectedRowId.current !== null) {
        const rows = getMRT_Rows(table, true);
        const lastIndex = rows.findIndex((r) => r.id === lastSelectedRowId.current);
        if (lastIndex !== -1) {
            const isLastIndexChecked = getIsRowSelected({
                row: rows === null || rows === void 0 ? void 0 : rows[lastIndex],
                table,
            });
            const currentIndex = renderedRowIndex + paginationOffset;
            const [start, end] = lastIndex < currentIndex
                ? [lastIndex, currentIndex]
                : [currentIndex, lastIndex];
            // toggle selection of all rows between last selected and this one
            // but only if the last selected row is not the same as the current one
            if (wasCurrentRowChecked !== isLastIndexChecked) {
                for (let i = start; i <= end; i++) {
                    rows[i].toggleSelected(!wasCurrentRowChecked);
                    changedRowIds.add(rows[i].id);
                }
            }
        }
    }
    // record the last selected row id
    lastSelectedRowId.current = row.id;
    // if all sub rows were selected, unselect them
    if (row.getCanSelectSubRows() && row.getIsAllSubRowsSelected()) {
        (_a = row.subRows) === null || _a === void 0 ? void 0 : _a.forEach((r) => r.toggleSelected(false));
    }
    if (enableRowPinning && (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('select'))) {
        changedRowIds.forEach((rowId) => {
            const rowToTogglePin = table.getRow(rowId);
            rowToTogglePin.pin(!wasCurrentRowChecked //was not previously pinned or selected
                ? (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('bottom'))
                    ? 'bottom'
                    : 'top'
                : false);
        });
    }
};
const getMRT_SelectAllHandler = ({ table }) => (event, value, forceAll) => {
    const { options: { enableRowPinning, rowPinningDisplayMode, selectAllMode }, refs: { lastSelectedRowId }, } = table;
    selectAllMode === 'all' || forceAll
        ? table.toggleAllRowsSelected(value !== null && value !== void 0 ? value : event.target.checked)
        : table.toggleAllPageRowsSelected(value !== null && value !== void 0 ? value : event.target.checked);
    if (enableRowPinning && (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('select'))) {
        table.setRowPinning({ bottom: [], top: [] });
    }
    lastSelectedRowId.current = null;
};

const parseCSSVarId = (id) => id.replace(/[^a-zA-Z0-9]/g, '_');
const getPrimaryShade = (theme) => {
    var _a, _b;
    return typeof theme.primaryShade === 'number'
        ? theme.primaryShade
        : (_b = (_a = theme.primaryShade) === null || _a === void 0 ? void 0 : _a.dark) !== null && _b !== void 0 ? _b : 7;
};
const getPrimaryColor = (theme, shade) => theme.colors[theme.primaryColor][shade !== null && shade !== void 0 ? shade : getPrimaryShade(theme)];
function dataVariable(name, value) {
    const key = `data-${name}`;
    switch (typeof value) {
        case 'boolean':
            return value ? { [key]: '' } : null;
        case 'number':
            return { [key]: `${value}` };
        case 'string':
            return { [key]: value };
        default:
            return null;
    }
}

const MRT_AggregationFns = Object.assign({}, reactTable.aggregationFns);

const fuzzy = (row, columnId, filterValue, addMeta) => {
    const itemRank = matchSorterUtils.rankItem(row.getValue(columnId), filterValue, {
        threshold: matchSorterUtils.rankings.MATCHES,
    });
    addMeta(itemRank);
    return itemRank.passed;
};
fuzzy.autoRemove = (val) => !val;
const contains = (row, id, filterValue) => row
    .getValue(id)
    .toString()
    .toLowerCase()
    .trim()
    .includes(filterValue.toString().toLowerCase().trim());
contains.autoRemove = (val) => !val;
const startsWith = (row, id, filterValue) => row
    .getValue(id)
    .toString()
    .toLowerCase()
    .trim()
    .startsWith(filterValue.toString().toLowerCase().trim());
startsWith.autoRemove = (val) => !val;
const endsWith = (row, id, filterValue) => row
    .getValue(id)
    .toString()
    .toLowerCase()
    .trim()
    .endsWith(filterValue.toString().toLowerCase().trim());
endsWith.autoRemove = (val) => !val;
const equals = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim() ===
    (filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString().toLowerCase().trim());
equals.autoRemove = (val) => !val;
const notEquals = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim() !==
    filterValue.toString().toLowerCase().trim();
notEquals.autoRemove = (val) => !val;
const greaterThan = (row, id, filterValue) => !isNaN(+filterValue) && !isNaN(+row.getValue(id))
    ? +row.getValue(id) > +filterValue
    : row.getValue(id).toString().toLowerCase().trim() >
        (filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString().toLowerCase().trim());
greaterThan.autoRemove = (val) => !val;
const greaterThanOrEqualTo = (row, id, filterValue) => equals(row, id, filterValue) || greaterThan(row, id, filterValue);
greaterThanOrEqualTo.autoRemove = (val) => !val;
const lessThan = (row, id, filterValue) => !isNaN(+filterValue) && !isNaN(+row.getValue(id))
    ? +row.getValue(id) < +filterValue
    : row.getValue(id).toString().toLowerCase().trim() <
        (filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString().toLowerCase().trim());
lessThan.autoRemove = (val) => !val;
const lessThanOrEqualTo = (row, id, filterValue) => equals(row, id, filterValue) || lessThan(row, id, filterValue);
lessThanOrEqualTo.autoRemove = (val) => !val;
const between = (row, id, filterValues) => (['', undefined].includes(filterValues[0]) ||
    greaterThan(row, id, filterValues[0])) &&
    ((!isNaN(+filterValues[0]) &&
        !isNaN(+filterValues[1]) &&
        +filterValues[0] > +filterValues[1]) ||
        ['', undefined].includes(filterValues[1]) ||
        lessThan(row, id, filterValues[1]));
between.autoRemove = (val) => !val;
const betweenInclusive = (row, id, filterValues) => (['', undefined].includes(filterValues[0]) ||
    greaterThanOrEqualTo(row, id, filterValues[0])) &&
    ((!isNaN(+filterValues[0]) &&
        !isNaN(+filterValues[1]) &&
        +filterValues[0] > +filterValues[1]) ||
        ['', undefined].includes(filterValues[1]) ||
        lessThanOrEqualTo(row, id, filterValues[1]));
betweenInclusive.autoRemove = (val) => !val;
const empty = (row, id, _filterValue) => !row.getValue(id).toString().trim();
empty.autoRemove = (val) => !val;
const notEmpty = (row, id, _filterValue) => !!row.getValue(id).toString().trim();
notEmpty.autoRemove = (val) => !val;
const MRT_FilterFns = Object.assign(Object.assign({}, reactTable.filterFns), { between,
    betweenInclusive,
    contains,
    empty,
    endsWith,
    equals,
    fuzzy,
    greaterThan,
    greaterThanOrEqualTo,
    lessThan,
    lessThanOrEqualTo,
    notEmpty,
    notEquals,
    startsWith });
function localizedFilterOption(localization, option) {
    var _a;
    if (!option) {
        return '';
    }
    const key = `filter${option[0].toUpperCase()}${option.slice(1)}`;
    return (_a = localization[key]) !== null && _a !== void 0 ? _a : '';
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var classes$C = {"root":"MRT_EditActionButtons-module_root__BfxVZ"};

const MRT_EditActionButtons = (_a) => {
    var { row, table, variant = 'icon' } = _a, rest = __rest(_a, ["row", "table", "variant"]);
    const { getState, options: { icons: { IconCircleX, IconDeviceFloppy }, localization, onCreatingRowCancel, onCreatingRowSave, onEditingRowCancel, onEditingRowSave, }, refs: { editInputRefs }, setCreatingRow, setEditingRow, } = table;
    const { creatingRow, editingRow, isSaving } = getState();
    const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;
    const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;
    const handleCancel = () => {
        if (isCreating) {
            onCreatingRowCancel === null || onCreatingRowCancel === void 0 ? void 0 : onCreatingRowCancel({ row, table });
            setCreatingRow(null);
        }
        else if (isEditing) {
            onEditingRowCancel === null || onEditingRowCancel === void 0 ? void 0 : onEditingRowCancel({ row, table });
            setEditingRow(null);
        }
        row._valuesCache = {}; //reset values cache
    };
    const handleSubmitRow = () => {
        var _a;
        //look for auto-filled input values
        (_a = Object.values(editInputRefs === null || editInputRefs === void 0 ? void 0 : editInputRefs.current)
            .filter((inputRef) => { var _a, _b; return row.id === ((_b = (_a = inputRef === null || inputRef === void 0 ? void 0 : inputRef.name) === null || _a === void 0 ? void 0 : _a.split('_')) === null || _b === void 0 ? void 0 : _b[0]); })) === null || _a === void 0 ? void 0 : _a.forEach((input) => {
            if (input.value !== undefined &&
                Object.hasOwn(row === null || row === void 0 ? void 0 : row._valuesCache, input.name)) {
                // @ts-ignore
                row._valuesCache[input.name] = input.value;
            }
        });
        if (isCreating)
            onCreatingRowSave === null || onCreatingRowSave === void 0 ? void 0 : onCreatingRowSave({
                exitCreatingMode: () => setCreatingRow(null),
                row,
                table,
                values: row._valuesCache,
            });
        else if (isEditing) {
            onEditingRowSave === null || onEditingRowSave === void 0 ? void 0 : onEditingRowSave({
                exitEditingMode: () => setEditingRow(null),
                row,
                table,
                values: row === null || row === void 0 ? void 0 : row._valuesCache,
            });
        }
    };
    return (jsxRuntime.jsx(core.Box, Object.assign({ className: clsx('mrt-edit-action-buttons', classes$C.root), onClick: (e) => e.stopPropagation() }, rest, { children: variant === 'icon' ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Tooltip, { label: localization.cancel, withinPortal: true, children: jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.cancel, color: "red", onClick: handleCancel, variant: "subtle", children: jsxRuntime.jsx(IconCircleX, {}) }) }), jsxRuntime.jsx(core.Tooltip, { label: localization.save, withinPortal: true, children: jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.save, color: "blue", loading: isSaving, onClick: handleSubmitRow, variant: "subtle", children: jsxRuntime.jsx(IconDeviceFloppy, {}) }) })] })) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Button, { onClick: handleCancel, variant: "subtle", children: localization.cancel }), jsxRuntime.jsx(core.Button, { loading: isSaving, onClick: handleSubmitRow, variant: "filled", children: localization.save })] })) })));
};

const MRT_RowActionMenu = (_a) => {
    var { handleEdit, row, table } = _a, rest = __rest(_a, ["handleEdit", "row", "table"]);
    const { options: { editDisplayMode, enableEditing, icons: { IconDots, IconEdit }, localization, positionActionsColumn, renderRowActionMenuItems, }, } = table;
    return (jsxRuntime.jsxs(core.Menu, { closeOnItemClick: true, position: positionActionsColumn === 'first'
            ? 'bottom-start'
            : positionActionsColumn === 'last'
                ? 'bottom-end'
                : undefined, withinPortal: true, children: [jsxRuntime.jsx(core.Tooltip, { label: localization.rowActions, openDelay: 1000, withinPortal: true, children: jsxRuntime.jsx(core.Menu.Target, { children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": localization.rowActions, color: "gray", onClick: (event) => event.stopPropagation(), size: "sm", variant: "subtle" }, rest, { children: jsxRuntime.jsx(IconDots, {}) })) }) }), jsxRuntime.jsxs(core.Menu.Dropdown, { onClick: (event) => event.stopPropagation(), children: [enableEditing && editDisplayMode !== 'table' && (jsxRuntime.jsx(core.Menu.Item, { leftSection: jsxRuntime.jsx(IconEdit, {}), onClick: handleEdit, children: localization.edit })), renderRowActionMenuItems === null || renderRowActionMenuItems === void 0 ? void 0 : renderRowActionMenuItems({
                        row,
                        table,
                    })] })] }));
};

const MRT_ToggleRowActionMenuButton = ({ cell, row, table, }) => {
    const { getState, options: { createDisplayMode, editDisplayMode, enableEditing, icons: { IconEdit }, localization: { edit }, renderRowActionMenuItems, renderRowActions, }, setEditingRow, } = table;
    const { creatingRow, editingRow } = getState();
    const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;
    const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;
    const handleStartEditMode = (event) => {
        event.stopPropagation();
        setEditingRow(Object.assign({}, row));
    };
    const showEditActionButtons = (isCreating && createDisplayMode === 'row') ||
        (isEditing && editDisplayMode === 'row');
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: renderRowActions && !showEditActionButtons ? (renderRowActions({ cell, row, table })) : showEditActionButtons ? (jsxRuntime.jsx(MRT_EditActionButtons, { row: row, table: table })) : !renderRowActionMenuItems &&
            parseFromValuesOrFunc(enableEditing, row) ? (jsxRuntime.jsx(core.Tooltip, { label: edit, openDelay: 1000, position: "right", withinPortal: true, children: jsxRuntime.jsx(core.ActionIcon, { "aria-label": edit, color: "gray", disabled: !!editingRow && editingRow.id !== row.id, onClick: handleStartEditMode, size: "md", variant: "subtle", children: jsxRuntime.jsx(IconEdit, {}) }) })) : renderRowActionMenuItems ? (jsxRuntime.jsx(MRT_RowActionMenu, { handleEdit: handleStartEditMode, row: row, table: table })) : null }));
};

const getMRT_RowActionsColumnDef = (tableOptions) => {
    return Object.assign({ Cell: ({ cell, row, table }) => (jsxRuntime.jsx(MRT_ToggleRowActionMenuButton, { cell: cell, row: row, table: table })) }, defaultDisplayColumnProps({
        header: 'actions',
        id: 'mrt-row-actions',
        size: 70,
        tableOptions,
    }));
};

var classes$B = {"grab-icon":"MRT_GrabHandleButton-module_grab-icon__mQimy"};

const MRT_GrabHandleButton = ({ actionIconProps, onDragEnd, onDragStart, table: { options: { icons: { IconGripHorizontal }, localization: { move }, }, }, }) => {
    var _a, _b;
    return (jsxRuntime.jsx(core.Tooltip, { label: (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.title) !== null && _a !== void 0 ? _a : move, openDelay: 1000, withinPortal: true, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": (_b = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.title) !== null && _b !== void 0 ? _b : move, draggable: true }, actionIconProps, { className: clsx('mrt-grab-handle-button', classes$B['grab-icon'], actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.className), color: "gray", onClick: (e) => {
                var _a;
                e.stopPropagation();
                (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onClick) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, e);
            }, onDragEnd: onDragEnd, onDragStart: onDragStart, title: undefined, variant: "transparent", children: jsxRuntime.jsx(IconGripHorizontal, {}) })) }));
};

const MRT_TableBodyRowGrabHandle = (_a) => {
    var { row, rowRef, table } = _a, rest = __rest(_a, ["row", "rowRef", "table"]);
    const { options: { mantineRowDragHandleProps }, } = table;
    const actionIconProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineRowDragHandleProps, {
        row,
        table,
    })), rest);
    const handleDragStart = (event) => {
        var _a;
        (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onDragStart) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, event);
        event.dataTransfer.setDragImage(rowRef.current, 0, 0);
        table.setDraggingRow(row);
    };
    const handleDragEnd = (event) => {
        var _a;
        (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onDragEnd) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, event);
        table.setDraggingRow(null);
        table.setHoveredRow(null);
    };
    return (jsxRuntime.jsx(MRT_GrabHandleButton, { actionIconProps: actionIconProps, onDragEnd: handleDragEnd, onDragStart: handleDragStart, table: table }));
};

const getMRT_RowDragColumnDef = (tableOptions) => {
    return Object.assign({ Cell: ({ row, rowRef, table }) => (jsxRuntime.jsx(MRT_TableBodyRowGrabHandle, { row: row, rowRef: rowRef, table: table })), grow: false }, defaultDisplayColumnProps({
        header: 'move',
        id: 'mrt-row-drag',
        size: 60,
        tableOptions,
    }));
};

var classes$A = {"root":"MRT_ExpandAllButton-module_root__gkBZD","chevron":"MRT_ExpandAllButton-module_chevron__Iep0j","up":"MRT_ExpandAllButton-module_up__Xth3U","right":"MRT_ExpandAllButton-module_right__bS4L-"};

const MRT_ExpandAllButton = (_a) => {
    var _b, _c;
    var { table } = _a, rest = __rest(_a, ["table"]);
    const { getCanSomeRowsExpand, getIsAllRowsExpanded, getIsSomeRowsExpanded, getState, options: { icons: { IconChevronsDown }, localization, mantineExpandAllButtonProps, renderDetailPanel, }, toggleAllRowsExpanded, } = table;
    const { density, isLoading } = getState();
    const actionIconProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineExpandAllButtonProps, {
        table,
    })), rest);
    const isAllRowsExpanded = getIsAllRowsExpanded();
    return (jsxRuntime.jsx(core.Tooltip, { label: ((_b = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.title) !== null && _b !== void 0 ? _b : isAllRowsExpanded)
            ? localization.collapseAll
            : localization.expandAll, openDelay: 1000, withinPortal: true, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": localization.expandAll, color: "gray", variant: "subtle" }, actionIconProps, { className: clsx('mrt-expand-all-button', classes$A.root, actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.className, density), disabled: isLoading || (!renderDetailPanel && !getCanSomeRowsExpand()), onClick: () => toggleAllRowsExpanded(!isAllRowsExpanded), title: undefined, children: (_c = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.children) !== null && _c !== void 0 ? _c : (jsxRuntime.jsx(IconChevronsDown, { className: clsx(classes$A.chevron, isAllRowsExpanded
                    ? classes$A.up
                    : getIsSomeRowsExpanded()
                        ? classes$A.right
                        : undefined) })) })) }));
};

var classes$z = {"root":"MRT_ExpandButton-module_root__IFYio","root-ltr":"MRT_ExpandButton-module_root-ltr__FHNnp","chevron":"MRT_ExpandButton-module_chevron__XzC5P","right":"MRT_ExpandButton-module_right__-pC-A","up":"MRT_ExpandButton-module_up__TZGBo","root-rtl":"MRT_ExpandButton-module_root-rtl__zoudS"};

const MRT_ExpandButton = (_a) => {
    var _b, _c;
    var { row, table } = _a, rest = __rest(_a, ["row", "table"]);
    const direction = core.useDirection();
    const { options: { icons: { IconChevronDown }, localization, mantineExpandButtonProps, positionExpandColumn, renderDetailPanel, }, } = table;
    const actionIconProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineExpandButtonProps, {
        row,
        table,
    })), rest);
    const canExpand = row.getCanExpand();
    const isExpanded = row.getIsExpanded();
    const DetailPanel = !!(renderDetailPanel === null || renderDetailPanel === void 0 ? void 0 : renderDetailPanel({ row, table }));
    const handleToggleExpand = (event) => {
        var _a;
        event.stopPropagation();
        row.toggleExpanded();
        (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onClick) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, event);
    };
    const rtl = direction.dir === 'rtl' || positionExpandColumn === 'last';
    return (jsxRuntime.jsx(core.Tooltip, { disabled: !canExpand && !DetailPanel, label: ((_b = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.title) !== null && _b !== void 0 ? _b : isExpanded)
            ? localization.collapse
            : localization.expand, openDelay: 1000, withinPortal: true, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": localization.expand, color: "gray", disabled: !canExpand && !DetailPanel, variant: "subtle" }, actionIconProps, { __vars: {
                '--mrt-row-depth': `${row.depth}`,
            }, className: clsx('mrt-expand-button', classes$z.root, classes$z[`root-${rtl ? 'rtl' : 'ltr'}`], actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.className), onClick: handleToggleExpand, title: undefined, children: (_c = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.children) !== null && _c !== void 0 ? _c : (jsxRuntime.jsx(IconChevronDown, { className: clsx('mrt-expand-button-chevron', classes$z.chevron, !canExpand && !renderDetailPanel
                    ? classes$z.right
                    : isExpanded
                        ? classes$z.up
                        : undefined) })) })) }));
};

const getMRT_RowExpandColumnDef = (tableOptions) => {
    var _a;
    const { defaultColumn, enableExpandAll, groupedColumnMode, positionExpandColumn, renderDetailPanel, state: { grouping }, } = tableOptions;
    const alignProps = positionExpandColumn === 'last'
        ? {
            align: 'right',
        }
        : undefined;
    return Object.assign({ Cell: ({ cell, column, row, table }) => {
            var _a, _b, _c;
            const expandButtonProps = { row, table };
            const subRowsLength = (_a = row.subRows) === null || _a === void 0 ? void 0 : _a.length;
            if (tableOptions.groupedColumnMode === 'remove' && row.groupingColumnId) {
                return (jsxRuntime.jsxs(core.Flex, { align: "center", gap: "0.25rem", children: [jsxRuntime.jsx(MRT_ExpandButton, Object.assign({}, expandButtonProps)), jsxRuntime.jsx(core.Tooltip, { label: table.getColumn(row.groupingColumnId).columnDef.header, openDelay: 1000, position: "right", children: jsxRuntime.jsx("span", { children: row.groupingValue }) }), !!subRowsLength && jsxRuntime.jsxs("span", { children: ["(", subRowsLength, ")"] })] }));
            }
            else {
                return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(MRT_ExpandButton, Object.assign({}, expandButtonProps)), (_c = (_b = column.columnDef).GroupedCell) === null || _c === void 0 ? void 0 : _c.call(_b, { cell, column, row, table })] }));
            }
        }, Header: enableExpandAll
            ? ({ table }) => {
                var _a;
                return (jsxRuntime.jsxs(core.Flex, { align: "center", children: [jsxRuntime.jsx(MRT_ExpandAllButton, { table: table }), groupedColumnMode === 'remove' &&
                            ((_a = grouping === null || grouping === void 0 ? void 0 : grouping.map((groupedColumnId) => table.getColumn(groupedColumnId).columnDef.header)) === null || _a === void 0 ? void 0 : _a.join(', '))] }));
            }
            : undefined, mantineTableBodyCellProps: alignProps, mantineTableHeadCellProps: alignProps }, defaultDisplayColumnProps({
        header: 'expand',
        id: 'mrt-row-expand',
        size: groupedColumnMode === 'remove'
            ? (_a = defaultColumn === null || defaultColumn === void 0 ? void 0 : defaultColumn.size) !== null && _a !== void 0 ? _a : 180
            : renderDetailPanel
                ? enableExpandAll
                    ? 60
                    : 70
                : 100,
        tableOptions,
    }));
};

const getMRT_RowNumbersColumnDef = (tableOptions) => {
    const { localization, rowNumberDisplayMode } = tableOptions;
    const { pagination: { pageIndex, pageSize }, } = tableOptions.state;
    return Object.assign({ Cell: ({ renderedRowIndex = 0, row }) => {
            var _a;
            return ((_a = (rowNumberDisplayMode === 'static'
                ? renderedRowIndex + pageSize * pageIndex
                : row.index)) !== null && _a !== void 0 ? _a : 0) + 1;
        }, Header: () => localization.rowNumber, grow: false }, defaultDisplayColumnProps({
        header: 'rowNumbers',
        id: 'mrt-row-numbers',
        size: 50,
        tableOptions,
    }));
};

const MRT_RowPinButton = (_a) => {
    var { pinningPosition, row, table } = _a, rest = __rest(_a, ["pinningPosition", "row", "table"]);
    const { options: { icons: { IconPinned, IconX }, localization, rowPinningDisplayMode, }, } = table;
    const isPinned = row.getIsPinned();
    const [tooltipOpened, setTooltipOpened] = react.useState(false);
    const handleTogglePin = (event) => {
        setTooltipOpened(false);
        event.stopPropagation();
        row.pin(isPinned ? false : pinningPosition);
    };
    return (jsxRuntime.jsx(core.Tooltip, { label: isPinned ? localization.unpin : localization.pin, openDelay: 1000, opened: tooltipOpened, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": localization.pin, color: "gray", onClick: handleTogglePin, onMouseEnter: () => setTooltipOpened(true), onMouseLeave: () => setTooltipOpened(false), size: "xs", style: {
                height: '24px',
                width: '24px',
            }, variant: "subtle" }, rest, { children: isPinned ? (jsxRuntime.jsx(IconX, {})) : (jsxRuntime.jsx(IconPinned, { fontSize: "small", style: {
                    transform: `rotate(${rowPinningDisplayMode === 'sticky'
                        ? 135
                        : pinningPosition === 'top'
                            ? 180
                            : 0}deg)`,
                } })) })) }));
};

const MRT_TableBodyRowPinButton = (_a) => {
    var { row, table } = _a, rest = __rest(_a, ["row", "table"]);
    const { getState, options: { enableRowPinning, rowPinningDisplayMode }, } = table;
    const { density } = getState();
    const canPin = parseFromValuesOrFunc(enableRowPinning, row);
    if (!canPin)
        return null;
    const rowPinButtonProps = Object.assign({ row,
        table }, rest);
    if (rowPinningDisplayMode === 'top-and-bottom' && !row.getIsPinned()) {
        return (jsxRuntime.jsxs(core.Box, { style: {
                display: 'flex',
                flexDirection: density === 'xs' ? 'row' : 'column',
            }, children: [jsxRuntime.jsx(MRT_RowPinButton, Object.assign({ pinningPosition: "top" }, rowPinButtonProps)), jsxRuntime.jsx(MRT_RowPinButton, Object.assign({ pinningPosition: "bottom" }, rowPinButtonProps))] }));
    }
    return (jsxRuntime.jsx(MRT_RowPinButton, Object.assign({ pinningPosition: rowPinningDisplayMode === 'bottom' ? 'bottom' : 'top' }, rowPinButtonProps)));
};

const getMRT_RowPinningColumnDef = (tableOptions) => {
    return Object.assign({ Cell: ({ row, table }) => (jsxRuntime.jsx(MRT_TableBodyRowPinButton, { row: row, table: table })), grow: false }, defaultDisplayColumnProps({
        header: 'pin',
        id: 'mrt-row-pin',
        size: 60,
        tableOptions,
    }));
};

const MRT_SelectCheckbox = (_a) => {
    var _b;
    var { renderedRowIndex = 0, row, table } = _a, rest = __rest(_a, ["renderedRowIndex", "row", "table"]);
    const { getState, options: { enableMultiRowSelection, localization, mantineSelectAllCheckboxProps, mantineSelectCheckboxProps, selectAllMode, selectDisplayMode, }, } = table;
    const { density, isLoading } = getState();
    const selectAll = !row;
    const allRowsSelected = selectAll
        ? selectAllMode === 'page'
            ? table.getIsAllPageRowsSelected()
            : table.getIsAllRowsSelected()
        : undefined;
    const isChecked = selectAll
        ? allRowsSelected
        : getIsRowSelected({ row, table });
    const checkboxProps = Object.assign(Object.assign({}, (selectAll
        ? parseFromValuesOrFunc(mantineSelectAllCheckboxProps, { table })
        : parseFromValuesOrFunc(mantineSelectCheckboxProps, {
            row,
            table,
        }))), rest);
    const onSelectionChange = row
        ? getMRT_RowSelectionHandler({
            renderedRowIndex,
            row,
            table,
        })
        : undefined;
    const onSelectAllChange = getMRT_SelectAllHandler({ table });
    const commonProps = Object.assign(Object.assign({ 'aria-label': selectAll
            ? localization.toggleSelectAll
            : localization.toggleSelectRow, checked: isChecked, disabled: isLoading || (row && !row.getCanSelect()) || (row === null || row === void 0 ? void 0 : row.id) === 'mrt-row-create', onChange: (event) => {
            event.stopPropagation();
            selectAll ? onSelectAllChange(event) : onSelectionChange(event);
        }, size: density === 'xs' ? 'sm' : 'md' }, checkboxProps), { onClick: (e) => {
            var _a;
            e.stopPropagation();
            (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a === void 0 ? void 0 : _a.call(checkboxProps, e);
        }, title: undefined });
    return (jsxRuntime.jsx(core.Tooltip, { label: (_b = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.title) !== null && _b !== void 0 ? _b : (selectAll
            ? localization.toggleSelectAll
            : localization.toggleSelectRow), openDelay: 1000, withinPortal: true, children: jsxRuntime.jsx("span", { children: selectDisplayMode === 'switch' ? (jsxRuntime.jsx(core.Switch, Object.assign({}, commonProps))) : selectDisplayMode === 'radio' ||
                enableMultiRowSelection === false ? (jsxRuntime.jsx(core.Radio, Object.assign({}, commonProps))) : (jsxRuntime.jsx(core.Checkbox, Object.assign({ indeterminate: !isChecked && selectAll
                    ? table.getIsSomeRowsSelected()
                    : (row === null || row === void 0 ? void 0 : row.getIsSomeSelected()) && row.getCanSelectSubRows() }, commonProps))) }) }));
};

const getMRT_RowSelectColumnDef = (tableOptions) => {
    const { enableMultiRowSelection, enableSelectAll } = tableOptions;
    return Object.assign({ Cell: ({ renderedRowIndex, row, table }) => (jsxRuntime.jsx(MRT_SelectCheckbox, { renderedRowIndex: renderedRowIndex, row: row, table: table })), Header: enableSelectAll && enableMultiRowSelection
            ? ({ table }) => jsxRuntime.jsx(MRT_SelectCheckbox, { table: table })
            : undefined, grow: false }, defaultDisplayColumnProps({
        header: 'select',
        id: 'mrt-row-select',
        size: enableSelectAll ? 60 : 70,
        tableOptions,
    }));
};

const MRT_Default_Icons = {
    IconArrowAutofitContent: iconsReact.IconArrowAutofitContent,
    IconArrowsSort: iconsReact.IconArrowsSort,
    IconBaselineDensityLarge: iconsReact.IconBaselineDensityLarge,
    IconBaselineDensityMedium: iconsReact.IconBaselineDensityMedium,
    IconBaselineDensitySmall: iconsReact.IconBaselineDensitySmall,
    IconBoxMultiple: iconsReact.IconBoxMultiple,
    IconChevronDown: iconsReact.IconChevronDown,
    IconChevronLeft: iconsReact.IconChevronLeft,
    IconChevronLeftPipe: iconsReact.IconChevronLeftPipe,
    IconChevronRight: iconsReact.IconChevronRight,
    IconChevronRightPipe: iconsReact.IconChevronRightPipe,
    IconChevronsDown: iconsReact.IconChevronsDown,
    IconCircleX: iconsReact.IconCircleX,
    IconClearAll: iconsReact.IconClearAll,
    IconColumns: iconsReact.IconColumns,
    IconDeviceFloppy: iconsReact.IconDeviceFloppy,
    IconDots: iconsReact.IconDots,
    IconDotsVertical: iconsReact.IconDotsVertical,
    IconEdit: iconsReact.IconEdit,
    IconEyeOff: iconsReact.IconEyeOff,
    IconFilter: iconsReact.IconFilter,
    IconFilterCog: iconsReact.IconFilterCog,
    IconFilterOff: iconsReact.IconFilterOff,
    IconGripHorizontal: iconsReact.IconGripHorizontal,
    IconMaximize: iconsReact.IconMaximize,
    IconMinimize: iconsReact.IconMinimize,
    IconPinned: iconsReact.IconPinned,
    IconPinnedOff: iconsReact.IconPinnedOff,
    IconSearch: iconsReact.IconSearch,
    IconSearchOff: iconsReact.IconSearchOff,
    IconSortAscending: iconsReact.IconSortAscending,
    IconSortDescending: iconsReact.IconSortDescending,
    IconX: iconsReact.IconX,
};

const MRT_Localization_EN = {
    actions: 'Actions',
    and: 'and',
    cancel: 'Cancel',
    changeFilterMode: 'Change filter mode',
    changeSearchMode: 'Change search mode',
    clearFilter: 'Clear filter',
    clearSearch: 'Clear search',
    clearSelection: 'Clear selection',
    clearSort: 'Clear sort',
    clickToCopy: 'Click to copy',
    collapse: 'Collapse',
    collapseAll: 'Collapse all',
    columnActions: 'Column Actions',
    copiedToClipboard: 'Copied to clipboard',
    dropToGroupBy: 'Drop to group by {column}',
    edit: 'Edit',
    expand: 'Expand',
    expandAll: 'Expand all',
    filterArrIncludes: 'Includes',
    filterArrIncludesAll: 'Includes all',
    filterArrIncludesSome: 'Includes',
    filterBetween: 'Between',
    filterBetweenInclusive: 'Between Inclusive',
    filterByColumn: 'Filter by {column}',
    filterContains: 'Contains',
    filterEmpty: 'Empty',
    filterEndsWith: 'Ends With',
    filterEquals: 'Equals',
    filterEqualsString: 'Equals',
    filterFuzzy: 'Fuzzy',
    filterGreaterThan: 'Greater Than',
    filterGreaterThanOrEqualTo: 'Greater Than Or Equal To',
    filterInNumberRange: 'Between',
    filterIncludesString: 'Contains',
    filterIncludesStringSensitive: 'Contains',
    filterLessThan: 'Less Than',
    filterLessThanOrEqualTo: 'Less Than Or Equal To',
    filterMode: 'Filter Mode: {filterType}',
    filterNotEmpty: 'Not Empty',
    filterNotEquals: 'Not Equals',
    filterStartsWith: 'Starts With',
    filterWeakEquals: 'Equals',
    filteringByColumn: 'Filtering by {column} - {filterType} {filterValue}',
    goToFirstPage: 'Go to first page',
    goToLastPage: 'Go to last page',
    goToNextPage: 'Go to next page',
    goToPreviousPage: 'Go to previous page',
    grab: 'Grab',
    groupByColumn: 'Group by {column}',
    groupedBy: 'Grouped by ',
    hideAll: 'Hide all',
    hideColumn: 'Hide {column} column',
    max: 'Max',
    min: 'Min',
    move: 'Move',
    noRecordsToDisplay: 'No records to display',
    noResultsFound: 'No results found',
    of: 'of',
    or: 'or',
    pin: 'Pin',
    pinToLeft: 'Pin to left',
    pinToRight: 'Pin to right',
    resetColumnSize: 'Reset column size',
    resetOrder: 'Reset order',
    rowActions: 'Row Actions',
    rowNumber: '#',
    rowNumbers: 'Row Numbers',
    rowsPerPage: 'Rows per page',
    save: 'Save',
    search: 'Search',
    selectedCountOfRowCountRowsSelected: '{selectedCount} of {rowCount} row(s) selected',
    select: 'Select',
    showAll: 'Show all',
    showAllColumns: 'Show all columns',
    showHideColumns: 'Show/Hide columns',
    showHideFilters: 'Show/Hide filters',
    showHideSearch: 'Show/Hide search',
    sortByColumnAsc: 'Sort by {column} ascending',
    sortByColumnDesc: 'Sort by {column} descending',
    sortedByColumnAsc: 'Sorted by {column} ascending',
    sortedByColumnDesc: 'Sorted by {column} descending',
    thenBy: ', then by ',
    toggleDensity: 'Toggle density',
    toggleFullScreen: 'Toggle full screen',
    toggleSelectAll: 'Toggle select all',
    toggleSelectRow: 'Toggle select row',
    toggleVisibility: 'Toggle visibility',
    ungroupByColumn: 'Ungroup by {column}',
    unpin: 'Unpin',
    unpinAll: 'Unpin all',
};

const MRT_DefaultColumn = {
    filterVariant: 'text',
    maxSize: 1000,
    minSize: 40,
    size: 180,
};
const MRT_DefaultDisplayColumn = {
    columnDefType: 'display',
    enableClickToCopy: false,
    enableColumnActions: false,
    enableColumnDragging: false,
    enableColumnFilter: false,
    enableColumnOrdering: false,
    enableEditing: false,
    enableGlobalFilter: false,
    enableGrouping: false,
    enableHiding: false,
    enableResizing: false,
    enableSorting: false,
};
const useMRT_TableOptions = (_a) => {
    var _b;
    var { aggregationFns, autoResetExpanded = false, columnFilterDisplayMode = 'subheader', columnResizeDirection, columnResizeMode = 'onChange', createDisplayMode = 'modal', defaultColumn, defaultDisplayColumn, editDisplayMode = 'modal', enableBatchRowSelection = true, enableBottomToolbar = true, enableColumnActions = true, enableColumnFilters = true, enableColumnOrdering = false, enableColumnPinning = false, enableColumnResizing = false, enableColumnVirtualization, enableDensityToggle = true, enableExpandAll = true, enableExpanding, enableFacetedValues = false, enableFilterMatchHighlighting = true, enableFilters = true, enableFullScreenToggle = true, enableGlobalFilter = true, enableGlobalFilterRankedResults = true, enableGrouping = false, enableHiding = true, enableMultiRowSelection = true, enableMultiSort = true, enablePagination = true, enableRowPinning = false, enableRowSelection = false, enableRowVirtualization, enableSelectAll = true, enableSorting = true, enableStickyHeader = false, enableTableFooter = true, enableTableHead = true, enableToolbarInternalActions = true, enableTopToolbar = true, filterFns, icons, layoutMode, localization, manualFiltering, manualGrouping, manualPagination, manualSorting, paginationDisplayMode = 'default', positionActionsColumn = 'first', positionCreatingRow = 'top', positionExpandColumn = 'first', positionGlobalFilter = 'right', positionPagination = 'bottom', positionToolbarAlertBanner = 'top', positionToolbarDropZone = 'top', rowNumberDisplayMode = 'static', rowPinningDisplayMode = 'sticky', selectAllMode = 'page', sortingFns } = _a, rest = __rest(_a, ["aggregationFns", "autoResetExpanded", "columnFilterDisplayMode", "columnResizeDirection", "columnResizeMode", "createDisplayMode", "defaultColumn", "defaultDisplayColumn", "editDisplayMode", "enableBatchRowSelection", "enableBottomToolbar", "enableColumnActions", "enableColumnFilters", "enableColumnOrdering", "enableColumnPinning", "enableColumnResizing", "enableColumnVirtualization", "enableDensityToggle", "enableExpandAll", "enableExpanding", "enableFacetedValues", "enableFilterMatchHighlighting", "enableFilters", "enableFullScreenToggle", "enableGlobalFilter", "enableGlobalFilterRankedResults", "enableGrouping", "enableHiding", "enableMultiRowSelection", "enableMultiSort", "enablePagination", "enableRowPinning", "enableRowSelection", "enableRowVirtualization", "enableSelectAll", "enableSorting", "enableStickyHeader", "enableTableFooter", "enableTableHead", "enableToolbarInternalActions", "enableTopToolbar", "filterFns", "icons", "layoutMode", "localization", "manualFiltering", "manualGrouping", "manualPagination", "manualSorting", "paginationDisplayMode", "positionActionsColumn", "positionCreatingRow", "positionExpandColumn", "positionGlobalFilter", "positionPagination", "positionToolbarAlertBanner", "positionToolbarDropZone", "rowNumberDisplayMode", "rowPinningDisplayMode", "selectAllMode", "sortingFns"]);
    const direction = core.useDirection();
    icons = react.useMemo(() => (Object.assign(Object.assign({}, MRT_Default_Icons), icons)), [icons]);
    localization = react.useMemo(() => (Object.assign(Object.assign({}, MRT_Localization_EN), localization)), [localization]);
    aggregationFns = react.useMemo(() => (Object.assign(Object.assign({}, MRT_AggregationFns), aggregationFns)), []);
    filterFns = react.useMemo(() => (Object.assign(Object.assign({}, MRT_FilterFns), filterFns)), []);
    sortingFns = react.useMemo(() => (Object.assign(Object.assign({}, MRT_SortingFns), sortingFns)), []);
    defaultColumn = react.useMemo(() => (Object.assign(Object.assign({}, MRT_DefaultColumn), defaultColumn)), [defaultColumn]);
    defaultDisplayColumn = react.useMemo(() => (Object.assign(Object.assign({}, MRT_DefaultDisplayColumn), defaultDisplayColumn)), [defaultDisplayColumn]);
    //cannot be changed after initialization
    [enableColumnVirtualization, enableRowVirtualization] = react.useMemo(() => [enableColumnVirtualization, enableRowVirtualization], []);
    if (!columnResizeDirection) {
        columnResizeDirection = direction.dir || 'ltr';
    }
    layoutMode =
        layoutMode || (enableColumnResizing ? 'grid-no-grow' : 'semantic');
    if (layoutMode === 'semantic' &&
        (enableRowVirtualization || enableColumnVirtualization)) {
        layoutMode = 'grid';
    }
    if (enableRowVirtualization) {
        enableStickyHeader = true;
    }
    if (enablePagination === false && manualPagination === undefined) {
        manualPagination = true;
    }
    if (!((_b = rest.data) === null || _b === void 0 ? void 0 : _b.length)) {
        manualFiltering = true;
        manualGrouping = true;
        manualPagination = true;
        manualSorting = true;
    }
    return Object.assign({ aggregationFns,
        autoResetExpanded,
        columnFilterDisplayMode,
        columnResizeDirection,
        columnResizeMode,
        createDisplayMode,
        defaultColumn,
        defaultDisplayColumn,
        editDisplayMode,
        enableBatchRowSelection,
        enableBottomToolbar,
        enableColumnActions,
        enableColumnFilters,
        enableColumnOrdering,
        enableColumnPinning,
        enableColumnResizing,
        enableColumnVirtualization,
        enableDensityToggle,
        enableExpandAll,
        enableExpanding,
        enableFacetedValues,
        enableFilterMatchHighlighting,
        enableFilters,
        enableFullScreenToggle,
        enableGlobalFilter,
        enableGlobalFilterRankedResults,
        enableGrouping,
        enableHiding,
        enableMultiRowSelection,
        enableMultiSort,
        enablePagination,
        enableRowPinning,
        enableRowSelection,
        enableRowVirtualization,
        enableSelectAll,
        enableSorting,
        enableStickyHeader,
        enableTableFooter,
        enableTableHead,
        enableToolbarInternalActions,
        enableTopToolbar,
        filterFns, getCoreRowModel: reactTable.getCoreRowModel(), getExpandedRowModel: enableExpanding || enableGrouping ? reactTable.getExpandedRowModel() : undefined, getFacetedMinMaxValues: enableFacetedValues
            ? reactTable.getFacetedMinMaxValues()
            : undefined, getFacetedRowModel: enableFacetedValues ? reactTable.getFacetedRowModel() : undefined, getFacetedUniqueValues: enableFacetedValues
            ? reactTable.getFacetedUniqueValues()
            : undefined, getFilteredRowModel: enableColumnFilters || enableGlobalFilter || enableFilters
            ? reactTable.getFilteredRowModel()
            : undefined, getGroupedRowModel: enableGrouping ? reactTable.getGroupedRowModel() : undefined, getPaginationRowModel: enablePagination
            ? reactTable.getPaginationRowModel()
            : undefined, getSortedRowModel: enableSorting ? reactTable.getSortedRowModel() : undefined, getSubRows: (row) => row === null || row === void 0 ? void 0 : row.subRows, icons,
        layoutMode,
        localization,
        manualFiltering,
        manualGrouping,
        manualPagination,
        manualSorting,
        paginationDisplayMode,
        positionActionsColumn,
        positionCreatingRow,
        positionExpandColumn,
        positionGlobalFilter,
        positionPagination,
        positionToolbarAlertBanner,
        positionToolbarDropZone,
        rowNumberDisplayMode,
        rowPinningDisplayMode,
        selectAllMode,
        sortingFns }, rest);
};

const blankColProps = {
    children: null,
    style: {
        minWidth: 0,
        padding: 0,
        width: 0,
    },
};
const getMRT_RowSpacerColumnDef = (tableOptions) => {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, defaultDisplayColumnProps({
        id: 'mrt-row-spacer',
        size: 0,
        tableOptions,
    })), { grow: true }), MRT_DefaultDisplayColumn), { mantineTableBodyCellProps: blankColProps, mantineTableFooterCellProps: blankColProps, mantineTableHeadCellProps: blankColProps });
};

const useMRT_Effects = (table) => {
    const { getIsSomeRowsPinned, getPrePaginationRowModel, getState, options: { enablePagination, enableRowPinning, rowCount }, } = table;
    const { columnOrder, density, globalFilter, isFullScreen, isLoading, pagination, showSkeletons, sorting, } = getState();
    const totalColumnCount = table.options.columns.length;
    const totalRowCount = rowCount !== null && rowCount !== void 0 ? rowCount : getPrePaginationRowModel().rows.length;
    const rerender = react.useReducer(() => ({}), {})[1];
    const initialBodyHeight = react.useRef();
    const previousTop = react.useRef();
    react.useEffect(() => {
        if (typeof window !== 'undefined') {
            initialBodyHeight.current = document.body.style.height;
        }
    }, []);
    //hide scrollbars when table is in full screen mode, preserve body scroll position after full screen exit
    react.useEffect(() => {
        if (typeof window !== 'undefined') {
            if (isFullScreen) {
                previousTop.current = document.body.getBoundingClientRect().top; //save scroll position
                document.body.style.height = '100dvh'; //hide page scrollbars when table is in full screen mode
            }
            else {
                document.body.style.height = initialBodyHeight.current;
                if (!previousTop.current)
                    return;
                //restore scroll position
                window.scrollTo({
                    behavior: 'instant',
                    top: -1 * previousTop.current,
                });
            }
        }
    }, [isFullScreen]);
    //recalculate column order when columns change or features are toggled on/off
    react.useEffect(() => {
        if (totalColumnCount !== columnOrder.length) {
            table.setColumnOrder(getDefaultColumnOrderIds(table.options));
        }
    }, [totalColumnCount]);
    //if page index is out of bounds, set it to the last page
    react.useEffect(() => {
        if (!enablePagination || isLoading || showSkeletons)
            return;
        const { pageIndex, pageSize } = pagination;
        const firstVisibleRowIndex = pageIndex * pageSize;
        if (firstVisibleRowIndex >= totalRowCount) {
            table.setPageIndex(Math.ceil(totalRowCount / pageSize) - 1);
        }
    }, [totalRowCount]);
    //turn off sort when global filter is looking for ranked results
    const appliedSort = react.useRef(sorting);
    react.useEffect(() => {
        if (sorting.length) {
            appliedSort.current = sorting;
        }
    }, [sorting]);
    react.useEffect(() => {
        if (!getCanRankRows(table))
            return;
        if (globalFilter) {
            table.setSorting([]);
        }
        else {
            table.setSorting(() => appliedSort.current || []);
        }
    }, [globalFilter]);
    //fix pinned row top style when density changes
    react.useEffect(() => {
        if (enableRowPinning && getIsSomeRowsPinned()) {
            setTimeout(() => {
                rerender();
            }, 150);
        }
    }, [density]);
};

/**
 * The MRT hook that wraps the TanStack useReactTable hook and adds additional functionality
 * @param definedTableOptions - table options with proper defaults set
 * @returns the MRT table instance
 */
const useMRT_TableInstance = (definedTableOptions) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8;
    const lastSelectedRowId = react.useRef(null);
    const bottomToolbarRef = react.useRef(null);
    const editInputRefs = react.useRef({});
    const filterInputRefs = react.useRef({});
    const searchInputRef = react.useRef(null);
    const tableContainerRef = react.useRef(null);
    const tableHeadCellRefs = react.useRef({});
    const tablePaperRef = react.useRef(null);
    const topToolbarRef = react.useRef(null);
    const tableHeadRef = react.useRef(null);
    const tableFooterRef = react.useRef(null);
    //transform initial state with proper column order
    const initialState = react.useMemo(() => {
        var _a, _b, _c;
        const initState = (_a = definedTableOptions.initialState) !== null && _a !== void 0 ? _a : {};
        initState.columnOrder =
            (_b = initState.columnOrder) !== null && _b !== void 0 ? _b : getDefaultColumnOrderIds(Object.assign(Object.assign({}, definedTableOptions), { state: Object.assign(Object.assign({}, definedTableOptions.initialState), definedTableOptions.state) }));
        initState.globalFilterFn = (_c = definedTableOptions.globalFilterFn) !== null && _c !== void 0 ? _c : 'fuzzy';
        return initState;
    }, []);
    definedTableOptions.initialState = initialState;
    const [creatingRow, _setCreatingRow] = react.useState((_a = initialState.creatingRow) !== null && _a !== void 0 ? _a : null);
    const [columnFilterFns, setColumnFilterFns] = react.useState(() => Object.assign({}, ...getAllLeafColumnDefs(definedTableOptions.columns).map((col) => {
        var _a, _b, _c, _d;
        return ({
            [getColumnId(col)]: col.filterFn instanceof Function
                ? (_a = col.filterFn.name) !== null && _a !== void 0 ? _a : 'custom'
                : (_d = (_b = col.filterFn) !== null && _b !== void 0 ? _b : (_c = initialState === null || initialState === void 0 ? void 0 : initialState.columnFilterFns) === null || _c === void 0 ? void 0 : _c[getColumnId(col)]) !== null && _d !== void 0 ? _d : getDefaultColumnFilterFn(col),
        });
    })));
    const [columnOrder, onColumnOrderChange] = react.useState((_b = initialState.columnOrder) !== null && _b !== void 0 ? _b : []);
    const [columnSizingInfo, onColumnSizingInfoChange] = react.useState((_c = initialState.columnSizingInfo) !== null && _c !== void 0 ? _c : {});
    const [density, setDensity] = react.useState((_d = initialState === null || initialState === void 0 ? void 0 : initialState.density) !== null && _d !== void 0 ? _d : 'md');
    const [draggingColumn, setDraggingColumn] = react.useState((_e = initialState.draggingColumn) !== null && _e !== void 0 ? _e : null);
    const [draggingRow, setDraggingRow] = react.useState((_f = initialState.draggingRow) !== null && _f !== void 0 ? _f : null);
    const [editingCell, setEditingCell] = react.useState((_g = initialState.editingCell) !== null && _g !== void 0 ? _g : null);
    const [editingRow, setEditingRow] = react.useState((_h = initialState.editingRow) !== null && _h !== void 0 ? _h : null);
    const [globalFilterFn, setGlobalFilterFn] = react.useState((_j = initialState.globalFilterFn) !== null && _j !== void 0 ? _j : 'fuzzy');
    const [grouping, onGroupingChange] = react.useState((_k = initialState.grouping) !== null && _k !== void 0 ? _k : []);
    const [hoveredColumn, setHoveredColumn] = react.useState((_l = initialState.hoveredColumn) !== null && _l !== void 0 ? _l : null);
    const [hoveredRow, setHoveredRow] = react.useState((_m = initialState.hoveredRow) !== null && _m !== void 0 ? _m : null);
    const [isFullScreen, setIsFullScreen] = react.useState((_o = initialState === null || initialState === void 0 ? void 0 : initialState.isFullScreen) !== null && _o !== void 0 ? _o : false);
    const [pagination, onPaginationChange] = react.useState((_p = initialState === null || initialState === void 0 ? void 0 : initialState.pagination) !== null && _p !== void 0 ? _p : { pageIndex: 0, pageSize: 10 });
    const [showAlertBanner, setShowAlertBanner] = react.useState((_q = initialState === null || initialState === void 0 ? void 0 : initialState.showAlertBanner) !== null && _q !== void 0 ? _q : false);
    const [showColumnFilters, setShowColumnFilters] = react.useState((_r = initialState === null || initialState === void 0 ? void 0 : initialState.showColumnFilters) !== null && _r !== void 0 ? _r : false);
    const [showGlobalFilter, setShowGlobalFilter] = react.useState((_s = initialState === null || initialState === void 0 ? void 0 : initialState.showGlobalFilter) !== null && _s !== void 0 ? _s : false);
    const [showToolbarDropZone, setShowToolbarDropZone] = react.useState((_t = initialState === null || initialState === void 0 ? void 0 : initialState.showToolbarDropZone) !== null && _t !== void 0 ? _t : false);
    definedTableOptions.state = Object.assign({ columnFilterFns,
        columnOrder,
        columnSizingInfo,
        creatingRow,
        density,
        draggingColumn,
        draggingRow,
        editingCell,
        editingRow,
        globalFilterFn,
        grouping,
        hoveredColumn,
        hoveredRow,
        isFullScreen,
        pagination,
        showAlertBanner,
        showColumnFilters,
        showGlobalFilter,
        showToolbarDropZone }, definedTableOptions.state);
    //The table options now include all state needed to help determine column visibility and order logic
    const statefulTableOptions = definedTableOptions;
    //don't recompute columnDefs while resizing column or dragging column/row
    const columnDefsRef = react.useRef([]);
    statefulTableOptions.columns =
        statefulTableOptions.state.columnSizingInfo.isResizingColumn ||
            statefulTableOptions.state.draggingColumn ||
            statefulTableOptions.state.draggingRow
            ? columnDefsRef.current
            : prepareColumns({
                columnDefs: [
                    ...[
                        showRowPinningColumn(statefulTableOptions) &&
                            getMRT_RowPinningColumnDef(statefulTableOptions),
                        showRowDragColumn(statefulTableOptions) &&
                            getMRT_RowDragColumnDef(statefulTableOptions),
                        showRowActionsColumn(statefulTableOptions) &&
                            getMRT_RowActionsColumnDef(statefulTableOptions),
                        showRowExpandColumn(statefulTableOptions) &&
                            getMRT_RowExpandColumnDef(statefulTableOptions),
                        showRowSelectionColumn(statefulTableOptions) &&
                            getMRT_RowSelectColumnDef(statefulTableOptions),
                        showRowNumbersColumn(statefulTableOptions) &&
                            getMRT_RowNumbersColumnDef(statefulTableOptions),
                    ].filter(Boolean),
                    ...statefulTableOptions.columns,
                    ...[
                        showRowSpacerColumn(statefulTableOptions) &&
                            getMRT_RowSpacerColumnDef(statefulTableOptions),
                    ].filter(Boolean),
                ],
                tableOptions: statefulTableOptions,
            });
    columnDefsRef.current = statefulTableOptions.columns;
    //if loading, generate blank rows to show skeleton loaders
    statefulTableOptions.data = react.useMemo(() => (statefulTableOptions.state.isLoading ||
        statefulTableOptions.state.showSkeletons) &&
        !statefulTableOptions.data.length
        ? [
            ...Array(Math.min(statefulTableOptions.state.pagination.pageSize, 20)).fill(null),
        ].map(() => Object.assign({}, ...getAllLeafColumnDefs(statefulTableOptions.columns).map((col) => ({
            [getColumnId(col)]: null,
        }))))
        : statefulTableOptions.data, [
        statefulTableOptions.data,
        statefulTableOptions.state.isLoading,
        statefulTableOptions.state.showSkeletons,
    ]);
    //@ts-ignore
    const table = reactTable.useReactTable(Object.assign(Object.assign({ onColumnOrderChange,
        onColumnSizingInfoChange,
        onGroupingChange,
        onPaginationChange }, statefulTableOptions), { globalFilterFn: (_u = statefulTableOptions.filterFns) === null || _u === void 0 ? void 0 : _u[globalFilterFn !== null && globalFilterFn !== void 0 ? globalFilterFn : 'fuzzy'] }));
    table.refs = {
        bottomToolbarRef,
        editInputRefs,
        filterInputRefs,
        lastSelectedRowId,
        searchInputRef,
        tableContainerRef,
        tableFooterRef,
        tableHeadCellRefs,
        tableHeadRef,
        tablePaperRef,
        topToolbarRef,
    };
    table.setCreatingRow = (row) => {
        var _a, _b;
        let _row = row;
        if (row === true) {
            _row = createRow(table);
        }
        (_b = (_a = statefulTableOptions === null || statefulTableOptions === void 0 ? void 0 : statefulTableOptions.onCreatingRowChange) === null || _a === void 0 ? void 0 : _a.call(statefulTableOptions, _row)) !== null && _b !== void 0 ? _b : _setCreatingRow(_row);
    };
    table.setColumnFilterFns =
        (_v = statefulTableOptions.onColumnFilterFnsChange) !== null && _v !== void 0 ? _v : setColumnFilterFns;
    table.setDensity = (_w = statefulTableOptions.onDensityChange) !== null && _w !== void 0 ? _w : setDensity;
    table.setDraggingColumn =
        (_x = statefulTableOptions.onDraggingColumnChange) !== null && _x !== void 0 ? _x : setDraggingColumn;
    table.setDraggingRow =
        (_y = statefulTableOptions.onDraggingRowChange) !== null && _y !== void 0 ? _y : setDraggingRow;
    table.setEditingCell =
        (_z = statefulTableOptions.onEditingCellChange) !== null && _z !== void 0 ? _z : setEditingCell;
    table.setEditingRow =
        (_0 = statefulTableOptions.onEditingRowChange) !== null && _0 !== void 0 ? _0 : setEditingRow;
    table.setGlobalFilterFn =
        (_1 = statefulTableOptions.onGlobalFilterFnChange) !== null && _1 !== void 0 ? _1 : setGlobalFilterFn;
    table.setHoveredColumn =
        (_2 = statefulTableOptions.onHoveredColumnChange) !== null && _2 !== void 0 ? _2 : setHoveredColumn;
    table.setHoveredRow =
        (_3 = statefulTableOptions.onHoveredRowChange) !== null && _3 !== void 0 ? _3 : setHoveredRow;
    table.setIsFullScreen =
        (_4 = statefulTableOptions.onIsFullScreenChange) !== null && _4 !== void 0 ? _4 : setIsFullScreen;
    table.setShowAlertBanner =
        (_5 = statefulTableOptions.onShowAlertBannerChange) !== null && _5 !== void 0 ? _5 : setShowAlertBanner;
    table.setShowColumnFilters =
        (_6 = statefulTableOptions.onShowColumnFiltersChange) !== null && _6 !== void 0 ? _6 : setShowColumnFilters;
    table.setShowGlobalFilter =
        (_7 = statefulTableOptions.onShowGlobalFilterChange) !== null && _7 !== void 0 ? _7 : setShowGlobalFilter;
    table.setShowToolbarDropZone =
        (_8 = statefulTableOptions.onShowToolbarDropZoneChange) !== null && _8 !== void 0 ? _8 : setShowToolbarDropZone;
    useMRT_Effects(table);
    return table;
};

const useMantineReactTable = (tableOptions) => useMRT_TableInstance(useMRT_TableOptions(tableOptions));

const extraIndexRangeExtractor = (range, draggingIndex) => {
    const newIndexes = reactVirtual.defaultRangeExtractor(range);
    if (draggingIndex === undefined)
        return newIndexes;
    if (draggingIndex >= 0 &&
        draggingIndex < Math.max(range.startIndex - range.overscan, 0)) {
        newIndexes.unshift(draggingIndex);
    }
    if (draggingIndex >= 0 && draggingIndex > range.endIndex + range.overscan) {
        newIndexes.push(draggingIndex);
    }
    return newIndexes;
};

const useMRT_ColumnVirtualizer = (table) => {
    var _a, _b, _c, _d;
    const { getLeftLeafColumns, getRightLeafColumns, getState, getVisibleLeafColumns, options: { columnVirtualizerInstanceRef, columnVirtualizerOptions, enableColumnPinning, enableColumnVirtualization, }, refs: { tableContainerRef }, } = table;
    const { columnPinning, draggingColumn } = getState();
    if (!enableColumnVirtualization)
        return undefined;
    const columnVirtualizerProps = parseFromValuesOrFunc(columnVirtualizerOptions, {
        table,
    });
    const visibleColumns = getVisibleLeafColumns();
    const [leftPinnedIndexes, rightPinnedIndexes] = react.useMemo(() => enableColumnPinning
        ? [
            getLeftLeafColumns().map((c) => c.getPinnedIndex()),
            getRightLeafColumns()
                .map((column) => visibleColumns.length - column.getPinnedIndex() - 1)
                .sort((a, b) => a - b),
        ]
        : [[], []], [columnPinning, enableColumnPinning]);
    const numPinnedLeft = leftPinnedIndexes.length;
    const numPinnedRight = rightPinnedIndexes.length;
    const draggingColumnIndex = react.useMemo(() => (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id)
        ? visibleColumns.findIndex((c) => c.id === (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id))
        : undefined, [draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id]);
    const columnVirtualizer = reactVirtual.useVirtualizer(Object.assign({ count: visibleColumns.length, estimateSize: (index) => visibleColumns[index].getSize(), getScrollElement: () => tableContainerRef.current, horizontal: true, overscan: 3, rangeExtractor: react.useCallback((range) => {
            const newIndexes = extraIndexRangeExtractor(range, draggingColumnIndex);
            if (!numPinnedLeft && !numPinnedRight) {
                return newIndexes;
            }
            return [
                ...new Set([
                    ...leftPinnedIndexes,
                    ...newIndexes,
                    ...rightPinnedIndexes,
                ]),
            ];
        }, [leftPinnedIndexes, rightPinnedIndexes, draggingColumnIndex]) }, columnVirtualizerProps));
    const virtualColumns = columnVirtualizer.getVirtualItems();
    columnVirtualizer.virtualColumns = virtualColumns;
    const numColumns = virtualColumns.length;
    if (numColumns) {
        const totalSize = columnVirtualizer.getTotalSize();
        const leftNonPinnedStart = ((_a = virtualColumns[numPinnedLeft]) === null || _a === void 0 ? void 0 : _a.start) || 0;
        const leftNonPinnedEnd = ((_b = virtualColumns[leftPinnedIndexes.length - 1]) === null || _b === void 0 ? void 0 : _b.end) || 0;
        const rightNonPinnedStart = ((_c = virtualColumns[numColumns - numPinnedRight]) === null || _c === void 0 ? void 0 : _c.start) || 0;
        const rightNonPinnedEnd = ((_d = virtualColumns[numColumns - numPinnedRight - 1]) === null || _d === void 0 ? void 0 : _d.end) || 0;
        columnVirtualizer.virtualPaddingLeft =
            leftNonPinnedStart - leftNonPinnedEnd;
        columnVirtualizer.virtualPaddingRight =
            totalSize -
                rightNonPinnedEnd -
                (numPinnedRight ? totalSize - rightNonPinnedStart : 0);
    }
    if (columnVirtualizerInstanceRef) {
        //@ts-ignore
        columnVirtualizerInstanceRef.current = columnVirtualizer;
    }
    return columnVirtualizer;
};

const useMRT_RowVirtualizer = (table, rows) => {
    var _a;
    const { getRowModel, getState, options: { enableRowVirtualization, renderDetailPanel, rowVirtualizerInstanceRef, rowVirtualizerOptions, }, refs: { tableContainerRef }, } = table;
    const { density, draggingRow, expanded } = getState();
    if (!enableRowVirtualization)
        return undefined;
    const rowVirtualizerProps = parseFromValuesOrFunc(rowVirtualizerOptions, {
        table,
    });
    const rowCount = (_a = rows === null || rows === void 0 ? void 0 : rows.length) !== null && _a !== void 0 ? _a : getRowModel().rows.length;
    const normalRowHeight = density === 'xs' ? 42.7 : density === 'md' ? 54.7 : 70.7;
    const rowVirtualizer = reactVirtual.useVirtualizer(Object.assign({ count: renderDetailPanel ? rowCount * 2 : rowCount, estimateSize: (index) => renderDetailPanel && index % 2 === 1
            ? expanded === true
                ? 100
                : 0
            : normalRowHeight, getScrollElement: () => tableContainerRef.current, measureElement: typeof window !== 'undefined' &&
            navigator.userAgent.indexOf('Firefox') === -1
            ? (element) => element === null || element === void 0 ? void 0 : element.getBoundingClientRect().height
            : undefined, overscan: 4, rangeExtractor: react.useCallback((range) => {
            var _a;
            return extraIndexRangeExtractor(range, (_a = draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.index) !== null && _a !== void 0 ? _a : 0);
        }, [draggingRow]) }, rowVirtualizerProps));
    rowVirtualizer.virtualRows = rowVirtualizer.getVirtualItems();
    if (rowVirtualizerInstanceRef) {
        //@ts-ignore
        rowVirtualizerInstanceRef.current = rowVirtualizer;
    }
    return rowVirtualizer;
};

const useMRT_Rows = (table) => {
    const { getRowModel, getState, options: { data, enableGlobalFilterRankedResults, positionCreatingRow }, } = table;
    const { creatingRow, expanded, globalFilter, pagination, rowPinning, sorting, } = getState();
    const rows = react.useMemo(() => getMRT_Rows(table), [
        creatingRow,
        data,
        enableGlobalFilterRankedResults,
        expanded,
        getRowModel().rows,
        globalFilter,
        pagination.pageIndex,
        pagination.pageSize,
        positionCreatingRow,
        rowPinning,
        sorting,
    ]);
    return rows;
};

var classes$y = {"root":"MRT_TablePaper-module_root__q0v5L"};

var classes$x = {"root":"MRT_TableContainer-module_root__JIsGB","root-sticky":"MRT_TableContainer-module_root-sticky__uC4qx","root-fullscreen":"MRT_TableContainer-module_root-fullscreen__aM8Jg"};

var classes$w = {"root":"MRT_Table-module_root__ms2uS","root-grid":"MRT_Table-module_root-grid__2Pynz"};

var classes$v = {"root":"MRT_TableBody-module_root__kGhRy","root-grid":"MRT_TableBody-module_root-grid__WdOGg","root-no-rows":"MRT_TableBody-module_root-no-rows__iyi9K","root-virtualized":"MRT_TableBody-module_root-virtualized__TxPAi","empty-row-tr-grid":"MRT_TableBody-module_empty-row-tr-grid__LTgxw","empty-row-td-grid":"MRT_TableBody-module_empty-row-td-grid__pzlgG","empty-row-td-content":"MRT_TableBody-module_empty-row-td-content__Cc2XW","pinned":"MRT_TableBody-module_pinned__XHpcs"};

var classes$u = {"root":"MRT_TableBodyRow-module_root__2c3D4","root-grid":"MRT_TableBodyRow-module_root-grid__AwXTe","root-virtualized":"MRT_TableBodyRow-module_root-virtualized__zYgxq"};

var classes$t = {"root":"MRT_TableBodyCell-module_root__Wf-zi","root-grid":"MRT_TableBodyCell-module_root-grid__zIuC-","root-virtualized":"MRT_TableBodyCell-module_root-virtualized__jLl8R","root-data-col":"MRT_TableBodyCell-module_root-data-col__HHcxc","root-nowrap":"MRT_TableBodyCell-module_root-nowrap__-k1Jo","root-cursor-pointer":"MRT_TableBodyCell-module_root-cursor-pointer__4kw7J","root-editable-hover":"MRT_TableBodyCell-module_root-editable-hover__2DKSa"};

const allowedTypes = ['string', 'number'];
const allowedFilterVariants = ['text', 'autocomplete'];
const MRT_TableBodyCellValue = ({ cell, renderedColumnIndex = 0, renderedRowIndex = 0, table, }) => {
    var _a, _b;
    const { getState, options: { enableFilterMatchHighlighting, mantineHighlightProps }, } = table;
    const { column, row } = cell;
    const { columnDef } = column;
    const { globalFilter, globalFilterFn } = getState();
    const filterValue = column.getFilterValue();
    const highlightProps = parseFromValuesOrFunc(mantineHighlightProps, {
        cell,
        column,
        row,
        table,
    });
    let renderedCellValue = cell.getIsAggregated() && columnDef.AggregatedCell
        ? columnDef.AggregatedCell({
            cell,
            column,
            row,
            table,
        })
        : row.getIsGrouped() && !cell.getIsGrouped()
            ? null
            : cell.getIsGrouped() && columnDef.GroupedCell
                ? columnDef.GroupedCell({
                    cell,
                    column,
                    row,
                    table,
                })
                : undefined;
    const isGroupedValue = renderedCellValue !== undefined;
    if (!isGroupedValue) {
        renderedCellValue = cell.renderValue();
    }
    if (enableFilterMatchHighlighting &&
        columnDef.enableFilterMatchHighlighting !== false &&
        renderedCellValue &&
        allowedTypes.includes(typeof renderedCellValue) &&
        ((filterValue &&
            allowedTypes.includes(typeof filterValue) &&
            allowedFilterVariants.includes(columnDef.filterVariant)) ||
            (globalFilter &&
                allowedTypes.includes(typeof globalFilter) &&
                column.getCanGlobalFilter()))) {
        let highlight = ((_b = (_a = column.getFilterValue()) !== null && _a !== void 0 ? _a : globalFilter) !== null && _b !== void 0 ? _b : '').toString();
        if ((filterValue ? columnDef._filterFn : globalFilterFn) === 'fuzzy') {
            highlight = highlight.split(' ');
        }
        renderedCellValue = (jsxRuntime.jsx(core.Highlight, Object.assign({ color: "yellow.3", highlight: highlight }, highlightProps, { children: renderedCellValue === null || renderedCellValue === void 0 ? void 0 : renderedCellValue.toString() })));
    }
    if (columnDef.Cell && !isGroupedValue) {
        renderedCellValue = columnDef.Cell({
            cell,
            column,
            renderedCellValue,
            renderedColumnIndex,
            renderedRowIndex,
            row,
            table,
        });
    }
    return renderedCellValue;
};

var classes$s = {"root":"MRT_CopyButton-module_root__mkXy4"};

const MRT_CopyButton = (_a) => {
    var { cell, children, table } = _a, rest = __rest(_a, ["cell", "children", "table"]);
    const { options: { localization: { clickToCopy, copiedToClipboard }, mantineCopyButtonProps, }, } = table;
    const { column, row } = cell;
    const { columnDef } = column;
    const arg = { cell, column, row, table };
    const buttonProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineCopyButtonProps, arg)), parseFromValuesOrFunc(columnDef.mantineCopyButtonProps, arg)), rest);
    return (jsxRuntime.jsx(core.CopyButton, { value: cell.getValue(), children: ({ copied, copy }) => {
            var _a;
            return (jsxRuntime.jsx(core.Tooltip, { color: copied ? 'green' : undefined, label: (_a = buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.title) !== null && _a !== void 0 ? _a : (copied ? copiedToClipboard : clickToCopy), openDelay: 1000, withinPortal: true, children: jsxRuntime.jsx(core.UnstyledButton, Object.assign({}, buttonProps, { className: clsx('mrt-copy-button', classes$s.root, buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.className), onClick: (e) => {
                        e.stopPropagation();
                        copy();
                    }, role: "presentation", title: undefined, children: children })) }));
        } }));
};

const MRT_EditCellTextInput = (_a) => {
    var _b;
    var { cell, table } = _a, rest = __rest(_a, ["cell", "table"]);
    const { getState, options: { createDisplayMode, editDisplayMode, mantineEditSelectProps, mantineEditTextInputProps, }, refs: { editInputRefs }, setCreatingRow, setEditingCell, setEditingRow, } = table;
    const { column, row } = cell;
    const { columnDef } = column;
    const { creatingRow, editingRow } = getState();
    const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;
    const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;
    const isSelectEdit = columnDef.editVariant === 'select';
    const [value, setValue] = react.useState(() => cell.getValue());
    const arg = { cell, column, row, table };
    const textInputProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineEditTextInputProps, arg)), parseFromValuesOrFunc(columnDef.mantineEditTextInputProps, arg)), rest);
    const selectProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineEditSelectProps, arg)), parseFromValuesOrFunc(columnDef.mantineEditSelectProps, arg)), rest);
    const saveInputValueToRowCache = (newValue) => {
        //@ts-ignore
        row._valuesCache[column.id] = newValue;
        if (isCreating) {
            setCreatingRow(row);
        }
        else if (isEditing) {
            setEditingRow(row);
        }
    };
    const handleBlur = (event) => {
        var _a;
        (_a = textInputProps.onBlur) === null || _a === void 0 ? void 0 : _a.call(textInputProps, event);
        saveInputValueToRowCache(value);
        setEditingCell(null);
    };
    const handleEnterKeyDown = (event) => {
        var _a, _b;
        (_a = textInputProps.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(textInputProps, event);
        if (event.key === 'Enter') {
            (_b = editInputRefs.current[cell.id]) === null || _b === void 0 ? void 0 : _b.blur();
        }
    };
    if (columnDef.Edit) {
        return (_b = columnDef.Edit) === null || _b === void 0 ? void 0 : _b.call(columnDef, { cell, column, row, table });
    }
    const commonProps = {
        disabled: parseFromValuesOrFunc(columnDef.enableEditing, row) === false,
        label: ['custom', 'modal'].includes((isCreating ? createDisplayMode : editDisplayMode))
            ? column.columnDef.header
            : undefined,
        name: cell.id,
        onClick: (e) => {
            var _a;
            e.stopPropagation();
            (_a = textInputProps === null || textInputProps === void 0 ? void 0 : textInputProps.onClick) === null || _a === void 0 ? void 0 : _a.call(textInputProps, e);
        },
        placeholder: !['custom', 'modal'].includes((isCreating ? createDisplayMode : editDisplayMode))
            ? columnDef.header
            : undefined,
        value,
        variant: editDisplayMode === 'table' ? 'unstyled' : 'default',
    };
    if (isSelectEdit) {
        return (
        // @ts-ignore
        jsxRuntime.jsx(core.Select, Object.assign({}, commonProps, { searchable: true, value: value }, selectProps, { onBlur: handleBlur, onChange: (value) => {
                var _a;
                (_a = selectProps.onChange) === null || _a === void 0 ? void 0 : _a.call(selectProps, value);
                setValue(value);
            }, onClick: (e) => {
                var _a;
                e.stopPropagation();
                (_a = selectProps === null || selectProps === void 0 ? void 0 : selectProps.onClick) === null || _a === void 0 ? void 0 : _a.call(selectProps, e);
            }, ref: (node) => {
                if (node) {
                    editInputRefs.current[cell.id] = node;
                    if (selectProps.ref) {
                        selectProps.ref.current = node;
                    }
                }
            } })));
    }
    return (jsxRuntime.jsx(core.TextInput, Object.assign({}, commonProps, { onKeyDown: handleEnterKeyDown, value: value !== null && value !== void 0 ? value : '' }, textInputProps, { onBlur: handleBlur, onChange: (event) => {
            var _a;
            (_a = textInputProps.onChange) === null || _a === void 0 ? void 0 : _a.call(textInputProps, event);
            setValue(event.target.value);
        }, onClick: (event) => {
            var _a;
            event.stopPropagation();
            (_a = textInputProps === null || textInputProps === void 0 ? void 0 : textInputProps.onClick) === null || _a === void 0 ? void 0 : _a.call(textInputProps, event);
        }, ref: (node) => {
            if (node) {
                editInputRefs.current[cell.id] = node;
                if (textInputProps.ref) {
                    textInputProps.ref.current = node;
                }
            }
        } })));
};

const MRT_TableBodyCell = (_a) => {
    var _b, _c, _d, _e, _f, _g, _h;
    var { cell, numRows = 1, renderedColumnIndex = 0, renderedRowIndex = 0, rowRef, table, virtualCell } = _a, rest = __rest(_a, ["cell", "numRows", "renderedColumnIndex", "renderedRowIndex", "rowRef", "table", "virtualCell"]);
    const direction = core.useDirection();
    const { getState, options: { columnResizeDirection, columnResizeMode, createDisplayMode, editDisplayMode, enableClickToCopy, enableColumnOrdering, enableColumnPinning, enableEditing, enableGrouping, layoutMode, mantineSkeletonProps, mantineTableBodyCellProps, }, refs: { editInputRefs }, setEditingCell, setHoveredColumn, } = table;
    const { columnSizingInfo, creatingRow, density, draggingColumn, editingCell, editingRow, hoveredColumn, isLoading, showSkeletons, } = getState();
    const { column, row } = cell;
    const { columnDef } = column;
    const { columnDefType } = columnDef;
    const args = {
        cell,
        column,
        renderedColumnIndex,
        renderedRowIndex,
        row,
        table,
    };
    const tableCellProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineTableBodyCellProps, args)), parseFromValuesOrFunc(columnDef.mantineTableBodyCellProps, args)), rest);
    const skeletonProps = parseFromValuesOrFunc(mantineSkeletonProps, args);
    const [skeletonWidth, setSkeletonWidth] = react.useState(100);
    react.useEffect(() => {
        if ((!isLoading && !showSkeletons) || skeletonWidth !== 100)
            return;
        const size = column.getSize();
        setSkeletonWidth(columnDefType === 'display'
            ? size / 2
            : Math.round(Math.random() * (size - size / 3) + size / 3));
    }, [isLoading, showSkeletons]);
    const widthStyles = {
        minWidth: `max(calc(var(--col-${parseCSSVarId(column === null || column === void 0 ? void 0 : column.id)}-size) * 1px), ${(_b = columnDef.minSize) !== null && _b !== void 0 ? _b : 30}px)`,
        width: `calc(var(--col-${parseCSSVarId(column.id)}-size) * 1px)`,
    };
    if (layoutMode === 'grid') {
        widthStyles.flex = `${[0, false].includes(columnDef.grow)
            ? 0
            : `var(--col-${parseCSSVarId(column.id)}-size)`} 0 auto`;
    }
    else if (layoutMode === 'grid-no-grow') {
        widthStyles.flex = `${+(columnDef.grow || 0)} 0 auto`;
    }
    const isDraggingColumn = (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id;
    const isHoveredColumn = (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id;
    const isColumnPinned = enableColumnPinning &&
        columnDef.columnDefType !== 'group' &&
        column.getIsPinned();
    const isEditable = !cell.getIsPlaceholder() &&
        (parseFromValuesOrFunc(enableEditing, row) &&
            parseFromValuesOrFunc(columnDef.enableEditing, row)) !== false;
    const isEditing = isEditable &&
        !['custom', 'modal'].includes(editDisplayMode) &&
        (editDisplayMode === 'table' ||
            (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id ||
            (editingCell === null || editingCell === void 0 ? void 0 : editingCell.id) === cell.id) &&
        !row.getIsGrouped();
    const isCreating = isEditable && createDisplayMode === 'row' && (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;
    const showClickToCopyButton = parseFromValuesOrFunc(enableClickToCopy, cell) ||
        (parseFromValuesOrFunc(columnDef.enableClickToCopy, cell) &&
            parseFromValuesOrFunc(columnDef.enableClickToCopy, cell) !== false);
    const handleDoubleClick = (event) => {
        var _a;
        (_a = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onDoubleClick) === null || _a === void 0 ? void 0 : _a.call(tableCellProps, event);
        if (isEditable && editDisplayMode === 'cell') {
            setEditingCell(cell);
            setTimeout(() => {
                var _a;
                const textField = editInputRefs.current[cell.id];
                if (textField) {
                    textField.focus();
                    (_a = textField.select) === null || _a === void 0 ? void 0 : _a.call(textField);
                }
            }, 100);
        }
    };
    const handleDragEnter = (e) => {
        var _a;
        (_a = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onDragEnter) === null || _a === void 0 ? void 0 : _a.call(tableCellProps, e);
        if (enableGrouping && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone') {
            setHoveredColumn(null);
        }
        if (enableColumnOrdering && draggingColumn) {
            setHoveredColumn(columnDef.enableColumnOrdering !== false ? column : null);
        }
    };
    const cellValueProps = {
        cell,
        renderedColumnIndex,
        renderedRowIndex,
        table,
    };
    return (jsxRuntime.jsx(core.TableTd, Object.assign({ "data-column-pinned": isColumnPinned || undefined, "data-dragging-column": isDraggingColumn || undefined, "data-first-right-pinned": (isColumnPinned === 'right' &&
            column.getIsLastColumn(isColumnPinned)) ||
            undefined, "data-hovered-column-target": isHoveredColumn || undefined, "data-index": renderedColumnIndex, "data-last-left-pinned": (isColumnPinned === 'left' && column.getIsLastColumn(isColumnPinned)) ||
            undefined, "data-last-row": renderedRowIndex === numRows - 1 || undefined, "data-resizing": (columnResizeMode === 'onChange' &&
            (columnSizingInfo === null || columnSizingInfo === void 0 ? void 0 : columnSizingInfo.isResizingColumn) === column.id &&
            columnResizeDirection) ||
            undefined }, tableCellProps, { __vars: Object.assign({ '--mrt-cell-align': (_c = tableCellProps.align) !== null && _c !== void 0 ? _c : (direction.dir === 'rtl' ? 'right' : 'left'), '--mrt-table-cell-left': isColumnPinned === 'left'
                ? `${column.getStart(isColumnPinned)}`
                : undefined, '--mrt-table-cell-right': isColumnPinned === 'right'
                ? `${column.getAfter(isColumnPinned)}`
                : undefined }, tableCellProps.__vars), className: clsx(classes$t.root, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$t['root-grid'], virtualCell && classes$t['root-virtualized'], isEditable &&
            editDisplayMode === 'cell' &&
            classes$t['root-cursor-pointer'], isEditable &&
            ['cell', 'table'].includes(editDisplayMode !== null && editDisplayMode !== void 0 ? editDisplayMode : '') &&
            columnDefType !== 'display' &&
            classes$t['root-editable-hover'], columnDefType === 'data' && classes$t['root-data-col'], density === 'xs' && classes$t['root-nowrap'], tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.className), onDoubleClick: handleDoubleClick, onDragEnter: handleDragEnter, style: (theme) => (Object.assign(Object.assign({}, widthStyles), parseFromValuesOrFunc(tableCellProps.style, theme))), children: (_d = tableCellProps.children) !== null && _d !== void 0 ? _d : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [cell.getIsPlaceholder() ? ((_f = (_e = columnDef.PlaceholderCell) === null || _e === void 0 ? void 0 : _e.call(columnDef, { cell, column, row, table })) !== null && _f !== void 0 ? _f : null) : showSkeletons !== false && (isLoading || showSkeletons) ? (jsxRuntime.jsx(core.Skeleton, Object.assign({ height: 20, width: skeletonWidth }, skeletonProps))) : columnDefType === 'display' &&
                    (['mrt-row-expand', 'mrt-row-numbers', 'mrt-row-select'].includes(column.id) ||
                        !row.getIsGrouped()) ? ((_g = columnDef.Cell) === null || _g === void 0 ? void 0 : _g.call(columnDef, Object.assign({ column, renderedCellValue: cell.renderValue(), row,
                    rowRef }, cellValueProps))) : isCreating || isEditing ? (jsxRuntime.jsx(MRT_EditCellTextInput, { cell: cell, table: table })) : showClickToCopyButton && columnDef.enableClickToCopy !== false ? (jsxRuntime.jsx(MRT_CopyButton, { cell: cell, table: table, children: jsxRuntime.jsx(MRT_TableBodyCellValue, Object.assign({}, cellValueProps)) })) : (jsxRuntime.jsx(MRT_TableBodyCellValue, Object.assign({}, cellValueProps))), cell.getIsGrouped() && !columnDef.GroupedCell && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [" (", (_h = row.subRows) === null || _h === void 0 ? void 0 : _h.length, ")"] }))] })) })));
};
const Memo_MRT_TableBodyCell = react.memo(MRT_TableBodyCell, (prev, next) => next.cell === prev.cell);

var classes$r = {"root":"MRT_TableDetailPanel-module_root__vQAlM","root-grid":"MRT_TableDetailPanel-module_root-grid__7UMC6","root-virtual-row":"MRT_TableDetailPanel-module_root-virtual-row__r-X4Z","inner":"MRT_TableDetailPanel-module_inner__o-Fk-","inner-grid":"MRT_TableDetailPanel-module_inner-grid__WLZgF","inner-expanded":"MRT_TableDetailPanel-module_inner-expanded__6tg9T","inner-virtual":"MRT_TableDetailPanel-module_inner-virtual__TItRy"};

const MRT_TableDetailPanel = (_a) => {
    var _b, _c;
    var { parentRowRef, renderedRowIndex = 0, row, rowVirtualizer, striped, table, virtualRow } = _a, rest = __rest(_a, ["parentRowRef", "renderedRowIndex", "row", "rowVirtualizer", "striped", "table", "virtualRow"]);
    const { getState, getVisibleLeafColumns, options: { layoutMode, mantineDetailPanelProps, mantineTableBodyRowProps, renderDetailPanel, }, } = table;
    const { isLoading } = getState();
    const tableRowProps = parseFromValuesOrFunc(mantineTableBodyRowProps, {
        isDetailPanel: true,
        row,
        table,
    });
    const tableCellProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineDetailPanelProps, {
        row,
        table,
    })), rest);
    const DetailPanel = !isLoading && row.getIsExpanded() && (renderDetailPanel === null || renderDetailPanel === void 0 ? void 0 : renderDetailPanel({ row, table }));
    return (jsxRuntime.jsx(core.TableTr, Object.assign({ "data-index": renderDetailPanel ? renderedRowIndex * 2 + 1 : renderedRowIndex, "data-striped": striped, ref: (node) => {
            var _a;
            if (node) {
                (_a = rowVirtualizer === null || rowVirtualizer === void 0 ? void 0 : rowVirtualizer.measureElement) === null || _a === void 0 ? void 0 : _a.call(rowVirtualizer, node);
            }
        } }, tableRowProps, { __vars: Object.assign({ '--mrt-parent-row-height': virtualRow
                ? `${(_c = (_b = parentRowRef.current) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect()) === null || _c === void 0 ? void 0 : _c.height}px`
                : undefined, '--mrt-virtual-row-start': virtualRow
                ? `${virtualRow.start}px`
                : undefined }, tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.__vars), className: clsx('mantine-Table-tr-detail-panel', classes$r.root, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$r['root-grid'], virtualRow && classes$r['root-virtual-row'], tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.className), children: jsxRuntime.jsx(core.TableTd, Object.assign({ colSpan: getVisibleLeafColumns().length, component: "td" }, tableCellProps, { __vars: {
                '--mrt-inner-width': `${table.getTotalSize()}px`,
            }, className: clsx('mantine-Table-td-detail-panel', classes$r.inner, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$r['inner-grid'], row.getIsExpanded() && classes$r['inner-expanded'], virtualRow && classes$r['inner-virtual']), p: row.getIsExpanded() && DetailPanel ? 'md' : 0, children: rowVirtualizer ? (row.getIsExpanded() && DetailPanel) : (jsxRuntime.jsx(core.Collapse, { in: row.getIsExpanded(), children: DetailPanel })) })) })));
};

const MRT_TableBodyRow = (_a) => {
    var _b, _c, _d;
    var { columnVirtualizer, numRows, pinnedRowIds, renderedRowIndex = 0, row, rowVirtualizer, table, tableProps, virtualRow } = _a, rest = __rest(_a, ["columnVirtualizer", "numRows", "pinnedRowIds", "renderedRowIndex", "row", "rowVirtualizer", "table", "tableProps", "virtualRow"]);
    const { getState, options: { enableRowOrdering, enableRowPinning, enableStickyFooter, enableStickyHeader, layoutMode, mantineTableBodyRowProps, memoMode, renderDetailPanel, rowPinningDisplayMode, }, refs: { tableFooterRef, tableHeadRef }, setHoveredRow, } = table;
    const { density, draggingColumn, draggingRow, editingCell, editingRow, hoveredRow, isFullScreen, rowPinning, } = getState();
    const visibleCells = row.getVisibleCells();
    const { virtualColumns, virtualPaddingLeft, virtualPaddingRight } = columnVirtualizer !== null && columnVirtualizer !== void 0 ? columnVirtualizer : {};
    const isRowSelected = getIsRowSelected({ row, table });
    const isRowPinned = enableRowPinning && row.getIsPinned();
    const isRowStickyPinned = isRowPinned && (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky')) && 'sticky';
    const isDraggingRow = (draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id) === row.id;
    const isHoveredRow = (hoveredRow === null || hoveredRow === void 0 ? void 0 : hoveredRow.id) === row.id;
    const tableRowProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineTableBodyRowProps, {
        renderedRowIndex,
        row,
        table,
    })), rest);
    const [bottomPinnedIndex, topPinnedIndex] = react.useMemo(() => {
        if (!enableRowPinning ||
            !isRowStickyPinned ||
            !pinnedRowIds ||
            !row.getIsPinned())
            return [];
        return [
            [...pinnedRowIds].reverse().indexOf(row.id),
            pinnedRowIds.indexOf(row.id),
        ];
    }, [pinnedRowIds, rowPinning]);
    const tableHeadHeight = ((enableStickyHeader || isFullScreen) &&
        ((_b = tableHeadRef.current) === null || _b === void 0 ? void 0 : _b.clientHeight)) ||
        0;
    const tableFooterHeight = (enableStickyFooter && ((_c = tableFooterRef.current) === null || _c === void 0 ? void 0 : _c.clientHeight)) || 0;
    const rowHeight = 
    // @ts-ignore
    parseInt((_d = tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.style) === null || _d === void 0 ? void 0 : _d.height, 10) ||
        (density === 'xs' ? 37 : density === 'md' ? 53 : 69);
    const handleDragEnter = (_e) => {
        if (enableRowOrdering && draggingRow) {
            setHoveredRow(row);
        }
    };
    const rowRef = react.useRef(null);
    let striped = tableProps.striped;
    if (striped) {
        if (striped === true) {
            striped = 'odd';
        }
        if (striped === 'odd' && renderedRowIndex % 2 !== 0) {
            striped = false;
        }
        if (striped === 'even' && renderedRowIndex % 2 === 0) {
            striped = false;
        }
    }
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs(core.TableTr, Object.assign({ "data-dragging-row": isDraggingRow || undefined, "data-hovered-row-target": isHoveredRow || undefined, "data-index": renderDetailPanel ? renderedRowIndex * 2 : renderedRowIndex, "data-row-pinned": isRowStickyPinned || isRowPinned || undefined, "data-selected": isRowSelected || undefined, "data-striped": striped, onDragEnter: handleDragEnter, ref: (node) => {
                    if (node) {
                        rowRef.current = node;
                        rowVirtualizer === null || rowVirtualizer === void 0 ? void 0 : rowVirtualizer.measureElement(node);
                    }
                } }, tableRowProps, { __vars: Object.assign(Object.assign({}, tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.__vars), { '--mrt-pinned-row-bottom': !virtualRow && bottomPinnedIndex !== undefined && isRowPinned
                        ? `${bottomPinnedIndex * rowHeight +
                            (enableStickyFooter ? tableFooterHeight - 1 : 0)}`
                        : undefined, '--mrt-pinned-row-top': virtualRow
                        ? undefined
                        : topPinnedIndex !== undefined && isRowPinned
                            ? `${topPinnedIndex * rowHeight +
                                (enableStickyHeader || isFullScreen ? tableHeadHeight - 1 : 0)}`
                            : undefined, '--mrt-virtual-row-start': virtualRow
                        ? `${virtualRow.start}`
                        : undefined }), className: clsx(classes$u.root, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$u['root-grid'], virtualRow && classes$u['root-virtualized'], tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.className), children: [virtualPaddingLeft ? (jsxRuntime.jsx(core.Box, { component: "td", display: "flex", w: virtualPaddingLeft })) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : row.getVisibleCells()).map((cellOrVirtualCell, renderedColumnIndex) => {
                        let cell = cellOrVirtualCell;
                        if (columnVirtualizer) {
                            renderedColumnIndex = cellOrVirtualCell
                                .index;
                            cell = visibleCells[renderedColumnIndex];
                        }
                        const cellProps = {
                            cell,
                            numRows,
                            renderedColumnIndex,
                            renderedRowIndex,
                            rowRef,
                            table,
                            virtualCell: columnVirtualizer
                                ? cellOrVirtualCell
                                : undefined,
                        };
                        return memoMode === 'cells' &&
                            cell.column.columnDef.columnDefType === 'data' &&
                            !draggingColumn &&
                            !draggingRow &&
                            (editingCell === null || editingCell === void 0 ? void 0 : editingCell.id) !== cell.id &&
                            (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) !== row.id ? (jsxRuntime.jsx(Memo_MRT_TableBodyCell, Object.assign({}, cellProps), cell.id)) : (jsxRuntime.jsx(MRT_TableBodyCell, Object.assign({}, cellProps), cell.id));
                    }), virtualPaddingRight ? (jsxRuntime.jsx(core.Box, { component: "td", display: "flex", w: virtualPaddingRight })) : null] })), renderDetailPanel && !row.getIsGrouped() && (jsxRuntime.jsx(MRT_TableDetailPanel, { parentRowRef: rowRef, renderedRowIndex: renderedRowIndex, row: row, rowVirtualizer: rowVirtualizer, striped: striped, table: table, virtualRow: virtualRow }))] }));
};
const Memo_MRT_TableBodyRow = react.memo(MRT_TableBodyRow, (prev, next) => prev.row === next.row);

const MRT_TableBody = (_a) => {
    var _b, _c, _d, _e, _f;
    var { columnVirtualizer, table, tableProps } = _a, rest = __rest(_a, ["columnVirtualizer", "table", "tableProps"]);
    const { getBottomRows, getIsSomeRowsPinned, getRowModel, getState, getTopRows, options: { enableStickyFooter, enableStickyHeader, layoutMode, localization, mantineTableBodyProps, memoMode, renderDetailPanel, renderEmptyRowsFallback, rowPinningDisplayMode, }, refs: { tableFooterRef, tableHeadRef, tablePaperRef }, } = table;
    const { columnFilters, globalFilter, isFullScreen, rowPinning } = getState();
    const tableBodyProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineTableBodyProps, { table })), rest);
    const tableHeadHeight = ((enableStickyHeader || isFullScreen) &&
        ((_b = tableHeadRef.current) === null || _b === void 0 ? void 0 : _b.clientHeight)) ||
        0;
    const tableFooterHeight = (enableStickyFooter && ((_c = tableFooterRef.current) === null || _c === void 0 ? void 0 : _c.clientHeight)) || 0;
    const pinnedRowIds = react.useMemo(() => {
        var _a, _b;
        if (!((_a = rowPinning.bottom) === null || _a === void 0 ? void 0 : _a.length) && !((_b = rowPinning.top) === null || _b === void 0 ? void 0 : _b.length))
            return [];
        return getRowModel()
            .rows.filter((row) => row.getIsPinned())
            .map((r) => r.id);
    }, [rowPinning, getRowModel().rows]);
    const rows = useMRT_Rows(table);
    const rowVirtualizer = useMRT_RowVirtualizer(table, rows);
    const { virtualRows } = rowVirtualizer !== null && rowVirtualizer !== void 0 ? rowVirtualizer : {};
    const commonRowProps = {
        columnVirtualizer,
        numRows: rows.length,
        table,
        tableProps,
    };
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [!(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky')) &&
                getIsSomeRowsPinned('top') && (jsxRuntime.jsx(core.TableTbody, Object.assign({}, tableBodyProps, { __vars: Object.assign({ '--mrt-table-head-height': `${tableHeadHeight}` }, tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.__vars), className: clsx(classes$v.pinned, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$v['root-grid'], tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.className), children: getTopRows().map((row, renderedRowIndex) => {
                    const rowProps = Object.assign(Object.assign({}, commonRowProps), { renderedRowIndex,
                        row });
                    return memoMode === 'rows' ? (jsxRuntime.jsx(Memo_MRT_TableBodyRow, Object.assign({}, rowProps), row.id)) : (jsxRuntime.jsx(MRT_TableBodyRow, Object.assign({}, rowProps), row.id));
                }) }))), jsxRuntime.jsx(core.TableTbody, Object.assign({}, tableBodyProps, { __vars: Object.assign({ '--mrt-table-body-height': rowVirtualizer
                        ? `${rowVirtualizer.getTotalSize()}px`
                        : undefined }, tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.__vars), className: clsx(classes$v.root, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$v['root-grid'], !rows.length && classes$v['root-no-rows'], rowVirtualizer && classes$v['root-virtualized'], tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.className), children: (_d = tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.children) !== null && _d !== void 0 ? _d : (!rows.length ? (jsxRuntime.jsx("tr", { className: clsx('mrt-table-body-row', (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$v['empty-row-tr-grid']), children: jsxRuntime.jsx("td", { className: clsx('mrt-table-body-cell', (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) &&
                            classes$v['empty-row-td-grid']), colSpan: table.getVisibleLeafColumns().length, children: (_e = renderEmptyRowsFallback === null || renderEmptyRowsFallback === void 0 ? void 0 : renderEmptyRowsFallback({ table })) !== null && _e !== void 0 ? _e : (jsxRuntime.jsx(core.Text, { __vars: {
                                '--mrt-paper-width': `${(_f = tablePaperRef.current) === null || _f === void 0 ? void 0 : _f.clientWidth}`,
                            }, className: clsx(classes$v['empty-row-td-content']), children: globalFilter || columnFilters.length
                                ? localization.noResultsFound
                                : localization.noRecordsToDisplay })) }) })) : (jsxRuntime.jsx(jsxRuntime.Fragment, { children: (virtualRows !== null && virtualRows !== void 0 ? virtualRows : rows).map((rowOrVirtualRow, renderedRowIndex) => {
                        if (rowVirtualizer) {
                            if (renderDetailPanel) {
                                if (rowOrVirtualRow.index % 2 === 1) {
                                    return null;
                                }
                                else {
                                    renderedRowIndex = rowOrVirtualRow.index / 2;
                                }
                            }
                            else {
                                renderedRowIndex = rowOrVirtualRow.index;
                            }
                        }
                        const row = rowVirtualizer
                            ? rows[renderedRowIndex]
                            : rowOrVirtualRow;
                        const props = Object.assign(Object.assign({}, commonRowProps), { pinnedRowIds,
                            renderedRowIndex,
                            row,
                            rowVirtualizer, virtualRow: rowVirtualizer
                                ? rowOrVirtualRow
                                : undefined });
                        const key = `${row.id}-${row.index}`;
                        return memoMode === 'rows' ? (jsxRuntime.jsx(Memo_MRT_TableBodyRow, Object.assign({}, props), key)) : (jsxRuntime.jsx(MRT_TableBodyRow, Object.assign({}, props), key));
                    }) }))) })), !(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes('sticky')) &&
                getIsSomeRowsPinned('bottom') && (jsxRuntime.jsx(core.TableTbody, Object.assign({}, tableBodyProps, { __vars: Object.assign({ '--mrt-table-footer-height': `${tableFooterHeight}` }, tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.__vars), className: clsx(classes$v.pinned, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$v['root-grid'], tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.className), children: getBottomRows().map((row, renderedRowIndex) => {
                    const props = Object.assign(Object.assign({}, commonRowProps), { renderedRowIndex,
                        row });
                    return memoMode === 'rows' ? (jsxRuntime.jsx(Memo_MRT_TableBodyRow, Object.assign({}, props), row.id)) : (jsxRuntime.jsx(MRT_TableBodyRow, Object.assign({}, props), row.id));
                }) })))] }));
};
const Memo_MRT_TableBody = react.memo(MRT_TableBody, (prev, next) => prev.table.options.data === next.table.options.data);

var classes$q = {"root":"MRT_TableFooter-module_root__-JXpw","grid":"MRT_TableFooter-module_grid__J3Ga-","sticky":"MRT_TableFooter-module_sticky__GcoK6"};

var classes$p = {"root":"MRT_TableFooterRow-module_root__EuoPr","layout-mode-grid":"MRT_TableFooterRow-module_layout-mode-grid__dUEMF"};

var classes$o = {"root":"MRT_TableFooterCell-module_root__d8Scs","grid":"MRT_TableFooterCell-module_grid__H9jLk","group":"MRT_TableFooterCell-module_group__l3-p-"};

const MRT_TableFooterCell = (_a) => {
    var _b, _c, _d, _e, _f;
    var { footer, renderedColumnIndex, table } = _a, rest = __rest(_a, ["footer", "renderedColumnIndex", "table"]);
    const direction = core.useDirection();
    const { options: { enableColumnPinning, layoutMode, mantineTableFooterCellProps }, } = table;
    const { column } = footer;
    const { columnDef } = column;
    const { columnDefType } = columnDef;
    const isColumnPinned = enableColumnPinning &&
        columnDef.columnDefType !== 'group' &&
        column.getIsPinned();
    const args = { column, table };
    const tableCellProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineTableFooterCellProps, args)), parseFromValuesOrFunc(columnDef.mantineTableFooterCellProps, args)), rest);
    const widthStyles = {
        minWidth: `max(calc(var(--header-${parseCSSVarId(footer === null || footer === void 0 ? void 0 : footer.id)}-size) * 1px), ${(_b = columnDef.minSize) !== null && _b !== void 0 ? _b : 30}px)`,
        width: `calc(var(--header-${parseCSSVarId(footer.id)}-size) * 1px)`,
    };
    if (layoutMode === 'grid') {
        widthStyles.flex = `${[0, false].includes(columnDef.grow)
            ? 0
            : `var(--header-${parseCSSVarId(footer.id)}-size)`} 0 auto`;
    }
    else if (layoutMode === 'grid-no-grow') {
        widthStyles.flex = `${+(columnDef.grow || 0)} 0 auto`;
    }
    return (jsxRuntime.jsx(core.TableTh, Object.assign({ colSpan: footer.colSpan, "data-column-pinned": isColumnPinned || undefined, "data-first-right-pinned": (isColumnPinned === 'right' &&
            column.getIsLastColumn(isColumnPinned)) ||
            undefined, "data-index": renderedColumnIndex, "data-last-left-pinned": (isColumnPinned === 'left' && column.getIsLastColumn(isColumnPinned)) ||
            undefined }, tableCellProps, { __vars: Object.assign({ '--mrt-cell-align': (_c = tableCellProps.align) !== null && _c !== void 0 ? _c : (columnDefType === 'group'
                ? 'center'
                : direction.dir === 'rtl'
                    ? 'right'
                    : 'left'), '--mrt-table-cell-left': isColumnPinned === 'left'
                ? `${column.getStart(isColumnPinned)}`
                : undefined, '--mrt-table-cell-right': isColumnPinned === 'right'
                ? `${column.getAfter(isColumnPinned)}`
                : undefined }, tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.__vars), className: clsx(classes$o.root, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$o.grid, columnDefType === 'group' && classes$o.group, tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.className), style: (theme) => (Object.assign(Object.assign({}, widthStyles), parseFromValuesOrFunc(tableCellProps.style, theme))), children: (_d = tableCellProps.children) !== null && _d !== void 0 ? _d : (footer.isPlaceholder
            ? null
            : (_f = (_e = parseFromValuesOrFunc(columnDef.Footer, {
                column,
                footer,
                table,
            })) !== null && _e !== void 0 ? _e : columnDef.footer) !== null && _f !== void 0 ? _f : null) })));
};

const MRT_TableFooterRow = (_a) => {
    var _b;
    var { columnVirtualizer, footerGroup, table } = _a, rest = __rest(_a, ["columnVirtualizer", "footerGroup", "table"]);
    const { options: { layoutMode, mantineTableFooterRowProps }, } = table;
    const { virtualColumns, virtualPaddingLeft, virtualPaddingRight } = columnVirtualizer !== null && columnVirtualizer !== void 0 ? columnVirtualizer : {};
    // if no content in row, skip row
    if (!((_b = footerGroup.headers) === null || _b === void 0 ? void 0 : _b.some((header) => (typeof header.column.columnDef.footer === 'string' &&
        !!header.column.columnDef.footer) ||
        header.column.columnDef.Footer))) {
        return null;
    }
    const tableRowProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineTableFooterRowProps, {
        footerGroup,
        table,
    })), rest);
    return (jsxRuntime.jsxs(core.TableTr, Object.assign({ className: clsx(classes$p.root, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$p['layout-mode-grid']) }, tableRowProps, { children: [virtualPaddingLeft ? (jsxRuntime.jsx(core.Box, { component: "th", display: "flex", w: virtualPaddingLeft })) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : footerGroup.headers).map((footerOrVirtualFooter, renderedColumnIndex) => {
                let footer = footerOrVirtualFooter;
                if (columnVirtualizer) {
                    renderedColumnIndex = footerOrVirtualFooter
                        .index;
                    footer = footerGroup.headers[renderedColumnIndex];
                }
                return (jsxRuntime.jsx(MRT_TableFooterCell, { footer: footer, renderedColumnIndex: renderedColumnIndex, table: table }, footer.id));
            }), virtualPaddingRight ? (jsxRuntime.jsx(core.Box, { component: "th", display: "flex", w: virtualPaddingRight })) : null] })));
};

const MRT_TableFooter = (_a) => {
    var { columnVirtualizer, table } = _a, rest = __rest(_a, ["columnVirtualizer", "table"]);
    const { getFooterGroups, getState, options: { enableStickyFooter, layoutMode, mantineTableFooterProps }, refs: { tableFooterRef }, } = table;
    const { isFullScreen } = getState();
    const tableFooterProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineTableFooterProps, {
        table,
    })), rest);
    const stickFooter = (isFullScreen || enableStickyFooter) && enableStickyFooter !== false;
    return (jsxRuntime.jsx(core.TableTfoot, Object.assign({}, tableFooterProps, { className: clsx(classes$q.root, tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.className, stickFooter && classes$q.sticky, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$q.grid), ref: (ref) => {
            tableFooterRef.current = ref;
            if (tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.ref) {
                // @ts-ignore
                tableFooterProps.ref.current = ref;
            }
        }, children: getFooterGroups().map((footerGroup) => (jsxRuntime.jsx(MRT_TableFooterRow, { columnVirtualizer: columnVirtualizer, footerGroup: footerGroup, table: table }, footerGroup.id))) })));
};

var classes$n = {"root":"MRT_TableHead-module_root__j9NkO","root-grid":"MRT_TableHead-module_root-grid__c3aGl","root-table-row-group":"MRT_TableHead-module_root-table-row-group__d9FO4","root-sticky":"MRT_TableHead-module_root-sticky__0kuDE","banner-tr":"MRT_TableHead-module_banner-tr__EhT-x","banner-th":"MRT_TableHead-module_banner-th__KwM5a","grid":"MRT_TableHead-module_grid__OJ-td"};

var classes$m = {"root":"MRT_TableHeadRow-module_root__hUKv4","layout-mode-grid":"MRT_TableHeadRow-module_layout-mode-grid__4ZGri","sticky":"MRT_TableHeadRow-module_sticky__Ej7Ax"};

var classes$l = {"root":"MRT_TableHeadCell-module_root__6y50a","root-grid":"MRT_TableHeadCell-module_root-grid__bAf1d","root-virtualized":"MRT_TableHeadCell-module_root-virtualized__CWLit","root-no-select":"MRT_TableHeadCell-module_root-no-select__BEOVU","content":"MRT_TableHeadCell-module_content__-pzSK","content-spaced":"MRT_TableHeadCell-module_content-spaced__S85Aa","content-center":"MRT_TableHeadCell-module_content-center__c-17L","content-right":"MRT_TableHeadCell-module_content-right__NSRZU","content-wrapper":"MRT_TableHeadCell-module_content-wrapper__py6aJ","content-wrapper-hidden-overflow":"MRT_TableHeadCell-module_content-wrapper-hidden-overflow__QY40r","content-wrapper-nowrap":"MRT_TableHeadCell-module_content-wrapper-nowrap__-4aIg","labels":"MRT_TableHeadCell-module_labels__oiMSr","labels-right":"MRT_TableHeadCell-module_labels-right__6ZJp-","labels-center":"MRT_TableHeadCell-module_labels-center__MM9q8","labels-sortable":"MRT_TableHeadCell-module_labels-sortable__tyuLr","labels-data":"MRT_TableHeadCell-module_labels-data__PvFGO","content-actions":"MRT_TableHeadCell-module_content-actions__utxbm"};

var classes$k = {"filter-mode-label":"MRT_TableHeadCellFilterContainer-module_filter-mode-label__8reK-"};

var classes$j = {"root":"MRT_FilterCheckBox-module_root__59h9r"};

const MRT_FilterCheckbox = (_a) => {
    var _b, _c, _d;
    var { column, table } = _a, rest = __rest(_a, ["column", "table"]);
    const { getState, options: { localization, mantineFilterCheckboxProps }, } = table;
    const { density } = getState();
    const { columnDef } = column;
    const arg = { column, table };
    const checkboxProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineFilterCheckboxProps, arg)), parseFromValuesOrFunc(columnDef.mantineFilterCheckboxProps, arg)), rest);
    const filterLabel = (_b = localization.filterByColumn) === null || _b === void 0 ? void 0 : _b.replace('{column}', columnDef.header);
    const value = column.getFilterValue();
    return (jsxRuntime.jsx(core.Tooltip, { label: (_c = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.title) !== null && _c !== void 0 ? _c : filterLabel, openDelay: 1000, withinPortal: true, children: jsxRuntime.jsx(core.Checkbox, Object.assign({ checked: value === 'true', className: clsx('mrt-filter-checkbox', classes$j.root), indeterminate: value === undefined, label: (_d = checkboxProps.title) !== null && _d !== void 0 ? _d : filterLabel, size: density === 'xs' ? 'sm' : 'md' }, checkboxProps, { onChange: (e) => {
                var _a;
                column.setFilterValue(column.getFilterValue() === undefined
                    ? 'true'
                    : column.getFilterValue() === 'true'
                        ? 'false'
                        : undefined);
                (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onChange) === null || _a === void 0 ? void 0 : _a.call(checkboxProps, e);
            }, onClick: (e) => {
                var _a;
                e.stopPropagation();
                (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a === void 0 ? void 0 : _a.call(checkboxProps, e);
            }, title: undefined })) }));
};

var classes$i = {"root":"MRT_FilterRangeFields-module_root__KfCcg"};

var classes$h = {"root":"MRT_FilterTextInput-module_root__Ss8Ql","date-filter":"MRT_FilterTextInput-module_date-filter__jOBLB","range-filter":"MRT_FilterTextInput-module_range-filter__JQHAL","not-filter-chip":"MRT_FilterTextInput-module_not-filter-chip__u8b1y","filter-chip-badge":"MRT_FilterTextInput-module_filter-chip-badge__Sel2k"};

const MRT_FilterTextInput = (_a) => {
    var _b, _c, _d, _e, _f, _g, _h, _j;
    var { header, rangeFilterIndex, table } = _a, rest = __rest(_a, ["header", "rangeFilterIndex", "table"]);
    const { options: { columnFilterDisplayMode, columnFilterModeOptions, icons: { IconX }, localization, mantineFilterAutocompleteProps, mantineFilterDateInputProps, mantineFilterMultiSelectProps, mantineFilterSelectProps, mantineFilterTextInputProps, manualFiltering, }, refs: { filterInputRefs }, setColumnFilterFns, } = table;
    const { column } = header;
    const { columnDef } = column;
    const arg = { column, rangeFilterIndex, table };
    const textInputProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineFilterTextInputProps, arg)), parseFromValuesOrFunc(columnDef.mantineFilterTextInputProps, arg)), rest);
    const selectProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineFilterSelectProps, arg)), parseFromValuesOrFunc(columnDef.mantineFilterSelectProps, arg));
    const multiSelectProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineFilterMultiSelectProps, arg)), parseFromValuesOrFunc(columnDef.mantineFilterMultiSelectProps, arg));
    const dateInputProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineFilterDateInputProps, arg)), parseFromValuesOrFunc(columnDef.mantineFilterDateInputProps, arg));
    const autoCompleteProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineFilterAutocompleteProps, arg)), parseFromValuesOrFunc(columnDef.mantineFilterAutocompleteProps, arg));
    const isRangeFilter = columnDef.filterVariant === 'range' ||
        columnDef.filterVariant === 'date-range' ||
        rangeFilterIndex !== undefined;
    const isSelectFilter = columnDef.filterVariant === 'select';
    const isMultiSelectFilter = columnDef.filterVariant === 'multi-select';
    const isDateFilter = columnDef.filterVariant === 'date' ||
        columnDef.filterVariant === 'date-range';
    const isAutoCompleteFilter = columnDef.filterVariant === 'autocomplete';
    const allowedColumnFilterOptions = (_b = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _b !== void 0 ? _b : columnFilterModeOptions;
    const currentFilterOption = columnDef._filterFn;
    const filterChipLabel = ['empty', 'notEmpty'].includes(currentFilterOption)
        ? localizedFilterOption(localization, currentFilterOption)
        : '';
    const filterPlaceholder = !isRangeFilter
        ? (_c = textInputProps === null || textInputProps === void 0 ? void 0 : textInputProps.placeholder) !== null && _c !== void 0 ? _c : (_d = localization.filterByColumn) === null || _d === void 0 ? void 0 : _d.replace('{column}', String(columnDef.header))
        : rangeFilterIndex === 0
            ? localization.min
            : rangeFilterIndex === 1
                ? localization.max
                : '';
    const facetedUniqueValues = column.getFacetedUniqueValues();
    const filterSelectOptions = react.useMemo(() => {
        var _a, _b, _c;
        return ((_c = (_b = (_a = autoCompleteProps === null || autoCompleteProps === void 0 ? void 0 : autoCompleteProps.data) !== null && _a !== void 0 ? _a : selectProps === null || selectProps === void 0 ? void 0 : selectProps.data) !== null && _b !== void 0 ? _b : multiSelectProps === null || multiSelectProps === void 0 ? void 0 : multiSelectProps.data) !== null && _c !== void 0 ? _c : ((isAutoCompleteFilter || isSelectFilter || isMultiSelectFilter) &&
            facetedUniqueValues
            ? Array.from(facetedUniqueValues.keys()).sort((a, b) => a.localeCompare(b))
            : []))
            //@ts-ignore
            .filter((o) => o !== undefined && o !== null);
    }, [
        autoCompleteProps === null || autoCompleteProps === void 0 ? void 0 : autoCompleteProps.data,
        facetedUniqueValues,
        isAutoCompleteFilter,
        isMultiSelectFilter,
        isSelectFilter,
        multiSelectProps === null || multiSelectProps === void 0 ? void 0 : multiSelectProps.data,
        selectProps === null || selectProps === void 0 ? void 0 : selectProps.data,
    ]);
    const isMounted = react.useRef(false);
    const [filterValue, setFilterValue] = react.useState(() => {
        var _a, _b;
        return isMultiSelectFilter
            ? column.getFilterValue() || []
            : isRangeFilter
                ? ((_a = column.getFilterValue()) === null || _a === void 0 ? void 0 : _a[rangeFilterIndex]) || ''
                : (_b = column.getFilterValue()) !== null && _b !== void 0 ? _b : '';
    });
    const [debouncedFilterValue] = hooks.useDebouncedValue(filterValue, manualFiltering ? 400 : 200);
    //send debounced filterValue to table instance
    react.useEffect(() => {
        if (!isMounted.current)
            return;
        if (isRangeFilter) {
            column.setFilterValue((old) => {
                const newFilterValues = Array.isArray(old) ? old : ['', ''];
                newFilterValues[rangeFilterIndex] =
                    debouncedFilterValue;
                return newFilterValues;
            });
        }
        else {
            column.setFilterValue(debouncedFilterValue !== null && debouncedFilterValue !== void 0 ? debouncedFilterValue : undefined);
        }
    }, [debouncedFilterValue]);
    //receive table filter value and set it to local state
    react.useEffect(() => {
        if (!isMounted.current) {
            isMounted.current = true;
            return;
        }
        const tableFilterValue = column.getFilterValue();
        if (tableFilterValue === undefined) {
            handleClear();
        }
        else if (isRangeFilter && rangeFilterIndex !== undefined) {
            setFilterValue((tableFilterValue !== null && tableFilterValue !== void 0 ? tableFilterValue : ['', ''])[rangeFilterIndex]);
        }
        else {
            setFilterValue(tableFilterValue !== null && tableFilterValue !== void 0 ? tableFilterValue : '');
        }
    }, [column.getFilterValue()]);
    const handleClear = () => {
        if (isMultiSelectFilter) {
            setFilterValue([]);
            column.setFilterValue([]);
        }
        else if (isRangeFilter) {
            setFilterValue('');
            column.setFilterValue((old) => {
                const newFilterValues = Array.isArray(old) ? old : ['', ''];
                newFilterValues[rangeFilterIndex] = undefined;
                return newFilterValues;
            });
        }
        else {
            setFilterValue('');
            column.setFilterValue(undefined);
        }
    };
    if (columnDef.Filter) {
        return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: (_e = columnDef.Filter) === null || _e === void 0 ? void 0 : _e.call(columnDef, { column, header, rangeFilterIndex, table }) }));
    }
    const handleClearEmptyFilterChip = () => {
        setFilterValue('');
        column.setFilterValue(undefined);
        setColumnFilterFns((prev) => {
            var _a;
            return (Object.assign(Object.assign({}, prev), { [header.id]: (_a = allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions[0]) !== null && _a !== void 0 ? _a : 'fuzzy' }));
        });
    };
    const _k = {
        'aria-label': filterPlaceholder,
        className: clsx('mrt-filter-text-input', classes$h.root, isDateFilter
            ? classes$h['date-filter']
            : isRangeFilter
                ? classes$h['range-filter']
                : !filterChipLabel && classes$h['not-filter-chip']),
        disabled: !!filterChipLabel,
        onChange: setFilterValue,
        onClick: (event) => event.stopPropagation(),
        placeholder: filterPlaceholder,
        style: Object.assign({}, (isMultiSelectFilter
            ? multiSelectProps === null || multiSelectProps === void 0 ? void 0 : multiSelectProps.style
            : isSelectFilter
                ? selectProps === null || selectProps === void 0 ? void 0 : selectProps.style
                : isDateFilter
                    ? dateInputProps === null || dateInputProps === void 0 ? void 0 : dateInputProps.style
                    : textInputProps === null || textInputProps === void 0 ? void 0 : textInputProps.style)),
        title: filterPlaceholder,
        value: filterValue,
        variant: 'unstyled',
    }, { className } = _k, commonProps = __rest(_k, ["className"]);
    const ClearButton = filterValue ? (jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.clearFilter, color: "var(--mantine-color-gray-7)", onClick: handleClear, size: "sm", title: (_f = localization.clearFilter) !== null && _f !== void 0 ? _f : '', variant: "transparent", children: jsxRuntime.jsx(IconX, {}) })) : null;
    return filterChipLabel ? (jsxRuntime.jsx(core.Box, { style: commonProps.style, children: jsxRuntime.jsx(core.Badge, { className: classes$h['filter-chip-badge'], onClick: handleClearEmptyFilterChip, rightSection: ClearButton, size: "lg", children: filterChipLabel }) })) : isMultiSelectFilter ? (jsxRuntime.jsx(core.MultiSelect, Object.assign({}, commonProps, { searchable: true }, multiSelectProps, { className: clsx(className, multiSelectProps.className), data: filterSelectOptions, onChange: (value) => setFilterValue(value), ref: (node) => {
            if (node) {
                filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] =
                    node;
                if (multiSelectProps.ref) {
                    multiSelectProps.ref.current = node;
                }
            }
        }, rightSection: ((_g = filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString()) === null || _g === void 0 ? void 0 : _g.length) ? ClearButton : undefined, style: commonProps.style }))) : isSelectFilter ? (jsxRuntime.jsx(core.Select, Object.assign({}, commonProps, { clearable: true, searchable: true }, selectProps, { className: clsx(className, selectProps.className), clearButtonProps: {
            size: 'md',
        }, data: filterSelectOptions, ref: (node) => {
            if (node) {
                filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] =
                    node;
                if (selectProps.ref) {
                    selectProps.ref.current = node;
                }
            }
        }, style: commonProps.style }))) : isDateFilter ? (jsxRuntime.jsx(dates.DateInput, Object.assign({}, commonProps, { allowDeselect: true, clearable: true, popoverProps: { withinPortal: columnFilterDisplayMode !== 'popover' } }, dateInputProps, { className: clsx(className, dateInputProps.className), ref: (node) => {
            if (node) {
                filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] =
                    node;
                if (dateInputProps.ref) {
                    dateInputProps.ref.current = node;
                }
            }
        }, style: commonProps.style }))) : isAutoCompleteFilter ? (jsxRuntime.jsx(core.Autocomplete, Object.assign({}, commonProps, { onChange: (value) => setFilterValue(value), rightSection: ((_h = filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString()) === null || _h === void 0 ? void 0 : _h.length) ? ClearButton : undefined }, autoCompleteProps, { className: clsx(className, autoCompleteProps.className), data: filterSelectOptions, ref: (node) => {
            if (node) {
                filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] =
                    node;
                if (autoCompleteProps.ref) {
                    autoCompleteProps.ref.current = node;
                }
            }
        }, style: commonProps.style }))) : (jsxRuntime.jsx(core.TextInput, Object.assign({}, commonProps, { onChange: (e) => setFilterValue(e.target.value), rightSection: ((_j = filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString()) === null || _j === void 0 ? void 0 : _j.length) ? ClearButton : undefined }, textInputProps, { className: clsx(className, textInputProps.className), mt: 0, ref: (node) => {
            if (node) {
                filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] =
                    node;
                if (textInputProps.ref) {
                    textInputProps.ref.current = node;
                }
            }
        }, style: commonProps.style })));
};

const MRT_FilterRangeFields = (_a) => {
    var { header, table } = _a, rest = __rest(_a, ["header", "table"]);
    return (jsxRuntime.jsxs(core.Box, Object.assign({}, rest, { className: clsx('mrt-filter-range-fields', classes$i.root, rest.className), children: [jsxRuntime.jsx(MRT_FilterTextInput, { header: header, rangeFilterIndex: 0, table: table }), jsxRuntime.jsx(MRT_FilterTextInput, { header: header, rangeFilterIndex: 1, table: table })] })));
};

var classes$g = {"root":"MRT_FilterRangeSlider-module_root__uwYEk"};

const MRT_FilterRangeSlider = (_a) => {
    var _b;
    var { header, table } = _a, rest = __rest(_a, ["header", "table"]);
    const { options: { mantineFilterRangeSliderProps }, refs: { filterInputRefs }, } = table;
    const { column } = header;
    const { columnDef } = column;
    const arg = { column, table };
    const rangeSliderProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineFilterRangeSliderProps, arg)), parseFromValuesOrFunc(columnDef.mantineFilterRangeSliderProps, arg)), rest);
    let [min, max] = rangeSliderProps.min !== undefined && rangeSliderProps.max !== undefined
        ? [rangeSliderProps.min, rangeSliderProps.max]
        : (_b = column.getFacetedMinMaxValues()) !== null && _b !== void 0 ? _b : [0, 1];
    //fix potential TanStack Table bugs where min or max is an array
    if (Array.isArray(min))
        min = min[0];
    if (Array.isArray(max))
        max = max[0];
    if (min === null)
        min = 0;
    if (max === null)
        max = 1;
    const [filterValues, setFilterValues] = react.useState([
        min,
        max,
    ]);
    const columnFilterValue = column.getFilterValue();
    const isMounted = react.useRef(false);
    react.useEffect(() => {
        if (isMounted.current) {
            if (columnFilterValue === undefined) {
                setFilterValues([min, max]);
            }
            else if (Array.isArray(columnFilterValue)) {
                setFilterValues(columnFilterValue);
            }
        }
        isMounted.current = true;
    }, [columnFilterValue, min, max]);
    return (jsxRuntime.jsx(core.RangeSlider, Object.assign({ className: clsx('mrt-filter-range-slider', classes$g.root), max: max, min: min, onChange: (values) => {
            setFilterValues(values);
        }, onChangeEnd: (values) => {
            if (Array.isArray(values)) {
                if (values[0] <= min && values[1] >= max) {
                    //if the user has selected the entire range, remove the filter
                    column.setFilterValue(undefined);
                }
                else {
                    column.setFilterValue(values);
                }
            }
        }, value: filterValues }, rangeSliderProps, { ref: (node) => {
            if (node) {
                //@ts-ignore
                filterInputRefs.current[`${column.id}-0`] = node;
                // @ts-ignore
                if (rangeSliderProps === null || rangeSliderProps === void 0 ? void 0 : rangeSliderProps.ref) {
                    //@ts-ignore
                    rangeSliderProps.ref = node;
                }
            }
        } })));
};

var classes$f = {"symbol":"MRT_FilterOptionMenu-module_symbol__a1Bsy"};

const mrtFilterOptions = (localization) => [
    {
        divider: false,
        label: localization.filterFuzzy,
        option: 'fuzzy',
        symbol: '',
    },
    {
        divider: false,
        label: localization.filterContains,
        option: 'contains',
        symbol: '*',
    },
    {
        divider: false,
        label: localization.filterStartsWith,
        option: 'startsWith',
        symbol: 'a',
    },
    {
        divider: true,
        label: localization.filterEndsWith,
        option: 'endsWith',
        symbol: 'z',
    },
    {
        divider: false,
        label: localization.filterEquals,
        option: 'equals',
        symbol: '=',
    },
    {
        divider: true,
        label: localization.filterNotEquals,
        option: 'notEquals',
        symbol: '',
    },
    {
        divider: false,
        label: localization.filterBetween,
        option: 'between',
        symbol: '',
    },
    {
        divider: true,
        label: localization.filterBetweenInclusive,
        option: 'betweenInclusive',
        symbol: '',
    },
    {
        divider: false,
        label: localization.filterGreaterThan,
        option: 'greaterThan',
        symbol: '>',
    },
    {
        divider: false,
        label: localization.filterGreaterThanOrEqualTo,
        option: 'greaterThanOrEqualTo',
        symbol: '',
    },
    {
        divider: false,
        label: localization.filterLessThan,
        option: 'lessThan',
        symbol: '<',
    },
    {
        divider: true,
        label: localization.filterLessThanOrEqualTo,
        option: 'lessThanOrEqualTo',
        symbol: '',
    },
    {
        divider: false,
        label: localization.filterEmpty,
        option: 'empty',
        symbol: '',
    },
    {
        divider: false,
        label: localization.filterNotEmpty,
        option: 'notEmpty',
        symbol: '!',
    },
];
const rangeModes = ['between', 'betweenInclusive', 'inNumberRange'];
const emptyModes = ['empty', 'notEmpty'];
const arrModes = ['arrIncludesSome', 'arrIncludesAll', 'arrIncludes'];
const rangeVariants = ['range-slider', 'date-range', 'range'];
const MRT_FilterOptionMenu = ({ header, onSelect, table, }) => {
    var _a, _b, _c, _d;
    const { getState, options: { columnFilterModeOptions, globalFilterModeOptions, localization, renderColumnFilterModeMenuItems, renderGlobalFilterModeMenuItems, }, setColumnFilterFns, setGlobalFilterFn, } = table;
    const { globalFilterFn } = getState();
    const { column } = header !== null && header !== void 0 ? header : {};
    const { columnDef } = column !== null && column !== void 0 ? column : {};
    const currentFilterValue = column === null || column === void 0 ? void 0 : column.getFilterValue();
    let allowedColumnFilterOptions = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _a !== void 0 ? _a : columnFilterModeOptions;
    if (rangeVariants.includes(columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant)) {
        allowedColumnFilterOptions = [
            ...rangeModes,
            ...(allowedColumnFilterOptions !== null && allowedColumnFilterOptions !== void 0 ? allowedColumnFilterOptions : []),
        ].filter((option) => rangeModes.includes(option));
    }
    const internalFilterOptions = react.useMemo(() => mrtFilterOptions(localization).filter((filterOption) => columnDef
        ? allowedColumnFilterOptions === undefined ||
            (allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.includes(filterOption.option))
        : (!globalFilterModeOptions ||
            globalFilterModeOptions.includes(filterOption.option)) &&
            ['contains', 'fuzzy', 'startsWith'].includes(filterOption.option)), []);
    const handleSelectFilterMode = (option) => {
        var _a;
        const prevFilterMode = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef._filterFn) !== null && _a !== void 0 ? _a : '';
        if (!header || !column) {
            // global filter mode
            setGlobalFilterFn(option);
        }
        else if (option !== prevFilterMode) {
            // column filter mode
            setColumnFilterFns((prev) => (Object.assign(Object.assign({}, prev), { [header.id]: option })));
            // reset filter value and/or perform new filter render
            if (emptyModes.includes(option)) {
                // will now be empty/notEmpty filter mode
                if (currentFilterValue !== ' ' &&
                    !emptyModes.includes(prevFilterMode)) {
                    column.setFilterValue(' ');
                }
                else if (currentFilterValue) {
                    column.setFilterValue(currentFilterValue); // perform new filter render
                }
            }
            else if ((columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant) === 'multi-select' ||
                arrModes.includes(option)) {
                // will now be array filter mode
                if (currentFilterValue instanceof String ||
                    (currentFilterValue === null || currentFilterValue === void 0 ? void 0 : currentFilterValue.length)) {
                    column.setFilterValue([]);
                }
                else if (currentFilterValue) {
                    column.setFilterValue(currentFilterValue); // perform new filter render
                }
            }
            else if (rangeVariants.includes(columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant) ||
                rangeModes.includes(option)) {
                // will now be range filter mode
                if (!Array.isArray(currentFilterValue) ||
                    (!(currentFilterValue === null || currentFilterValue === void 0 ? void 0 : currentFilterValue.every((v) => v === '')) &&
                        !rangeModes.includes(prevFilterMode))) {
                    column.setFilterValue(['', '']);
                }
                else {
                    column.setFilterValue(currentFilterValue); // perform new filter render
                }
            }
            else {
                // will now be single value filter mode
                if (Array.isArray(currentFilterValue)) {
                    column.setFilterValue('');
                }
                else if (currentFilterValue === ' ' &&
                    emptyModes.includes(prevFilterMode)) {
                    column.setFilterValue(undefined);
                }
                else {
                    column.setFilterValue(currentFilterValue); // perform new filter render
                }
            }
        }
        onSelect === null || onSelect === void 0 ? void 0 : onSelect();
    };
    const filterOption = !!header && columnDef ? columnDef._filterFn : globalFilterFn;
    return (jsxRuntime.jsx(core.Menu.Dropdown, { children: (_d = (header && column && columnDef
            ? (_c = (_b = columnDef.renderColumnFilterModeMenuItems) === null || _b === void 0 ? void 0 : _b.call(columnDef, {
                column: column,
                internalFilterOptions,
                onSelectFilterMode: handleSelectFilterMode,
                table,
            })) !== null && _c !== void 0 ? _c : renderColumnFilterModeMenuItems === null || renderColumnFilterModeMenuItems === void 0 ? void 0 : renderColumnFilterModeMenuItems({
                column: column,
                internalFilterOptions,
                onSelectFilterMode: handleSelectFilterMode,
                table,
            })
            : renderGlobalFilterModeMenuItems === null || renderGlobalFilterModeMenuItems === void 0 ? void 0 : renderGlobalFilterModeMenuItems({
                internalFilterOptions,
                onSelectFilterMode: handleSelectFilterMode,
                table,
            }))) !== null && _d !== void 0 ? _d : internalFilterOptions.map(({ divider, label, option, symbol }, index) => (jsxRuntime.jsxs(react.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, { color: option === filterOption ? 'blue' : undefined, leftSection: jsxRuntime.jsx("span", { className: classes$f.symbol, children: symbol }), onClick: () => handleSelectFilterMode(option), value: option, children: label }), divider && jsxRuntime.jsx(core.Menu.Divider, {})] }, index))) }));
};

const MRT_TableHeadCellFilterContainer = (_a) => {
    var _b, _c;
    var { header, table } = _a, rest = __rest(_a, ["header", "table"]);
    const { getState, options: { columnFilterDisplayMode, columnFilterModeOptions, enableColumnFilterModes, icons: { IconFilterCog }, localization, }, refs: { filterInputRefs }, } = table;
    const { showColumnFilters } = getState();
    const { column } = header;
    const { columnDef } = column;
    const currentFilterOption = columnDef._filterFn;
    const allowedColumnFilterOptions = (_b = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _b !== void 0 ? _b : columnFilterModeOptions;
    const showChangeModeButton = enableColumnFilterModes &&
        columnDef.enableColumnFilterModes !== false &&
        (allowedColumnFilterOptions === undefined ||
            !!(allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.length));
    return (jsxRuntime.jsx(core.Collapse, { in: showColumnFilters || columnFilterDisplayMode === 'popover', children: jsxRuntime.jsxs(core.Flex, Object.assign({ direction: "column" }, rest, { children: [jsxRuntime.jsxs(core.Flex, { align: "flex-end", children: [columnDef.filterVariant === 'checkbox' ? (jsxRuntime.jsx(MRT_FilterCheckbox, { column: column, table: table })) : columnDef.filterVariant === 'range-slider' ? (jsxRuntime.jsx(MRT_FilterRangeSlider, { header: header, table: table })) : ['date-range', 'range'].includes((_c = columnDef.filterVariant) !== null && _c !== void 0 ? _c : '') ||
                            ['between', 'betweenInclusive', 'inNumberRange'].includes(columnDef._filterFn) ? (jsxRuntime.jsx(MRT_FilterRangeFields, { header: header, table: table })) : (jsxRuntime.jsx(MRT_FilterTextInput, { header: header, table: table })), showChangeModeButton && (jsxRuntime.jsxs(core.Menu, { withinPortal: columnFilterDisplayMode !== 'popover', children: [jsxRuntime.jsx(core.Tooltip, { label: localization.changeFilterMode, position: "bottom-start", withinPortal: true, children: jsxRuntime.jsx(core.Menu.Target, { children: jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.changeFilterMode, color: "gray", size: "md", variant: "subtle", children: jsxRuntime.jsx(IconFilterCog, {}) }) }) }), jsxRuntime.jsx(MRT_FilterOptionMenu, { header: header, onSelect: () => setTimeout(() => { var _a; return (_a = filterInputRefs.current[`${column.id}-0`]) === null || _a === void 0 ? void 0 : _a.focus(); }, 100), table: table })] }))] }), showChangeModeButton ? (jsxRuntime.jsx(core.Text, { c: "dimmed", className: classes$k['filter-mode-label'], component: "label", children: localization.filterMode.replace('{filterType}', localizedFilterOption(localization, currentFilterOption)) })) : null] })) }));
};

var classes$e = {"root":"MRT_TableHeadCellFilterLabel-module_root__Rur2R"};

const MRT_TableHeadCellFilterLabel = (_a) => {
    var _b, _c, _d;
    var { header, table } = _a, rest = __rest(_a, ["header", "table"]);
    const { options: { columnFilterDisplayMode, icons: { IconFilter }, localization, }, refs: { filterInputRefs }, setShowColumnFilters, } = table;
    const { column } = header;
    const { columnDef } = column;
    const filterValue = column.getFilterValue();
    const [popoverOpened, setPopoverOpened] = react.useState(false);
    const isFilterActive = (Array.isArray(filterValue) && filterValue.some(Boolean)) ||
        (!!filterValue && !Array.isArray(filterValue));
    const isRangeFilter = columnDef.filterVariant === 'range' ||
        ['between', 'betweenInclusive', 'inNumberRange'].includes(columnDef._filterFn);
    const currentFilterOption = columnDef._filterFn;
    const filterTooltip = columnFilterDisplayMode === 'popover' && !isFilterActive
        ? (_b = localization.filterByColumn) === null || _b === void 0 ? void 0 : _b.replace('{column}', String(columnDef.header))
        : localization.filteringByColumn
            .replace('{column}', String(columnDef.header))
            .replace('{filterType}', localizedFilterOption(localization, currentFilterOption))
            .replace('{filterValue}', `"${Array.isArray(column.getFilterValue())
            ? column.getFilterValue().join(`" ${isRangeFilter ? localization.and : localization.or} "`)
            : column.getFilterValue()}"`)
            .replace('" "', '');
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsxs(core.Popover, { keepMounted: columnDef.filterVariant === 'range-slider', onClose: () => setPopoverOpened(false), opened: popoverOpened, position: "top", shadow: "xl", width: 360, withinPortal: true, children: [jsxRuntime.jsx(core.Transition, { mounted: columnFilterDisplayMode === 'popover' ||
                        (!!column.getFilterValue() && !isRangeFilter) ||
                        (isRangeFilter &&
                            (!!((_c = column.getFilterValue()) === null || _c === void 0 ? void 0 : _c[0]) ||
                                !!((_d = column.getFilterValue()) === null || _d === void 0 ? void 0 : _d[1]))), transition: "scale", children: () => (jsxRuntime.jsx(core.Popover.Target, { children: jsxRuntime.jsx(core.Tooltip, { disabled: popoverOpened, label: filterTooltip, multiline: true, w: filterTooltip.length > 40 ? 300 : undefined, withinPortal: true, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ className: clsx('mrt-table-head-cell-filter-label-icon', classes$e.root), size: 18 }, dataVariable('active', isFilterActive), { onClick: (event) => {
                                    event.stopPropagation();
                                    if (columnFilterDisplayMode === 'popover') {
                                        setPopoverOpened((opened) => !opened);
                                    }
                                    else {
                                        setShowColumnFilters(true);
                                    }
                                    setTimeout(() => {
                                        const input = filterInputRefs.current[`${column.id}-0`];
                                        input === null || input === void 0 ? void 0 : input.focus();
                                        input === null || input === void 0 ? void 0 : input.select();
                                    }, 100);
                                } }, rest, { children: jsxRuntime.jsx(IconFilter, { size: "100%" }) })) }) })) }), columnFilterDisplayMode === 'popover' && (jsxRuntime.jsx(core.Popover.Dropdown, { onClick: (event) => event.stopPropagation(), onKeyDown: (event) => event.key === 'Enter' && setPopoverOpened(false), children: jsxRuntime.jsx(MRT_TableHeadCellFilterContainer, { header: header, table: table }) }))] }) }));
};

const MRT_TableHeadCellGrabHandle = (_a) => {
    var { column, table, tableHeadCellRef } = _a, rest = __rest(_a, ["column", "table", "tableHeadCellRef"]);
    const { getState, options: { enableColumnOrdering, mantineColumnDragHandleProps }, setColumnOrder, setDraggingColumn, setHoveredColumn, } = table;
    const { columnDef } = column;
    const { columnOrder, draggingColumn, hoveredColumn } = getState();
    const arg = { column, table };
    const actionIconProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineColumnDragHandleProps, arg)), parseFromValuesOrFunc(columnDef.mantineColumnDragHandleProps, arg)), rest);
    const handleDragStart = (event) => {
        var _a;
        (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onDragStart) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, event);
        setDraggingColumn(column);
        event.dataTransfer.setDragImage(tableHeadCellRef.current, 0, 0);
    };
    const handleDragEnd = (event) => {
        var _a;
        (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onDragEnd) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, event);
        if ((hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone') {
            column.toggleGrouping();
        }
        else if (enableColumnOrdering &&
            hoveredColumn &&
            (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) !== (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id)) {
            setColumnOrder(reorderColumn(column, hoveredColumn, columnOrder));
        }
        setDraggingColumn(null);
        setHoveredColumn(null);
    };
    return (jsxRuntime.jsx(MRT_GrabHandleButton, { actionIconProps: actionIconProps, onDragEnd: handleDragEnd, onDragStart: handleDragStart, table: table }));
};

var classes$d = {"root":"MRT_TableHeadCellResizeHandle-module_root__paufe","root-ltr":"MRT_TableHeadCellResizeHandle-module_root-ltr__652AZ","root-rtl":"MRT_TableHeadCellResizeHandle-module_root-rtl__5VlSo","root-hide":"MRT_TableHeadCellResizeHandle-module_root-hide__-ILlD"};

const MRT_TableHeadCellResizeHandle = (_a) => {
    var _b;
    var { header, table } = _a, rest = __rest(_a, ["header", "table"]);
    const { getState, options: { columnResizeDirection, columnResizeMode }, setColumnSizingInfo, } = table;
    const { density } = getState();
    const { column } = header;
    const handler = header.getResizeHandler();
    const offset = column.getIsResizing() && columnResizeMode === 'onEnd'
        ? `translateX(${(columnResizeDirection === 'rtl' ? -1 : 1) *
            ((_b = getState().columnSizingInfo.deltaOffset) !== null && _b !== void 0 ? _b : 0)}px)`
        : undefined;
    return (jsxRuntime.jsx(core.Box, Object.assign({ onDoubleClick: () => {
            setColumnSizingInfo((old) => (Object.assign(Object.assign({}, old), { isResizingColumn: false })));
            column.resetSize();
        }, onMouseDown: handler, onTouchStart: handler, role: "separator" }, rest, { __vars: Object.assign({ '--mrt-transform': offset }, rest.__vars), className: clsx('mrt-table-head-cell-resize-handle', classes$d.root, classes$d[`root-${columnResizeDirection}`], !header.subHeaders.length &&
            columnResizeMode === 'onChange' &&
            classes$d['root-hide'], density, rest.className) })));
};

var classes$c = {"sort-icon":"MRT_TableHeadCellSortLabel-module_sort-icon__zs1xA","multi-sort-indicator":"MRT_TableHeadCellSortLabel-module_multi-sort-indicator__MGBj2"};

const MRT_TableHeadCellSortLabel = (_a) => {
    var { header, table } = _a, rest = __rest(_a, ["header", "table"]);
    const { getState, options: { icons: { IconArrowsSort, IconSortAscending, IconSortDescending }, localization, }, } = table;
    const column = header.column;
    const { columnDef } = column;
    const { sorting } = getState();
    const sorted = column.getIsSorted();
    const sortIndex = column.getSortIndex();
    const sortTooltip = sorted
        ? sorted === 'desc'
            ? localization.sortedByColumnDesc.replace('{column}', columnDef.header)
            : localization.sortedByColumnAsc.replace('{column}', columnDef.header)
        : column.getNextSortingOrder() === 'desc'
            ? localization.sortByColumnDesc.replace('{column}', columnDef.header)
            : localization.sortByColumnAsc.replace('{column}', columnDef.header);
    const SortActionButton = (jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": sortTooltip }, dataVariable('sorted', sorted), rest, { className: clsx('mrt-table-head-sort-button', classes$c['sort-icon'], rest.className), children: sorted === 'desc' ? (jsxRuntime.jsx(IconSortDescending, { size: "100%" })) : sorted === 'asc' ? (jsxRuntime.jsx(IconSortAscending, { size: "100%" })) : (jsxRuntime.jsx(IconArrowsSort, { size: "100%" })) })));
    return (jsxRuntime.jsx(core.Tooltip, { label: sortTooltip, openDelay: 1000, withinPortal: true, children: sorting.length < 2 || sortIndex === -1 ? (SortActionButton) : (jsxRuntime.jsx(core.Indicator, { className: clsx('mrt-table-head-multi-sort-indicator', classes$c['multi-sort-indicator']), inline: true, label: sortIndex + 1, offset: 4, children: SortActionButton })) }));
};

var classes$b = {"left":"MRT_ColumnActionMenu-module_left__cfNmY","right":"MRT_ColumnActionMenu-module_right__-nK56"};

const MRT_ColumnActionMenu = (_a) => {
    var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    var { header, table } = _a, rest = __rest(_a, ["header", "table"]);
    const { getState, options: { columnFilterDisplayMode, enableColumnFilters, enableColumnPinning, enableColumnResizing, enableGrouping, enableHiding, enableSorting, enableSortingRemoval, icons: { IconArrowAutofitContent, IconBoxMultiple, IconClearAll, IconColumns, IconDotsVertical, IconEyeOff, IconFilter, IconFilterOff, IconPinned, IconPinnedOff, IconSortAscending, IconSortDescending, }, localization, mantineColumnActionsButtonProps, renderColumnActionsMenuItems, }, refs: { filterInputRefs }, setColumnOrder, setColumnSizingInfo, setShowColumnFilters, toggleAllColumnsVisible, } = table;
    const { column } = header;
    const { columnDef } = column;
    const { columnSizing, columnVisibility } = getState();
    const arg = { column, table };
    const actionIconProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineColumnActionsButtonProps, arg)), parseFromValuesOrFunc(columnDef.mantineColumnActionsButtonProps, arg));
    const handleClearSort = () => {
        column.clearSorting();
    };
    const handleSortAsc = () => {
        column.toggleSorting(false);
    };
    const handleSortDesc = () => {
        column.toggleSorting(true);
    };
    const handleResetColumnSize = () => {
        setColumnSizingInfo((old) => (Object.assign(Object.assign({}, old), { isResizingColumn: false })));
        column.resetSize();
    };
    const handleHideColumn = () => {
        column.toggleVisibility(false);
    };
    const handlePinColumn = (pinDirection) => {
        column.pin(pinDirection);
    };
    const handleGroupByColumn = () => {
        column.toggleGrouping();
        setColumnOrder((old) => ['mrt-row-expand', ...old]);
    };
    const handleClearFilter = () => {
        column.setFilterValue('');
    };
    const handleFilterByColumn = () => {
        setShowColumnFilters(true);
        setTimeout(() => { var _a; return (_a = filterInputRefs.current[`${column.id}-0`]) === null || _a === void 0 ? void 0 : _a.focus(); }, 100);
    };
    const handleShowAllColumns = () => {
        toggleAllColumnsVisible(true);
    };
    const internalColumnMenuItems = (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [enableSorting && column.getCanSort() && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [enableSortingRemoval !== false && (jsxRuntime.jsx(core.Menu.Item, { disabled: !column.getIsSorted(), leftSection: jsxRuntime.jsx(IconClearAll, {}), onClick: handleClearSort, children: localization.clearSort })), jsxRuntime.jsx(core.Menu.Item, { disabled: column.getIsSorted() === 'asc', leftSection: jsxRuntime.jsx(IconSortAscending, {}), onClick: handleSortAsc, children: (_b = localization.sortByColumnAsc) === null || _b === void 0 ? void 0 : _b.replace('{column}', String(columnDef.header)) }), jsxRuntime.jsx(core.Menu.Item, { disabled: column.getIsSorted() === 'desc', leftSection: jsxRuntime.jsx(IconSortDescending, {}), onClick: handleSortDesc, children: (_c = localization.sortByColumnDesc) === null || _c === void 0 ? void 0 : _c.replace('{column}', String(columnDef.header)) }), (enableColumnFilters || enableGrouping || enableHiding) && (jsxRuntime.jsx(core.Menu.Divider, {}, 3))] })), enableColumnFilters &&
                columnFilterDisplayMode !== 'popover' &&
                column.getCanFilter() && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, { disabled: !column.getFilterValue(), leftSection: jsxRuntime.jsx(IconFilterOff, {}), onClick: handleClearFilter, children: localization.clearFilter }), jsxRuntime.jsx(core.Menu.Item, { leftSection: jsxRuntime.jsx(IconFilter, {}), onClick: handleFilterByColumn, children: (_d = localization.filterByColumn) === null || _d === void 0 ? void 0 : _d.replace('{column}', String(columnDef.header)) }), (enableGrouping || enableHiding) && jsxRuntime.jsx(core.Menu.Divider, {}, 2)] })), enableGrouping && column.getCanGroup() && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, { leftSection: jsxRuntime.jsx(IconBoxMultiple, {}), onClick: handleGroupByColumn, children: (_e = localization[column.getIsGrouped() ? 'ungroupByColumn' : 'groupByColumn']) === null || _e === void 0 ? void 0 : _e.replace('{column}', String(columnDef.header)) }), enableColumnPinning && jsxRuntime.jsx(core.Menu.Divider, {})] })), enableColumnPinning && column.getCanPin() && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, { disabled: column.getIsPinned() === 'left' || !column.getCanPin(), leftSection: jsxRuntime.jsx(IconPinned, { className: classes$b.left }), onClick: () => handlePinColumn('left'), children: localization.pinToLeft }), jsxRuntime.jsx(core.Menu.Item, { disabled: column.getIsPinned() === 'right' || !column.getCanPin(), leftSection: jsxRuntime.jsx(IconPinned, { className: classes$b.right }), onClick: () => handlePinColumn('right'), children: localization.pinToRight }), jsxRuntime.jsx(core.Menu.Item, { disabled: !column.getIsPinned(), leftSection: jsxRuntime.jsx(IconPinnedOff, {}), onClick: () => handlePinColumn(false), children: localization.unpin }), enableHiding && jsxRuntime.jsx(core.Menu.Divider, {})] })), enableColumnResizing && column.getCanResize() && (jsxRuntime.jsx(core.Menu.Item, { disabled: !columnSizing[column.id], leftSection: jsxRuntime.jsx(IconArrowAutofitContent, {}), onClick: handleResetColumnSize, children: localization.resetColumnSize }, 0)), enableHiding && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, { disabled: !column.getCanHide(), leftSection: jsxRuntime.jsx(IconEyeOff, {}), onClick: handleHideColumn, children: (_f = localization.hideColumn) === null || _f === void 0 ? void 0 : _f.replace('{column}', String(columnDef.header)) }, 0), jsxRuntime.jsx(core.Menu.Item, { disabled: !Object.values(columnVisibility).filter((visible) => !visible)
                            .length, leftSection: jsxRuntime.jsx(IconColumns, {}), onClick: handleShowAllColumns, children: (_g = localization.showAllColumns) === null || _g === void 0 ? void 0 : _g.replace('{column}', String(columnDef.header)) }, 1)] }))] }));
    return (jsxRuntime.jsxs(core.Menu, Object.assign({ closeOnItemClick: true, position: "bottom-start", withinPortal: true }, rest, { children: [jsxRuntime.jsx(core.Tooltip, { label: (_h = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.title) !== null && _h !== void 0 ? _h : localization.columnActions, openDelay: 1000, withinPortal: true, children: jsxRuntime.jsx(core.Menu.Target, { children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": localization.columnActions, color: "gray", size: "sm", variant: "subtle" }, actionIconProps, { children: jsxRuntime.jsx(IconDotsVertical, { size: "100%" }) })) }) }), jsxRuntime.jsx(core.Menu.Dropdown, { children: (_l = (_k = (_j = columnDef.renderColumnActionsMenuItems) === null || _j === void 0 ? void 0 : _j.call(columnDef, {
                    column,
                    internalColumnMenuItems,
                    table,
                })) !== null && _k !== void 0 ? _k : renderColumnActionsMenuItems === null || renderColumnActionsMenuItems === void 0 ? void 0 : renderColumnActionsMenuItems({
                    column,
                    internalColumnMenuItems,
                    table,
                })) !== null && _l !== void 0 ? _l : internalColumnMenuItems })] })));
};

const MRT_TableHeadCell = (_a) => {
    var _b, _c, _d, _f, _g, _h;
    var { columnVirtualizer, header, renderedHeaderIndex = 0, table } = _a, rest = __rest(_a, ["columnVirtualizer", "header", "renderedHeaderIndex", "table"]);
    const direction = core.useDirection();
    const { getState, options: { columnFilterDisplayMode, columnResizeDirection, columnResizeMode, enableColumnActions, enableColumnDragging, enableColumnOrdering, enableColumnPinning, enableGrouping, enableMultiSort, layoutMode, mantineTableHeadCellProps, }, refs: { tableHeadCellRefs }, setHoveredColumn, } = table;
    const { columnSizingInfo, density, draggingColumn, grouping, hoveredColumn } = getState();
    const { column } = header;
    const { columnDef } = column;
    const { columnDefType } = columnDef;
    const arg = { column, table };
    const tableCellProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineTableHeadCellProps, arg)), parseFromValuesOrFunc(columnDef.mantineTableHeadCellProps, arg)), rest);
    const widthStyles = {
        minWidth: `max(calc(var(--header-${parseCSSVarId(header === null || header === void 0 ? void 0 : header.id)}-size) * 1px), ${(_b = columnDef.minSize) !== null && _b !== void 0 ? _b : 30}px)`,
        width: `calc(var(--header-${parseCSSVarId(header.id)}-size) * 1px)`,
    };
    if (layoutMode === 'grid') {
        widthStyles.flex = `${[0, false].includes(columnDef.grow)
            ? 0
            : `var(--header-${parseCSSVarId(header.id)}-size)`} 0 auto`;
    }
    else if (layoutMode === 'grid-no-grow') {
        widthStyles.flex = `${+(columnDef.grow || 0)} 0 auto`;
    }
    const isColumnPinned = enableColumnPinning &&
        columnDef.columnDefType !== 'group' &&
        column.getIsPinned();
    const isDraggingColumn = (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id;
    const isHoveredColumn = (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id;
    const showColumnActions = (enableColumnActions || columnDef.enableColumnActions) &&
        columnDef.enableColumnActions !== false;
    const showDragHandle = enableColumnDragging !== false &&
        columnDef.enableColumnDragging !== false &&
        (enableColumnDragging ||
            (enableColumnOrdering && columnDef.enableColumnOrdering !== false) ||
            (enableGrouping &&
                columnDef.enableGrouping !== false &&
                !grouping.includes(column.id)));
    const headerPL = react.useMemo(() => {
        let pl = 0;
        if (column.getCanSort())
            pl++;
        if (showColumnActions)
            pl += 1.75;
        if (showDragHandle)
            pl += 1.25;
        return pl;
    }, [showColumnActions, showDragHandle]);
    const handleDragEnter = (_e) => {
        if (enableGrouping && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone') {
            setHoveredColumn(null);
        }
        if (enableColumnOrdering && draggingColumn && columnDefType !== 'group') {
            setHoveredColumn(columnDef.enableColumnOrdering !== false ? column : null);
        }
    };
    const headerElement = (columnDef === null || columnDef === void 0 ? void 0 : columnDef.Header) instanceof Function
        ? (_c = columnDef === null || columnDef === void 0 ? void 0 : columnDef.Header) === null || _c === void 0 ? void 0 : _c.call(columnDef, {
            column,
            header,
            table,
        })
        : (_d = columnDef === null || columnDef === void 0 ? void 0 : columnDef.Header) !== null && _d !== void 0 ? _d : columnDef.header;
    return (jsxRuntime.jsxs(core.TableTh, Object.assign({ colSpan: header.colSpan, "data-column-pinned": isColumnPinned || undefined, "data-dragging-column": isDraggingColumn || undefined, "data-first-right-pinned": (isColumnPinned === 'right' &&
            column.getIsLastColumn(isColumnPinned)) ||
            undefined, "data-hovered-column-target": isHoveredColumn || undefined, "data-index": renderedHeaderIndex, "data-last-left-pinned": (isColumnPinned === 'left' && column.getIsLastColumn(isColumnPinned)) ||
            undefined, "data-resizing": (columnResizeMode === 'onChange' &&
            (columnSizingInfo === null || columnSizingInfo === void 0 ? void 0 : columnSizingInfo.isResizingColumn) === column.id &&
            columnResizeDirection) ||
            undefined }, tableCellProps, { __vars: {
            '--mrt-table-cell-left': isColumnPinned === 'left'
                ? `${column.getStart(isColumnPinned)}`
                : undefined,
            '--mrt-table-cell-right': isColumnPinned === 'right'
                ? `${column.getAfter(isColumnPinned)}`
                : undefined,
            '--mrt-table-head-cell-padding': density === 'xl' ? '23' : density === 'md' ? '16' : '10',
        }, align: columnDefType === 'group'
            ? 'center'
            : direction.dir === 'rtl'
                ? 'right'
                : 'left', className: clsx(classes$l.root, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$l['root-grid'], enableMultiSort && column.getCanSort() && classes$l['root-no-select'], columnVirtualizer && classes$l['root-virtualized'], tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.className), onDragEnter: handleDragEnter, ref: (node) => {
            var _a;
            if (node) {
                tableHeadCellRefs.current[column.id] = node;
                if (columnDefType !== 'group') {
                    (_a = columnVirtualizer === null || columnVirtualizer === void 0 ? void 0 : columnVirtualizer.measureElement) === null || _a === void 0 ? void 0 : _a.call(columnVirtualizer, node);
                }
            }
        }, style: (theme) => (Object.assign(Object.assign({}, widthStyles), parseFromValuesOrFunc(tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.style, theme))), children: [header.isPlaceholder
                ? null
                : (_f = tableCellProps.children) !== null && _f !== void 0 ? _f : (jsxRuntime.jsxs(core.Flex, { className: clsx('mrt-table-head-cell-content', classes$l.content, (columnDefType === 'group' ||
                        (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'center') &&
                        classes$l['content-center'], (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'right' && classes$l['content-right'], column.getCanResize() && classes$l['content-spaced']), children: [jsxRuntime.jsxs(core.Flex, { __vars: {
                                '--mrt-table-head-cell-labels-padding-left': `${headerPL}`,
                            }, className: clsx('mrt-table-head-cell-labels', classes$l.labels, column.getCanSort() &&
                                columnDefType !== 'group' &&
                                classes$l['labels-sortable'], (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'right'
                                ? classes$l['labels-right']
                                : (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'center' &&
                                    classes$l['labels-center'], columnDefType === 'data' && classes$l['labels-data']), onClick: column.getToggleSortingHandler(), children: [jsxRuntime.jsx(core.Flex, { className: clsx('mrt-table-head-cell-content-wrapper', classes$l['content-wrapper'], columnDefType === 'data' &&
                                        classes$l['content-wrapper-hidden-overflow'], ((_h = (_g = columnDef.header) === null || _g === void 0 ? void 0 : _g.length) !== null && _h !== void 0 ? _h : 0) < 20 &&
                                        classes$l['content-wrapper-nowrap']), children: headerElement }), column.getCanFilter() && (jsxRuntime.jsx(MRT_TableHeadCellFilterLabel, { header: header, table: table })), column.getCanSort() && (jsxRuntime.jsx(MRT_TableHeadCellSortLabel, { header: header, table: table }))] }), columnDefType !== 'group' && (jsxRuntime.jsxs(core.Flex, { className: clsx('mrt-table-head-cell-content-actions', classes$l['content-actions']), children: [showDragHandle && (jsxRuntime.jsx(MRT_TableHeadCellGrabHandle, { column: column, table: table, tableHeadCellRef: {
                                        current: tableHeadCellRefs.current[column.id],
                                    } })), showColumnActions && (jsxRuntime.jsx(MRT_ColumnActionMenu, { header: header, table: table }))] })), column.getCanResize() && (jsxRuntime.jsx(MRT_TableHeadCellResizeHandle, { header: header, table: table }))] })), columnFilterDisplayMode === 'subheader' && column.getCanFilter() && (jsxRuntime.jsx(MRT_TableHeadCellFilterContainer, { header: header, table: table }))] })));
};

const MRT_TableHeadRow = (_a) => {
    var { columnVirtualizer, headerGroup, table } = _a, rest = __rest(_a, ["columnVirtualizer", "headerGroup", "table"]);
    const { getState, options: { enableStickyHeader, layoutMode, mantineTableHeadRowProps }, } = table;
    const { isFullScreen } = getState();
    const { virtualColumns, virtualPaddingLeft, virtualPaddingRight } = columnVirtualizer !== null && columnVirtualizer !== void 0 ? columnVirtualizer : {};
    const tableRowProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineTableHeadRowProps, {
        headerGroup,
        table,
    })), rest);
    return (jsxRuntime.jsxs(core.TableTr, Object.assign({}, tableRowProps, { className: clsx(classes$m.root, (enableStickyHeader || isFullScreen) && classes$m.sticky, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$m['layout-mode-grid'], tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.className), children: [virtualPaddingLeft ? (jsxRuntime.jsx(core.Box, { component: "th", display: "flex", w: virtualPaddingLeft })) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : headerGroup.headers).map((headerOrVirtualHeader, renderedHeaderIndex) => {
                let header = headerOrVirtualHeader;
                if (columnVirtualizer) {
                    renderedHeaderIndex = headerOrVirtualHeader
                        .index;
                    header = headerGroup.headers[renderedHeaderIndex];
                }
                return (jsxRuntime.jsx(MRT_TableHeadCell, { columnVirtualizer: columnVirtualizer, header: header, renderedHeaderIndex: renderedHeaderIndex, table: table }, header.id));
            }), virtualPaddingRight ? (jsxRuntime.jsx(core.Box, { component: "th", display: "flex", w: virtualPaddingRight })) : null] })));
};

var classes$a = {"alert":"MRT_ToolbarAlertBanner-module_alert__PAhUK","alert-stacked":"MRT_ToolbarAlertBanner-module_alert-stacked__HR7Nq","alert-bottom":"MRT_ToolbarAlertBanner-module_alert-bottom__u9L-S","alert-badge":"MRT_ToolbarAlertBanner-module_alert-badge__GwDmX","toolbar-alert":"MRT_ToolbarAlertBanner-module_toolbar-alert__3sJGU","head-overlay":"MRT_ToolbarAlertBanner-module_head-overlay__Hw7jK"};

const MRT_ToolbarAlertBanner = (_a) => {
    var _b, _c, _d;
    var { stackAlertBanner, table } = _a, rest = __rest(_a, ["stackAlertBanner", "table"]);
    const { getFilteredSelectedRowModel, getPrePaginationRowModel, getState, options: { enableRowSelection, enableSelectAll, icons: { IconX }, localization, mantineToolbarAlertBannerBadgeProps, mantineToolbarAlertBannerProps, manualPagination, positionToolbarAlertBanner, renderToolbarAlertBannerContent, rowCount, }, } = table;
    const { density, grouping, rowSelection, showAlertBanner } = getState();
    const alertProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineToolbarAlertBannerProps, {
        table,
    })), rest);
    const badgeProps = parseFromValuesOrFunc(mantineToolbarAlertBannerBadgeProps, { table });
    const totalRowCount = rowCount !== null && rowCount !== void 0 ? rowCount : getPrePaginationRowModel().flatRows.length;
    const selectedRowCount = react.useMemo(() => manualPagination
        ? Object.values(rowSelection).filter(Boolean).length
        : getFilteredSelectedRowModel().rows.length, [rowSelection, totalRowCount, manualPagination]);
    const selectedAlert = selectedRowCount ? (jsxRuntime.jsxs(core.Flex, { align: "center", gap: "sm", children: [(_c = (_b = localization.selectedCountOfRowCountRowsSelected) === null || _b === void 0 ? void 0 : _b.replace('{selectedCount}', selectedRowCount.toString())) === null || _c === void 0 ? void 0 : _c.replace('{rowCount}', totalRowCount.toString()), jsxRuntime.jsx(core.Button, { onClick: (event) => getMRT_SelectAllHandler({ table })(event, false, true), size: "compact-xs", variant: "subtle", children: localization.clearSelection })] })) : null;
    const groupedAlert = grouping.length > 0 ? (jsxRuntime.jsxs(core.Flex, { children: [localization.groupedBy, ' ', grouping.map((columnId, index) => (jsxRuntime.jsxs(react.Fragment, { children: [index > 0 ? localization.thenBy : '', jsxRuntime.jsxs(core.Badge, Object.assign({ className: classes$a['alert-badge'], rightSection: jsxRuntime.jsx(core.ActionIcon, { color: "white", onClick: () => table.getColumn(columnId).toggleGrouping(), size: "xs", variant: "subtle", children: jsxRuntime.jsx(IconX, { style: { transform: 'scale(0.8)' } }) }), variant: "filled" }, badgeProps, { children: [table.getColumn(columnId).columnDef.header, ' '] }))] }, `${index}-${columnId}`)))] })) : null;
    return (jsxRuntime.jsx(core.Collapse, { in: showAlertBanner || !!selectedAlert || !!groupedAlert, transitionDuration: stackAlertBanner ? 200 : 0, children: jsxRuntime.jsx(core.Alert, Object.assign({ color: "blue", icon: false }, alertProps, { className: clsx(classes$a.alert, stackAlertBanner &&
                !positionToolbarAlertBanner &&
                classes$a['alert-stacked'], !stackAlertBanner &&
                positionToolbarAlertBanner === 'bottom' &&
                classes$a['alert-bottom'], alertProps === null || alertProps === void 0 ? void 0 : alertProps.className), children: (_d = renderToolbarAlertBannerContent === null || renderToolbarAlertBannerContent === void 0 ? void 0 : renderToolbarAlertBannerContent({
                groupedAlert,
                selectedAlert,
                table,
            })) !== null && _d !== void 0 ? _d : (jsxRuntime.jsxs(core.Flex, { className: clsx(classes$a['toolbar-alert'], positionToolbarAlertBanner === 'head-overlay' &&
                    classes$a['head-overlay'], density), children: [enableRowSelection &&
                        enableSelectAll &&
                        positionToolbarAlertBanner === 'head-overlay' && (jsxRuntime.jsx(MRT_SelectCheckbox, { table: table })), jsxRuntime.jsxs(core.Stack, { children: [alertProps === null || alertProps === void 0 ? void 0 : alertProps.children, selectedAlert, groupedAlert] })] })) })) }));
};

const MRT_TableHead = (_a) => {
    var { columnVirtualizer, table } = _a, rest = __rest(_a, ["columnVirtualizer", "table"]);
    const { getHeaderGroups, getSelectedRowModel, getState, options: { enableStickyHeader, layoutMode, mantineTableHeadProps, positionToolbarAlertBanner, }, refs: { tableHeadRef }, } = table;
    const { isFullScreen, showAlertBanner } = getState();
    const tableHeadProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineTableHeadProps, {
        table,
    })), rest);
    const stickyHeader = enableStickyHeader || isFullScreen;
    return (jsxRuntime.jsx(core.TableThead, Object.assign({}, tableHeadProps, { className: clsx(classes$n.root, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid'))
            ? classes$n['root-grid']
            : classes$n['root-table-row-group'], stickyHeader && classes$n['root-sticky'], tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.className), pos: stickyHeader && (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) ? 'sticky' : 'relative', ref: (ref) => {
            tableHeadRef.current = ref;
            if (tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.ref) {
                // @ts-ignore
                tableHeadProps.ref.current = ref;
            }
        }, children: positionToolbarAlertBanner === 'head-overlay' &&
            (showAlertBanner || getSelectedRowModel().rows.length > 0) ? (jsxRuntime.jsx(core.TableTr, { className: clsx(classes$n['banner-tr'], (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$n.grid), children: jsxRuntime.jsx(core.TableTh, { className: clsx(classes$n['banner-th'], (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$n.grid), colSpan: table.getVisibleLeafColumns().length, children: jsxRuntime.jsx(MRT_ToolbarAlertBanner, { table: table }) }) })) : (getHeaderGroups().map((headerGroup) => (jsxRuntime.jsx(MRT_TableHeadRow, { columnVirtualizer: columnVirtualizer, headerGroup: headerGroup, table: table }, headerGroup.id)))) })));
};

const MRT_Table = (_a) => {
    var { table } = _a, rest = __rest(_a, ["table"]);
    const { getFlatHeaders, getState, options: { columns, enableTableFooter, enableTableHead, layoutMode, mantineTableProps, memoMode, }, } = table;
    const { columnSizing, columnSizingInfo, columnVisibility, density } = getState();
    const tableProps = Object.assign(Object.assign({ highlightOnHover: true, horizontalSpacing: density, verticalSpacing: density }, parseFromValuesOrFunc(mantineTableProps, { table })), rest);
    const columnSizeVars = react.useMemo(() => {
        const headers = getFlatHeaders();
        const colSizes = {};
        for (let i = 0; i < headers.length; i++) {
            const header = headers[i];
            const colSize = header.getSize();
            colSizes[`--header-${parseCSSVarId(header.id)}-size`] = colSize;
            colSizes[`--col-${parseCSSVarId(header.column.id)}-size`] = colSize;
        }
        return colSizes;
    }, [columns, columnSizing, columnSizingInfo, columnVisibility]);
    const columnVirtualizer = useMRT_ColumnVirtualizer(table);
    const commonTableGroupProps = {
        columnVirtualizer,
        table,
    };
    const { colorScheme } = core.useMantineColorScheme();
    const { stripedColor } = tableProps;
    return (jsxRuntime.jsxs(core.Table, Object.assign({ className: clsx('mrt-table', classes$w.root, (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith('grid')) && classes$w['root-grid'], tableProps.className) }, tableProps, { __vars: Object.assign(Object.assign(Object.assign({}, columnSizeVars), { '--mrt-striped-row-background-color': stripedColor, '--mrt-striped-row-hover-background-color': stripedColor
                ? colorScheme === 'dark'
                    ? core.lighten(stripedColor, 0.08)
                    : core.darken(stripedColor, 0.12)
                : undefined }), tableProps.__vars), children: [enableTableHead && jsxRuntime.jsx(MRT_TableHead, Object.assign({}, commonTableGroupProps)), memoMode === 'table-body' || columnSizingInfo.isResizingColumn ? (jsxRuntime.jsx(Memo_MRT_TableBody, Object.assign({}, commonTableGroupProps, { tableProps: tableProps }))) : (jsxRuntime.jsx(MRT_TableBody, Object.assign({}, commonTableGroupProps, { tableProps: tableProps }))), enableTableFooter && jsxRuntime.jsx(MRT_TableFooter, Object.assign({}, commonTableGroupProps))] })));
};

const MRT_EditRowModal = (_a) => {
    var _b;
    var { open, table } = _a, rest = __rest(_a, ["open", "table"]);
    const { getState, options: { mantineCreateRowModalProps, mantineEditRowModalProps, onCreatingRowCancel, onEditingRowCancel, renderCreateRowModalContent, renderEditRowModalContent, }, setCreatingRow, setEditingRow, } = table;
    const { creatingRow, editingRow } = getState();
    const row = (creatingRow !== null && creatingRow !== void 0 ? creatingRow : editingRow);
    const arg = { row, table };
    const modalProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineEditRowModalProps, arg)), (creatingRow && parseFromValuesOrFunc(mantineCreateRowModalProps, arg))), rest);
    const internalEditComponents = row
        .getAllCells()
        .filter((cell) => cell.column.columnDef.columnDefType === 'data')
        .map((cell) => (jsxRuntime.jsx(MRT_EditCellTextInput, { cell: cell, table: table }, cell.id)));
    const handleCancel = () => {
        var _a;
        if (creatingRow) {
            onCreatingRowCancel === null || onCreatingRowCancel === void 0 ? void 0 : onCreatingRowCancel({ row, table });
            setCreatingRow(null);
        }
        else {
            onEditingRowCancel === null || onEditingRowCancel === void 0 ? void 0 : onEditingRowCancel({ row, table });
            setEditingRow(null);
        }
        row._valuesCache = {}; //reset values cache
        (_a = modalProps.onClose) === null || _a === void 0 ? void 0 : _a.call(modalProps);
    };
    return (react.createElement(core.Modal, Object.assign({ opened: open, withCloseButton: false }, modalProps, { key: row.id, onClose: handleCancel }), (_b = ((creatingRow &&
        (renderCreateRowModalContent === null || renderCreateRowModalContent === void 0 ? void 0 : renderCreateRowModalContent({
            internalEditComponents,
            row,
            table,
        }))) ||
        (renderEditRowModalContent === null || renderEditRowModalContent === void 0 ? void 0 : renderEditRowModalContent({
            internalEditComponents,
            row,
            table,
        })))) !== null && _b !== void 0 ? _b : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("form", { onSubmit: (e) => e.preventDefault(), children: jsxRuntime.jsx(core.Stack, { gap: "lg", pb: 24, pt: 16, children: internalEditComponents }) }), jsxRuntime.jsx(core.Flex, { justify: "flex-end", children: jsxRuntime.jsx(MRT_EditActionButtons, { row: row, table: table, variant: "text" }) })] }))));
};

const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? react.useLayoutEffect : react.useEffect;
const MRT_TableContainer = (_a) => {
    var { table } = _a, rest = __rest(_a, ["table"]);
    const { getState, options: { createDisplayMode, editDisplayMode, enableStickyHeader, mantineLoadingOverlayProps, mantineTableContainerProps, }, refs: { bottomToolbarRef, tableContainerRef, topToolbarRef }, } = table;
    const { creatingRow, editingRow, isFullScreen, isLoading, showLoadingOverlay, } = getState();
    const [totalToolbarHeight, setTotalToolbarHeight] = react.useState(0);
    const tableContainerProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineTableContainerProps, { table })), rest);
    const loadingOverlayProps = parseFromValuesOrFunc(mantineLoadingOverlayProps, { table });
    useIsomorphicLayoutEffect(() => {
        var _a, _b, _c, _d;
        const topToolbarHeight = typeof document !== 'undefined'
            ? (_b = (_a = topToolbarRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) !== null && _b !== void 0 ? _b : 0
            : 0;
        const bottomToolbarHeight = typeof document !== 'undefined'
            ? (_d = (_c = bottomToolbarRef === null || bottomToolbarRef === void 0 ? void 0 : bottomToolbarRef.current) === null || _c === void 0 ? void 0 : _c.offsetHeight) !== null && _d !== void 0 ? _d : 0
            : 0;
        setTotalToolbarHeight(topToolbarHeight + bottomToolbarHeight);
    });
    const createModalOpen = createDisplayMode === 'modal' && creatingRow;
    const editModalOpen = editDisplayMode === 'modal' && editingRow;
    return (jsxRuntime.jsxs(core.Box, Object.assign({}, tableContainerProps, { __vars: Object.assign({ '--mrt-top-toolbar-height': `${totalToolbarHeight}` }, tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.__vars), className: clsx('mrt-table-container', classes$x.root, enableStickyHeader && classes$x['root-sticky'], isFullScreen && classes$x['root-fullscreen'], tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.className), ref: (node) => {
            if (node) {
                tableContainerRef.current = node;
                if (tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.ref) {
                    //@ts-ignore
                    tableContainerProps.ref.current = node;
                }
            }
        }, children: [jsxRuntime.jsx(core.LoadingOverlay, Object.assign({ visible: isLoading || showLoadingOverlay, zIndex: 2 }, loadingOverlayProps)), jsxRuntime.jsx(MRT_Table, { table: table }), (createModalOpen || editModalOpen) && (jsxRuntime.jsx(MRT_EditRowModal, { open: true, table: table }))] })));
};

var classes$9 = {"root":"MRT_BottomToolbar-module_root__VDeWo","root-fullscreen":"MRT_BottomToolbar-module_root-fullscreen__esE15","custom-toolbar-container":"MRT_BottomToolbar-module_custom-toolbar-container__XcDRF","paginator-container":"MRT_BottomToolbar-module_paginator-container__A3eWY","paginator-container-alert-banner":"MRT_BottomToolbar-module_paginator-container-alert-banner__gyqtO"};

var commonClasses = {"common-toolbar-styles":"common-styles-module_common-toolbar-styles__DnjR8"};

var classes$8 = {"collapse":"MRT_ProgressBar-module_collapse__rOLJH","collapse-top":"MRT_ProgressBar-module_collapse-top__oCi0h"};

const MRT_ProgressBar = (_a) => {
    var { isTopToolbar, table } = _a, rest = __rest(_a, ["isTopToolbar", "table"]);
    const { getState, options: { mantineProgressProps }, } = table;
    const { isSaving, showProgressBars } = getState();
    const linearProgressProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineProgressProps, {
        isTopToolbar,
        table,
    })), rest);
    return (jsxRuntime.jsx(core.Collapse, { className: clsx(classes$8.collapse, isTopToolbar && classes$8['collapse-top']), in: isSaving || showProgressBars, children: jsxRuntime.jsx(core.Progress, Object.assign({ animated: true, "aria-busy": "true", "aria-label": "Loading", radius: 0, value: 100 }, linearProgressProps)) }));
};

var classes$7 = {"root":"MRT_TablePagination-module_root__yZ8pm","pagesize":"MRT_TablePagination-module_pagesize__-vmTn","with-top-margin":"MRT_TablePagination-module_with-top-margin__aM5-m"};

const defaultRowsPerPage = [5, 10, 15, 20, 25, 30, 50, 100].map((x) => x.toString());
const MRT_TablePagination = (_a) => {
    var _b;
    var { position = 'bottom', table } = _a, props = __rest(_a, ["position", "table"]);
    const { getPrePaginationRowModel, getState, options: { enableToolbarInternalActions, icons: { IconChevronLeft, IconChevronLeftPipe, IconChevronRight, IconChevronRightPipe, }, localization, mantinePaginationProps, paginationDisplayMode, rowCount, }, setPageIndex, setPageSize, } = table;
    const { pagination: { pageIndex = 0, pageSize = 10 }, showGlobalFilter, } = getState();
    const paginationProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantinePaginationProps, {
        table,
    })), props);
    const totalRowCount = rowCount !== null && rowCount !== void 0 ? rowCount : getPrePaginationRowModel().rows.length;
    const numberOfPages = Math.ceil(totalRowCount / pageSize);
    const showFirstLastPageButtons = numberOfPages > 2;
    const firstRowIndex = pageIndex * pageSize;
    const lastRowIndex = Math.min(pageIndex * pageSize + pageSize, totalRowCount);
    const _c = paginationProps !== null && paginationProps !== void 0 ? paginationProps : {}, { rowsPerPageOptions = defaultRowsPerPage, showRowsPerPage = true, withEdges = showFirstLastPageButtons } = _c, rest = __rest(_c, ["rowsPerPageOptions", "showRowsPerPage", "withEdges"]);
    const needsTopMargin = position === 'top' && enableToolbarInternalActions && !showGlobalFilter;
    return (jsxRuntime.jsxs(core.Box, { className: clsx('mrt-table-pagination', classes$7.root, needsTopMargin && classes$7['with-top-margin']), children: [(paginationProps === null || paginationProps === void 0 ? void 0 : paginationProps.showRowsPerPage) !== false && (jsxRuntime.jsxs(core.Group, { gap: "xs", children: [jsxRuntime.jsx(core.Text, { id: "rpp-label", children: localization.rowsPerPage }), jsxRuntime.jsx(core.Select, { allowDeselect: false, "aria-labelledby": "rpp-label", className: classes$7.pagesize, data: (_b = paginationProps === null || paginationProps === void 0 ? void 0 : paginationProps.rowsPerPageOptions) !== null && _b !== void 0 ? _b : defaultRowsPerPage, onChange: (value) => setPageSize(+value), value: pageSize.toString() })] })), paginationDisplayMode === 'pages' ? (jsxRuntime.jsx(core.Pagination, Object.assign({ firstIcon: IconChevronLeftPipe, lastIcon: IconChevronRightPipe, nextIcon: IconChevronRight, onChange: (newPageIndex) => setPageIndex(newPageIndex - 1), previousIcon: IconChevronLeft, total: numberOfPages, value: pageIndex + 1, withEdges: withEdges }, rest))) : paginationDisplayMode === 'default' ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Text, { children: `${lastRowIndex === 0 ? 0 : (firstRowIndex + 1).toLocaleString()}-${lastRowIndex.toLocaleString()} ${localization.of} ${totalRowCount.toLocaleString()}` }), jsxRuntime.jsxs(core.Group, { gap: 6, children: [withEdges && (jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.goToFirstPage, color: "gray", disabled: pageIndex <= 0, onClick: () => setPageIndex(0), variant: "subtle", children: jsxRuntime.jsx(IconChevronLeftPipe, {}) })), jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.goToPreviousPage, color: "gray", disabled: pageIndex <= 0, onClick: () => setPageIndex(pageIndex - 1), variant: "subtle", children: jsxRuntime.jsx(IconChevronLeft, {}) }), jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.goToNextPage, color: "gray", disabled: lastRowIndex >= totalRowCount, onClick: () => setPageIndex(pageIndex + 1), variant: "subtle", children: jsxRuntime.jsx(IconChevronRight, {}) }), withEdges && (jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.goToLastPage, color: "gray", disabled: lastRowIndex >= totalRowCount, onClick: () => setPageIndex(numberOfPages - 1), variant: "subtle", children: jsxRuntime.jsx(IconChevronRightPipe, {}) }))] })] })) : null] }));
};

var classes$6 = {"root":"MRT_ToolbarDropZone-module_root__eGTXb","hovered":"MRT_ToolbarDropZone-module_hovered__g7PeJ"};

const MRT_ToolbarDropZone = (_a) => {
    var { table } = _a, rest = __rest(_a, ["table"]);
    const { getState, options: { enableGrouping, localization }, setHoveredColumn, setShowToolbarDropZone, } = table;
    const { draggingColumn, grouping, hoveredColumn, showToolbarDropZone } = getState();
    const handleDragEnter = (_event) => {
        setHoveredColumn({ id: 'drop-zone' });
    };
    react.useEffect(() => {
        var _a;
        if (((_a = table.options.state) === null || _a === void 0 ? void 0 : _a.showToolbarDropZone) !== undefined) {
            setShowToolbarDropZone(!!enableGrouping &&
                !!draggingColumn &&
                draggingColumn.columnDef.enableGrouping !== false &&
                !grouping.includes(draggingColumn.id));
        }
    }, [enableGrouping, draggingColumn, grouping]);
    return (jsxRuntime.jsx(core.Transition, { mounted: showToolbarDropZone, transition: "fade", children: () => {
            var _a, _b;
            return (jsxRuntime.jsx(core.Flex, Object.assign({ className: clsx('mrt-toolbar-dropzone', classes$6.root, (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone' && classes$6.hovered), onDragEnter: handleDragEnter }, rest, { children: jsxRuntime.jsx(core.Text, { children: localization.dropToGroupBy.replace('{column}', (_b = (_a = draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.columnDef) === null || _a === void 0 ? void 0 : _a.header) !== null && _b !== void 0 ? _b : '') }) })));
        } }));
};

const MRT_BottomToolbar = (_a) => {
    var { table } = _a, rest = __rest(_a, ["table"]);
    const { getState, options: { enablePagination, mantineBottomToolbarProps, positionPagination, positionToolbarAlertBanner, positionToolbarDropZone, renderBottomToolbarCustomActions, }, refs: { bottomToolbarRef }, } = table;
    const { isFullScreen } = getState();
    const isMobile = hooks.useMediaQuery('(max-width: 720px)');
    const toolbarProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineBottomToolbarProps, {
        table,
    })), rest);
    const stackAlertBanner = isMobile || !!renderBottomToolbarCustomActions;
    return (jsxRuntime.jsxs(core.Box, Object.assign({}, toolbarProps, { className: clsx('mrt-bottom-toolbar', classes$9.root, commonClasses['common-toolbar-styles'], isFullScreen && classes$9['root-fullscreen'], toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.className), ref: (node) => {
            if (node) {
                bottomToolbarRef.current = node;
                if (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.ref) {
                    toolbarProps.ref.current = node;
                }
            }
        }, children: [jsxRuntime.jsx(MRT_ProgressBar, { isTopToolbar: false, table: table }), positionToolbarAlertBanner === 'bottom' && (jsxRuntime.jsx(MRT_ToolbarAlertBanner, { stackAlertBanner: stackAlertBanner, table: table })), ['both', 'bottom'].includes(positionToolbarDropZone !== null && positionToolbarDropZone !== void 0 ? positionToolbarDropZone : '') && (jsxRuntime.jsx(MRT_ToolbarDropZone, { table: table })), jsxRuntime.jsxs(core.Box, { className: classes$9['custom-toolbar-container'], children: [renderBottomToolbarCustomActions ? (renderBottomToolbarCustomActions({ table })) : (jsxRuntime.jsx("span", {})), jsxRuntime.jsx(core.Box, { className: clsx(classes$9['paginator-container'], stackAlertBanner && classes$9['paginator-container-alert-banner']), children: enablePagination &&
                            ['both', 'bottom'].includes(positionPagination !== null && positionPagination !== void 0 ? positionPagination : '') && (jsxRuntime.jsx(MRT_TablePagination, { position: "bottom", table: table })) })] })] })));
};

var classes$5 = {"root":"MRT_TopToolbar-module_root__r4-V9","root-fullscreen":"MRT_TopToolbar-module_root-fullscreen__3itT8","actions-container":"MRT_TopToolbar-module_actions-container__-uL0u","actions-container-stack-alert":"MRT_TopToolbar-module_actions-container-stack-alert__OYDL6"};

var classes$4 = {"root":"MRT_ToolbarInternalButtons-module_root__NKoUG"};

var classes$3 = {"root":"MRT_ShowHideColumnsMenu-module_root__2UWak","content":"MRT_ShowHideColumnsMenu-module_content__ehkWQ"};

var classes$2 = {"root":"MRT_ShowHideColumnsMenuItems-module_root__wYgv-","menu":"MRT_ShowHideColumnsMenuItems-module_menu__CeATR","grab":"MRT_ShowHideColumnsMenuItems-module_grab__a-d-y","pin":"MRT_ShowHideColumnsMenuItems-module_pin__P437b","switch":"MRT_ShowHideColumnsMenuItems-module_switch__tMsdt","header":"MRT_ShowHideColumnsMenuItems-module_header__xVkKb"};

var classes$1 = {"root":"MRT_ColumnPinningButtons-module_root__scTtW","left":"MRT_ColumnPinningButtons-module_left__W6Aog","right":"MRT_ColumnPinningButtons-module_right__7AJE3"};

const MRT_ColumnPinningButtons = ({ column, table, }) => {
    const { options: { icons: { IconPinned, IconPinnedOff }, localization, }, } = table;
    return (jsxRuntime.jsx(core.Flex, { className: clsx('mrt-column-pinning-buttons', classes$1.root), children: column.getIsPinned() ? (jsxRuntime.jsx(core.Tooltip, { label: localization.unpin, withinPortal: true, children: jsxRuntime.jsx(core.ActionIcon, { color: "gray", onClick: () => column.pin(false), size: "md", variant: "subtle", children: jsxRuntime.jsx(IconPinnedOff, {}) }) })) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Tooltip, { label: localization.pinToLeft, withinPortal: true, children: jsxRuntime.jsx(core.ActionIcon, { color: "gray", onClick: () => column.pin('left'), size: "md", variant: "subtle", children: jsxRuntime.jsx(IconPinned, { className: classes$1.left }) }) }), jsxRuntime.jsx(core.Tooltip, { label: localization.pinToRight, withinPortal: true, children: jsxRuntime.jsx(core.ActionIcon, { color: "gray", onClick: () => column.pin('right'), size: "md", variant: "subtle", children: jsxRuntime.jsx(IconPinned, { className: classes$1.right }) }) })] })) }));
};

const MRT_ShowHideColumnsMenuItems = ({ allColumns, column, hoveredColumn, setHoveredColumn, table, }) => {
    var _a;
    const theme = core.useMantineTheme();
    const { getState, options: { enableColumnOrdering, enableColumnPinning, enableHiding, localization, }, setColumnOrder, } = table;
    const { columnOrder } = getState();
    const { columnDef } = column;
    const { columnDefType } = columnDef;
    const switchChecked = (columnDefType !== 'group' && column.getIsVisible()) ||
        (columnDefType === 'group' &&
            column.getLeafColumns().some((col) => col.getIsVisible()));
    const handleToggleColumnHidden = (column) => {
        var _a, _b;
        if (columnDefType === 'group') {
            (_b = (_a = column === null || column === void 0 ? void 0 : column.columns) === null || _a === void 0 ? void 0 : _a.forEach) === null || _b === void 0 ? void 0 : _b.call(_a, (childColumn) => {
                childColumn.toggleVisibility(!switchChecked);
            });
        }
        else {
            column.toggleVisibility();
        }
    };
    const menuItemRef = react.useRef(null);
    const [isDragging, setIsDragging] = react.useState(false);
    const handleDragStart = (e) => {
        setIsDragging(true);
        e.dataTransfer.setDragImage(menuItemRef.current, 0, 0);
    };
    const handleDragEnd = (_e) => {
        setIsDragging(false);
        setHoveredColumn(null);
        if (hoveredColumn) {
            setColumnOrder(reorderColumn(column, hoveredColumn, columnOrder));
        }
    };
    const handleDragEnter = (_e) => {
        if (!isDragging && columnDef.enableColumnOrdering !== false) {
            setHoveredColumn(column);
        }
    };
    if (!columnDef.header || columnDef.visibleInShowHideMenu === false) {
        return null;
    }
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, Object.assign({ className: classes$2.root, component: "span", onDragEnter: handleDragEnter, ref: menuItemRef, style: {
                    '--_column-depth': `${(column.depth + 0.5) * 2}rem`,
                    '--_hover-color': getPrimaryColor(theme),
                } }, dataVariable('dragging', isDragging), dataVariable('order-hovered', (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id), { children: jsxRuntime.jsxs(core.Box, { className: classes$2.menu, children: [columnDefType !== 'group' &&
                            enableColumnOrdering &&
                            !allColumns.some((col) => col.columnDef.columnDefType === 'group') &&
                            (columnDef.enableColumnOrdering !== false ? (jsxRuntime.jsx(MRT_GrabHandleButton, { onDragEnd: handleDragEnd, onDragStart: handleDragStart, table: table })) : (jsxRuntime.jsx(core.Box, { className: classes$2.grab }))), enableColumnPinning &&
                            (column.getCanPin() ? (jsxRuntime.jsx(MRT_ColumnPinningButtons, { column: column, table: table })) : (jsxRuntime.jsx(core.Box, { className: classes$2.pin }))), enableHiding ? (jsxRuntime.jsx(core.Tooltip, { label: localization.toggleVisibility, openDelay: 1000, withinPortal: true, children: jsxRuntime.jsx(core.Switch, { checked: switchChecked, className: classes$2.switch, disabled: !column.getCanHide(), label: columnDef.header, onChange: () => handleToggleColumnHidden(column) }) })) : (jsxRuntime.jsx(core.Text, { className: classes$2.header, children: columnDef.header }))] }) })), (_a = column.columns) === null || _a === void 0 ? void 0 : _a.map((c, i) => (jsxRuntime.jsx(MRT_ShowHideColumnsMenuItems, { allColumns: allColumns, column: c, hoveredColumn: hoveredColumn, setHoveredColumn: setHoveredColumn, table: table }, `${i}-${c.id}`)))] }));
};

const MRT_ShowHideColumnsMenu = ({ table, }) => {
    const { getAllColumns, getAllLeafColumns, getCenterLeafColumns, getIsAllColumnsVisible, getIsSomeColumnsPinned, getIsSomeColumnsVisible, getLeftLeafColumns, getRightLeafColumns, getState, options: { enableColumnOrdering, enableColumnPinning, enableHiding, localization, }, } = table;
    const { columnOrder, columnPinning } = getState();
    const handleToggleAllColumns = (value) => {
        getAllLeafColumns()
            .filter((col) => col.columnDef.enableHiding !== false)
            .forEach((col) => col.toggleVisibility(value));
    };
    const allColumns = react.useMemo(() => {
        const columns = getAllColumns();
        if (columnOrder.length > 0 &&
            !columns.some((col) => col.columnDef.columnDefType === 'group')) {
            return [
                ...getLeftLeafColumns(),
                ...Array.from(new Set(columnOrder)).map((colId) => getCenterLeafColumns().find((col) => (col === null || col === void 0 ? void 0 : col.id) === colId)),
                ...getRightLeafColumns(),
            ].filter(Boolean);
        }
        return columns;
    }, [
        columnOrder,
        columnPinning,
        getAllColumns(),
        getCenterLeafColumns(),
        getLeftLeafColumns(),
        getRightLeafColumns(),
    ]);
    const [hoveredColumn, setHoveredColumn] = react.useState(null);
    return (jsxRuntime.jsxs(core.Menu.Dropdown, { className: clsx('mrt-show-hide-columns-menu', classes$3.root), children: [jsxRuntime.jsxs(core.Flex, { className: classes$3.content, children: [enableHiding && (jsxRuntime.jsx(core.Button, { disabled: !getIsSomeColumnsVisible(), onClick: () => handleToggleAllColumns(false), variant: "subtle", children: localization.hideAll })), enableColumnOrdering && (jsxRuntime.jsx(core.Button, { onClick: () => table.setColumnOrder(getDefaultColumnOrderIds(table.options)), variant: "subtle", children: localization.resetOrder })), enableColumnPinning && (jsxRuntime.jsx(core.Button, { disabled: !getIsSomeColumnsPinned(), onClick: () => table.resetColumnPinning(true), variant: "subtle", children: localization.unpinAll })), enableHiding && (jsxRuntime.jsx(core.Button, { disabled: getIsAllColumnsVisible(), onClick: () => handleToggleAllColumns(true), variant: "subtle", children: localization.showAll }))] }), jsxRuntime.jsx(core.Divider, {}), allColumns.map((column, index) => (jsxRuntime.jsx(MRT_ShowHideColumnsMenuItems, { allColumns: allColumns, column: column, hoveredColumn: hoveredColumn, setHoveredColumn: setHoveredColumn, table: table }, `${index}-${column.id}`)))] }));
};

const MRT_ShowHideColumnsButton = (_a) => {
    var { table, title } = _a, rest = __rest(_a, ["table", "title"]);
    const { icons: { IconColumns }, localization: { showHideColumns }, } = table.options;
    return (jsxRuntime.jsxs(core.Menu, { closeOnItemClick: false, withinPortal: true, children: [jsxRuntime.jsx(core.Tooltip, { label: title !== null && title !== void 0 ? title : showHideColumns, withinPortal: true, children: jsxRuntime.jsx(core.Menu.Target, { children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": title !== null && title !== void 0 ? title : showHideColumns, color: "gray", size: "lg", variant: "subtle" }, rest, { children: jsxRuntime.jsx(IconColumns, {}) })) }) }), jsxRuntime.jsx(MRT_ShowHideColumnsMenu, { table: table })] }));
};

const next = {
    md: 'xs',
    xl: 'md',
    xs: 'xl',
};
const MRT_ToggleDensePaddingButton = (_a) => {
    var { table: { getState, options: { icons: { IconBaselineDensityLarge, IconBaselineDensityMedium, IconBaselineDensitySmall, }, localization: { toggleDensity }, }, setDensity, }, title } = _a, rest = __rest(_a, ["table", "title"]);
    const { density } = getState();
    return (jsxRuntime.jsx(core.Tooltip, { label: title !== null && title !== void 0 ? title : toggleDensity, withinPortal: true, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": title !== null && title !== void 0 ? title : toggleDensity, color: "gray", onClick: () => setDensity((current) => next[current]), size: "lg", variant: "subtle" }, rest, { children: density === 'xs' ? (jsxRuntime.jsx(IconBaselineDensitySmall, {})) : density === 'md' ? (jsxRuntime.jsx(IconBaselineDensityMedium, {})) : (jsxRuntime.jsx(IconBaselineDensityLarge, {})) })) }));
};

const MRT_ToggleFiltersButton = (_a) => {
    var { table: { getState, options: { icons: { IconFilter, IconFilterOff }, localization: { showHideFilters }, }, setShowColumnFilters, }, title } = _a, rest = __rest(_a, ["table", "title"]);
    const { showColumnFilters } = getState();
    return (jsxRuntime.jsx(core.Tooltip, { label: title !== null && title !== void 0 ? title : showHideFilters, withinPortal: true, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": title !== null && title !== void 0 ? title : showHideFilters, color: "gray", onClick: () => setShowColumnFilters((current) => !current), size: "lg", variant: "subtle" }, rest, { children: showColumnFilters ? jsxRuntime.jsx(IconFilterOff, {}) : jsxRuntime.jsx(IconFilter, {}) })) }));
};

const MRT_ToggleFullScreenButton = (_a) => {
    var { table: { getState, options: { icons: { IconMaximize, IconMinimize }, localization: { toggleFullScreen }, }, setIsFullScreen, }, title } = _a, rest = __rest(_a, ["table", "title"]);
    const { isFullScreen } = getState();
    const [tooltipOpened, setTooltipOpened] = react.useState(false);
    const handleToggleFullScreen = () => {
        setTooltipOpened(false);
        setIsFullScreen((current) => !current);
    };
    return (jsxRuntime.jsx(core.Tooltip, { label: title !== null && title !== void 0 ? title : toggleFullScreen, opened: tooltipOpened, withinPortal: true, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": title !== null && title !== void 0 ? title : toggleFullScreen, color: "gray", onClick: handleToggleFullScreen, onMouseEnter: () => setTooltipOpened(true), onMouseLeave: () => setTooltipOpened(false), size: "lg", variant: "subtle" }, rest, { children: isFullScreen ? jsxRuntime.jsx(IconMinimize, {}) : jsxRuntime.jsx(IconMaximize, {}) })) }));
};

const MRT_ToggleGlobalFilterButton = (_a) => {
    var { table: { getState, options: { icons: { IconSearch, IconSearchOff }, localization: { showHideSearch }, }, refs: { searchInputRef }, setShowGlobalFilter, }, title } = _a, rest = __rest(_a, ["table", "title"]);
    const { globalFilter, showGlobalFilter } = getState();
    const handleToggleSearch = () => {
        setShowGlobalFilter(!showGlobalFilter);
        setTimeout(() => { var _a; return (_a = searchInputRef.current) === null || _a === void 0 ? void 0 : _a.focus(); }, 100);
    };
    return (jsxRuntime.jsx(core.Tooltip, { label: title !== null && title !== void 0 ? title : showHideSearch, withinPortal: true, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": title !== null && title !== void 0 ? title : showHideSearch, color: "gray", disabled: !!globalFilter, onClick: handleToggleSearch, size: "lg", variant: "subtle" }, rest, { children: showGlobalFilter ? jsxRuntime.jsx(IconSearchOff, {}) : jsxRuntime.jsx(IconSearch, {}) })) }));
};

const MRT_ToolbarInternalButtons = (_a) => {
    var _b;
    var { table } = _a, rest = __rest(_a, ["table"]);
    const { options: { columnFilterDisplayMode, enableColumnFilters, enableColumnOrdering, enableColumnPinning, enableDensityToggle, enableFilters, enableFullScreenToggle, enableGlobalFilter, enableHiding, initialState, renderToolbarInternalActions, }, } = table;
    return (jsxRuntime.jsx(core.Flex, Object.assign({}, rest, { className: clsx('mrt-toolbar-internal-buttons', classes$4.root, rest === null || rest === void 0 ? void 0 : rest.className), children: (_b = renderToolbarInternalActions === null || renderToolbarInternalActions === void 0 ? void 0 : renderToolbarInternalActions({ table })) !== null && _b !== void 0 ? _b : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [enableFilters &&
                    enableGlobalFilter &&
                    !(initialState === null || initialState === void 0 ? void 0 : initialState.showGlobalFilter) && (jsxRuntime.jsx(MRT_ToggleGlobalFilterButton, { table: table })), enableFilters &&
                    enableColumnFilters &&
                    columnFilterDisplayMode !== 'popover' && (jsxRuntime.jsx(MRT_ToggleFiltersButton, { table: table })), (enableHiding || enableColumnOrdering || enableColumnPinning) && (jsxRuntime.jsx(MRT_ShowHideColumnsButton, { table: table })), enableDensityToggle && (jsxRuntime.jsx(MRT_ToggleDensePaddingButton, { table: table })), enableFullScreenToggle && (jsxRuntime.jsx(MRT_ToggleFullScreenButton, { table: table }))] })) })));
};

var classes = {"root":"MRT_GlobalFilterTextInput-module_root__Xmcpv","collapse":"MRT_GlobalFilterTextInput-module_collapse__v311d"};

const MRT_GlobalFilterTextInput = (_a) => {
    var { table } = _a, rest = __rest(_a, ["table"]);
    const { getState, options: { enableGlobalFilterModes, icons: { IconSearch, IconX }, localization, mantineSearchTextInputProps, manualFiltering, }, refs: { searchInputRef }, setGlobalFilter, } = table;
    const { globalFilter, showGlobalFilter } = getState();
    const textFieldProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineSearchTextInputProps, {
        table,
    })), rest);
    const isMounted = react.useRef(false);
    const [searchValue, setSearchValue] = react.useState(globalFilter !== null && globalFilter !== void 0 ? globalFilter : '');
    const [debouncedSearchValue] = hooks.useDebouncedValue(searchValue, manualFiltering ? 500 : 250);
    react.useEffect(() => {
        setGlobalFilter(debouncedSearchValue || undefined);
    }, [debouncedSearchValue]);
    const handleClear = () => {
        setSearchValue('');
        setGlobalFilter(undefined);
    };
    react.useEffect(() => {
        if (isMounted.current) {
            if (globalFilter === undefined) {
                handleClear();
            }
            else {
                setSearchValue(globalFilter);
            }
        }
        isMounted.current = true;
    }, [globalFilter]);
    return (jsxRuntime.jsxs(core.Collapse, { className: classes.collapse, in: showGlobalFilter, children: [enableGlobalFilterModes && (jsxRuntime.jsxs(core.Menu, { withinPortal: true, children: [jsxRuntime.jsx(core.Menu.Target, { children: jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.changeSearchMode, color: "gray", size: "sm", variant: "transparent", children: jsxRuntime.jsx(IconSearch, {}) }) }), jsxRuntime.jsx(MRT_FilterOptionMenu, { onSelect: handleClear, table: table })] })), jsxRuntime.jsx(core.TextInput, Object.assign({ leftSection: !enableGlobalFilterModes && jsxRuntime.jsx(IconSearch, {}), mt: 0, mx: "sm", onChange: (event) => setSearchValue(event.target.value), placeholder: localization.search, rightSection: searchValue ? (jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.clearSearch, color: "gray", disabled: !(searchValue === null || searchValue === void 0 ? void 0 : searchValue.length), onClick: handleClear, size: "sm", variant: "transparent", children: jsxRuntime.jsx(core.Tooltip, { label: localization.clearSearch, withinPortal: true, children: jsxRuntime.jsx(IconX, {}) }) })) : null, value: searchValue !== null && searchValue !== void 0 ? searchValue : '', variant: "filled" }, textFieldProps, { className: clsx('mrt-global-filter-text-input', classes.root, textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.className), ref: (node) => {
                    if (node) {
                        searchInputRef.current = node;
                        if (textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.ref) {
                            // @ts-ignore
                            textFieldProps.ref = node;
                        }
                    }
                } }))] }));
};

const MRT_TopToolbar = (_a) => {
    var _b;
    var { table } = _a, rest = __rest(_a, ["table"]);
    const { getState, options: { enableGlobalFilter, enablePagination, enableToolbarInternalActions, mantineTopToolbarProps, positionGlobalFilter, positionPagination, positionToolbarAlertBanner, positionToolbarDropZone, renderTopToolbarCustomActions, }, refs: { topToolbarRef }, } = table;
    const { isFullScreen, showGlobalFilter } = getState();
    const isMobile = hooks.useMediaQuery('(max-width:720px)');
    const isTablet = hooks.useMediaQuery('(max-width:1024px)');
    const toolbarProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantineTopToolbarProps, { table })), rest);
    const stackAlertBanner = isMobile ||
        !!renderTopToolbarCustomActions ||
        (showGlobalFilter && isTablet);
    const globalFilterProps = {
        style: !isTablet
            ? {
                zIndex: 3,
            }
            : undefined,
        table,
    };
    return (jsxRuntime.jsxs(core.Box, Object.assign({}, toolbarProps, { className: clsx(commonClasses['common-toolbar-styles'], classes$5['root'], isFullScreen && classes$5['root-fullscreen'], toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.className), ref: (node) => {
            if (node) {
                topToolbarRef.current = node;
                if (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.ref) {
                    toolbarProps.ref.current = node;
                }
            }
        }, children: [positionToolbarAlertBanner === 'top' && (jsxRuntime.jsx(MRT_ToolbarAlertBanner, { stackAlertBanner: stackAlertBanner, table: table })), ['both', 'top'].includes(positionToolbarDropZone !== null && positionToolbarDropZone !== void 0 ? positionToolbarDropZone : '') && (jsxRuntime.jsx(MRT_ToolbarDropZone, { table: table })), jsxRuntime.jsxs(core.Flex, { className: clsx(classes$5['actions-container'], stackAlertBanner && classes$5['actions-container-stack-alert']), children: [enableGlobalFilter && positionGlobalFilter === 'left' && (jsxRuntime.jsx(MRT_GlobalFilterTextInput, Object.assign({}, globalFilterProps))), (_b = renderTopToolbarCustomActions === null || renderTopToolbarCustomActions === void 0 ? void 0 : renderTopToolbarCustomActions({ table })) !== null && _b !== void 0 ? _b : jsxRuntime.jsx("span", {}), enableToolbarInternalActions ? (jsxRuntime.jsxs(core.Flex, { justify: 'end', wrap: 'wrap-reverse', children: [enableGlobalFilter && positionGlobalFilter === 'right' && (jsxRuntime.jsx(MRT_GlobalFilterTextInput, Object.assign({}, globalFilterProps))), jsxRuntime.jsx(MRT_ToolbarInternalButtons, { table: table })] })) : (enableGlobalFilter &&
                        positionGlobalFilter === 'right' && (jsxRuntime.jsx(MRT_GlobalFilterTextInput, Object.assign({}, globalFilterProps))))] }), enablePagination &&
                ['both', 'top'].includes(positionPagination !== null && positionPagination !== void 0 ? positionPagination : '') && (jsxRuntime.jsx(core.Flex, { justify: "end", children: jsxRuntime.jsx(MRT_TablePagination, { position: "top", table: table }) })), jsxRuntime.jsx(MRT_ProgressBar, { isTopToolbar: true, table: table })] })));
};

const MRT_TablePaper = (_a) => {
    var _b, _c;
    var { table } = _a, rest = __rest(_a, ["table"]);
    const { getState, options: { enableBottomToolbar, enableTopToolbar, mantinePaperProps, renderBottomToolbar, renderTopToolbar, }, refs: { tablePaperRef }, } = table;
    const { isFullScreen } = getState();
    const tablePaperProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(mantinePaperProps, { table })), rest);
    return (jsxRuntime.jsxs(core.Paper, Object.assign({ shadow: "xs", withBorder: true }, tablePaperProps, { className: clsx('mrt-table-paper', classes$y.root, isFullScreen && 'mrt-table-paper-fullscreen', tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.className), ref: (ref) => {
            tablePaperRef.current = ref;
            if (tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.ref) {
                tablePaperProps.ref.current = ref;
            }
        }, 
        // rare case where we should use inline styles to guarantee highest specificity
        style: (theme) => (Object.assign(Object.assign({ zIndex: isFullScreen ? 200 : undefined }, parseFromValuesOrFunc(tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.style, theme)), (isFullScreen
            ? {
                bottom: 0,
                height: '100vh',
                left: 0,
                margin: 0,
                maxHeight: '100vh',
                maxWidth: '100vw',
                padding: 0,
                position: 'fixed',
                right: 0,
                top: 0,
                width: '100vw',
            }
            : null))), children: [enableTopToolbar &&
                ((_b = parseFromValuesOrFunc(renderTopToolbar, { table })) !== null && _b !== void 0 ? _b : (jsxRuntime.jsx(MRT_TopToolbar, { table: table }))), jsxRuntime.jsx(MRT_TableContainer, { table: table }), enableBottomToolbar &&
                ((_c = parseFromValuesOrFunc(renderBottomToolbar, { table })) !== null && _c !== void 0 ? _c : (jsxRuntime.jsx(MRT_BottomToolbar, { table: table })))] })));
};

const isTableInstanceProp = (props) => props.table !== undefined;
const MantineReactTable = (props) => {
    let table;
    if (isTableInstanceProp(props)) {
        table = props.table;
    }
    else {
        table = useMantineReactTable(props);
    }
    return jsxRuntime.jsx(MRT_TablePaper, { table: table });
};

exports.MRT_AggregationFns = MRT_AggregationFns;
exports.MRT_BottomToolbar = MRT_BottomToolbar;
exports.MRT_ColumnActionMenu = MRT_ColumnActionMenu;
exports.MRT_ColumnPinningButtons = MRT_ColumnPinningButtons;
exports.MRT_CopyButton = MRT_CopyButton;
exports.MRT_DefaultColumn = MRT_DefaultColumn;
exports.MRT_DefaultDisplayColumn = MRT_DefaultDisplayColumn;
exports.MRT_EditActionButtons = MRT_EditActionButtons;
exports.MRT_EditCellTextInput = MRT_EditCellTextInput;
exports.MRT_EditRowModal = MRT_EditRowModal;
exports.MRT_ExpandAllButton = MRT_ExpandAllButton;
exports.MRT_ExpandButton = MRT_ExpandButton;
exports.MRT_FilterCheckbox = MRT_FilterCheckbox;
exports.MRT_FilterFns = MRT_FilterFns;
exports.MRT_FilterOptionMenu = MRT_FilterOptionMenu;
exports.MRT_FilterRangeFields = MRT_FilterRangeFields;
exports.MRT_FilterRangeSlider = MRT_FilterRangeSlider;
exports.MRT_FilterTextInput = MRT_FilterTextInput;
exports.MRT_GlobalFilterTextInput = MRT_GlobalFilterTextInput;
exports.MRT_GrabHandleButton = MRT_GrabHandleButton;
exports.MRT_ProgressBar = MRT_ProgressBar;
exports.MRT_RowActionMenu = MRT_RowActionMenu;
exports.MRT_RowPinButton = MRT_RowPinButton;
exports.MRT_SelectCheckbox = MRT_SelectCheckbox;
exports.MRT_ShowHideColumnsButton = MRT_ShowHideColumnsButton;
exports.MRT_ShowHideColumnsMenu = MRT_ShowHideColumnsMenu;
exports.MRT_ShowHideColumnsMenuItems = MRT_ShowHideColumnsMenuItems;
exports.MRT_SortingFns = MRT_SortingFns;
exports.MRT_Table = MRT_Table;
exports.MRT_TableBody = MRT_TableBody;
exports.MRT_TableBodyCell = MRT_TableBodyCell;
exports.MRT_TableBodyCellValue = MRT_TableBodyCellValue;
exports.MRT_TableBodyRow = MRT_TableBodyRow;
exports.MRT_TableBodyRowGrabHandle = MRT_TableBodyRowGrabHandle;
exports.MRT_TableBodyRowPinButton = MRT_TableBodyRowPinButton;
exports.MRT_TableContainer = MRT_TableContainer;
exports.MRT_TableDetailPanel = MRT_TableDetailPanel;
exports.MRT_TableFooter = MRT_TableFooter;
exports.MRT_TableFooterCell = MRT_TableFooterCell;
exports.MRT_TableFooterRow = MRT_TableFooterRow;
exports.MRT_TableHead = MRT_TableHead;
exports.MRT_TableHeadCell = MRT_TableHeadCell;
exports.MRT_TableHeadCellFilterContainer = MRT_TableHeadCellFilterContainer;
exports.MRT_TableHeadCellFilterLabel = MRT_TableHeadCellFilterLabel;
exports.MRT_TableHeadCellGrabHandle = MRT_TableHeadCellGrabHandle;
exports.MRT_TableHeadCellResizeHandle = MRT_TableHeadCellResizeHandle;
exports.MRT_TableHeadCellSortLabel = MRT_TableHeadCellSortLabel;
exports.MRT_TableHeadRow = MRT_TableHeadRow;
exports.MRT_TablePagination = MRT_TablePagination;
exports.MRT_TablePaper = MRT_TablePaper;
exports.MRT_ToggleDensePaddingButton = MRT_ToggleDensePaddingButton;
exports.MRT_ToggleFiltersButton = MRT_ToggleFiltersButton;
exports.MRT_ToggleFullScreenButton = MRT_ToggleFullScreenButton;
exports.MRT_ToggleGlobalFilterButton = MRT_ToggleGlobalFilterButton;
exports.MRT_ToggleRowActionMenuButton = MRT_ToggleRowActionMenuButton;
exports.MRT_ToolbarAlertBanner = MRT_ToolbarAlertBanner;
exports.MRT_ToolbarDropZone = MRT_ToolbarDropZone;
exports.MRT_ToolbarInternalButtons = MRT_ToolbarInternalButtons;
exports.MRT_TopToolbar = MRT_TopToolbar;
exports.MantineReactTable = MantineReactTable;
exports.Memo_MRT_TableBody = Memo_MRT_TableBody;
exports.Memo_MRT_TableBodyCell = Memo_MRT_TableBodyCell;
exports.Memo_MRT_TableBodyRow = Memo_MRT_TableBodyRow;
exports.createMRTColumnHelper = createMRTColumnHelper;
exports.createRow = createRow;
exports.dataVariable = dataVariable;
exports.defaultDisplayColumnProps = defaultDisplayColumnProps;
exports.flexRender = flexRender;
exports.getAllLeafColumnDefs = getAllLeafColumnDefs;
exports.getCanRankRows = getCanRankRows;
exports.getColumnId = getColumnId;
exports.getDefaultColumnFilterFn = getDefaultColumnFilterFn;
exports.getDefaultColumnOrderIds = getDefaultColumnOrderIds;
exports.getIsRankingRows = getIsRankingRows;
exports.getIsRowSelected = getIsRowSelected;
exports.getLeadingDisplayColumnIds = getLeadingDisplayColumnIds;
exports.getMRT_RowSelectionHandler = getMRT_RowSelectionHandler;
exports.getMRT_Rows = getMRT_Rows;
exports.getMRT_SelectAllHandler = getMRT_SelectAllHandler;
exports.getPrimaryColor = getPrimaryColor;
exports.getPrimaryShade = getPrimaryShade;
exports.getTrailingDisplayColumnIds = getTrailingDisplayColumnIds;
exports.localizedFilterOption = localizedFilterOption;
exports.mrtFilterOptions = mrtFilterOptions;
exports.parseCSSVarId = parseCSSVarId;
exports.prepareColumns = prepareColumns;
exports.rankGlobalFuzzy = rankGlobalFuzzy;
exports.reorderColumn = reorderColumn;
exports.showRowActionsColumn = showRowActionsColumn;
exports.showRowDragColumn = showRowDragColumn;
exports.showRowExpandColumn = showRowExpandColumn;
exports.showRowNumbersColumn = showRowNumbersColumn;
exports.showRowPinningColumn = showRowPinningColumn;
exports.showRowSelectionColumn = showRowSelectionColumn;
exports.showRowSpacerColumn = showRowSpacerColumn;
exports.useMRT_ColumnVirtualizer = useMRT_ColumnVirtualizer;
exports.useMRT_Effects = useMRT_Effects;
exports.useMRT_RowVirtualizer = useMRT_RowVirtualizer;
exports.useMRT_Rows = useMRT_Rows;
exports.useMRT_TableInstance = useMRT_TableInstance;
exports.useMRT_TableOptions = useMRT_TableOptions;
exports.useMantineReactTable = useMantineReactTable;
//# sourceMappingURL=index.cjs.map
