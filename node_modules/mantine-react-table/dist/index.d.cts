/// <reference types="react" />
import * as react from 'react';
import { HTMLProps, MutableRefObject, Dispatch, SetStateAction, ReactNode, RefObject, ChangeEvent, MouseEvent, DragEventHandler } from 'react';
import * as _tanstack_react_table from '@tanstack/react-table';
import { Row, ColumnFiltersState, ColumnOrderState, ColumnPinningState, ColumnSizingInfoState, ColumnSizingState, ExpandedState, GroupingState, PaginationState, RowSelectionState, SortingState, Updater, VisibilityState, AccessorFn, DeepKeys, DeepValue, Table, TableState, ColumnDef, Column, Header, HeaderGroup, Cell, AggregationFn, SortingFn, FilterFn, TableOptions, OnChangeFn, Renderable, RowPinningPosition } from '@tanstack/react-table';
import { VirtualItem, VirtualizerOptions, Virtualizer } from '@tanstack/react-virtual';
import { PaginationProps, ActionIconProps, UnstyledButtonProps, MultiSelectProps, TextInputProps, AutocompleteProps, RangeSliderProps, SelectProps, TableTdProps, TableThProps, BoxProps, ModalProps, CheckboxProps, HighlightProps, LoadingOverlayProps, PaperProps, ProgressProps, RadioProps, SwitchProps, SkeletonProps, TableTbodyProps, TableTrProps, TableTfootProps, TableTheadProps, TableProps, BadgeProps, AlertProps, MantineTheme, FlexProps, MenuProps } from '@mantine/core';
import { DateInputProps } from '@mantine/dates';
import { RankingInfo } from '@tanstack/match-sorter-utils';
import * as _tabler_icons_react from '@tabler/icons-react';
import * as react_jsx_runtime from 'react/jsx-runtime';

declare const MRT_AggregationFns: {
    sum: _tanstack_react_table.AggregationFn<any>;
    min: _tanstack_react_table.AggregationFn<any>;
    max: _tanstack_react_table.AggregationFn<any>;
    extent: _tanstack_react_table.AggregationFn<any>;
    mean: _tanstack_react_table.AggregationFn<any>;
    median: _tanstack_react_table.AggregationFn<any>;
    unique: _tanstack_react_table.AggregationFn<any>;
    uniqueCount: _tanstack_react_table.AggregationFn<any>;
    count: _tanstack_react_table.AggregationFn<any>;
};

declare const MRT_FilterFns: {
    between: {
        <TData extends MRT_RowData>(row: Row<TData>, id: string, filterValues: [number | string, number | string]): boolean;
        autoRemove(val: any): boolean;
    };
    betweenInclusive: {
        <TData_1 extends MRT_RowData>(row: Row<TData_1>, id: string, filterValues: [number | string, number | string]): boolean;
        autoRemove(val: any): boolean;
    };
    contains: {
        <TData_2 extends MRT_RowData>(row: Row<TData_2>, id: string, filterValue: number | string): boolean;
        autoRemove(val: any): boolean;
    };
    empty: {
        <TData_3 extends MRT_RowData>(row: Row<TData_3>, id: string, _filterValue: number | string): boolean;
        autoRemove(val: any): boolean;
    };
    endsWith: {
        <TData_4 extends MRT_RowData>(row: Row<TData_4>, id: string, filterValue: number | string): boolean;
        autoRemove(val: any): boolean;
    };
    equals: {
        <TData_5 extends MRT_RowData>(row: Row<TData_5>, id: string, filterValue: number | string): boolean;
        autoRemove(val: any): boolean;
    };
    fuzzy: {
        <TData_6 extends MRT_RowData>(row: Row<TData_6>, columnId: string, filterValue: number | string, addMeta: (item: RankingInfo) => void): boolean;
        autoRemove(val: any): boolean;
    };
    greaterThan: {
        <TData_7 extends MRT_RowData>(row: Row<TData_7>, id: string, filterValue: number | string): boolean;
        autoRemove(val: any): boolean;
    };
    greaterThanOrEqualTo: {
        <TData_8 extends MRT_RowData>(row: Row<TData_8>, id: string, filterValue: number | string): boolean;
        autoRemove(val: any): boolean;
    };
    lessThan: {
        <TData_9 extends MRT_RowData>(row: Row<TData_9>, id: string, filterValue: number | string): boolean;
        autoRemove(val: any): boolean;
    };
    lessThanOrEqualTo: {
        <TData_10 extends MRT_RowData>(row: Row<TData_10>, id: string, filterValue: number | string): boolean;
        autoRemove(val: any): boolean;
    };
    notEmpty: {
        <TData_11 extends MRT_RowData>(row: Row<TData_11>, id: string, _filterValue: number | string): boolean;
        autoRemove(val: any): boolean;
    };
    notEquals: {
        <TData_12 extends MRT_RowData>(row: Row<TData_12>, id: string, filterValue: number | string): boolean;
        autoRemove(val: any): boolean;
    };
    startsWith: {
        <TData_13 extends MRT_RowData>(row: Row<TData_13>, id: string, filterValue: number | string): boolean;
        autoRemove(val: any): boolean;
    };
    includesString: _tanstack_react_table.FilterFn<any>;
    includesStringSensitive: _tanstack_react_table.FilterFn<any>;
    equalsString: _tanstack_react_table.FilterFn<any>;
    arrIncludes: _tanstack_react_table.FilterFn<any>;
    arrIncludesAll: _tanstack_react_table.FilterFn<any>;
    arrIncludesSome: _tanstack_react_table.FilterFn<any>;
    weakEquals: _tanstack_react_table.FilterFn<any>;
    inNumberRange: _tanstack_react_table.FilterFn<any>;
};
declare function localizedFilterOption(localization: MRT_Localization, option: MRT_FilterOption): string;

declare const MRT_SortingFns: {
    fuzzy: <TData extends MRT_RowData>(rowA: Row<TData>, rowB: Row<TData>, columnId: string) => number;
    alphanumeric: _tanstack_react_table.SortingFn<any>;
    alphanumericCaseSensitive: _tanstack_react_table.SortingFn<any>;
    text: _tanstack_react_table.SortingFn<any>;
    textCaseSensitive: _tanstack_react_table.SortingFn<any>;
    datetime: _tanstack_react_table.SortingFn<any>;
    basic: _tanstack_react_table.SortingFn<any>;
};
declare const rankGlobalFuzzy: <TData extends MRT_RowData>(rowA: MRT_Row<TData>, rowB: MRT_Row<TData>) => number;

declare const MRT_Default_Icons: {
    readonly IconArrowAutofitContent: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconArrowsSort: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconBaselineDensityLarge: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconBaselineDensityMedium: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconBaselineDensitySmall: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconBoxMultiple: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconChevronDown: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconChevronLeft: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconChevronLeftPipe: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconChevronRight: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconChevronRightPipe: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconChevronsDown: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconCircleX: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconClearAll: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconColumns: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconDeviceFloppy: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconDots: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconDotsVertical: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconEdit: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconEyeOff: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconFilter: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconFilterCog: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconFilterOff: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconGripHorizontal: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconMaximize: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconMinimize: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconPinned: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconPinnedOff: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconSearch: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconSearchOff: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconSortAscending: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconSortDescending: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
    readonly IconX: react.ForwardRefExoticComponent<Omit<_tabler_icons_react.IconProps, "ref"> & react.RefAttributes<_tabler_icons_react.Icon>>;
};
type MRT_Icons = Record<keyof typeof MRT_Default_Icons, any>;

type LiteralUnion<T extends U, U = string> = T | (U & Record<never, never>);
type Prettify<T> = {
    [K in keyof T]: T[K];
} & unknown;
type Xor<A, B> = Prettify<A & {
    [k in keyof B]?: never;
}> | Prettify<B & {
    [k in keyof A]?: never;
}>;
type HTMLPropsRef<T extends HTMLElement> = Omit<HTMLProps<T>, 'color' | 'data' | 'label' | 'ref' | 'size' | 'style' | 'type'> & {
    ref?: MutableRefObject<T | null> | null;
};
type MantineShade = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
type MRT_PaginationProps = Partial<PaginationProps> & {
    rowsPerPageOptions?: string[];
    showRowsPerPage?: boolean;
};
type MRT_DensityState = 'md' | 'xl' | 'xs';
type MRT_ColumnFilterFnsState = Record<string, MRT_FilterOption>;
type MRT_RowData = Record<string, any>;
type MRT_CellValue = unknown;
type MRT_ColumnFiltersState = ColumnFiltersState;
type MRT_ColumnOrderState = ColumnOrderState;
type MRT_ColumnPinningState = ColumnPinningState;
type MRT_ColumnSizingInfoState = ColumnSizingInfoState;
type MRT_ColumnSizingState = ColumnSizingState;
type MRT_ExpandedState = ExpandedState;
type MRT_GroupingState = GroupingState;
type MRT_PaginationState = PaginationState;
type MRT_RowSelectionState = RowSelectionState;
type MRT_SortingState = SortingState;
type MRT_Updater<T> = Updater<T>;
type MRT_VirtualItem = VirtualItem;
type MRT_VisibilityState = VisibilityState;
type MRT_VirtualizerOptions<TScrollElement extends Element | Window = Element | Window, TItemElement extends Element = Element> = VirtualizerOptions<TScrollElement, TItemElement>;
type MRT_ColumnVirtualizer<TScrollElement extends Element | Window = HTMLDivElement, TItemElement extends Element = HTMLTableCellElement> = Virtualizer<TScrollElement, TItemElement> & {
    virtualColumns: MRT_VirtualItem[];
    virtualPaddingLeft?: number;
    virtualPaddingRight?: number;
};
type MRT_RowVirtualizer<TScrollElement extends Element | Window = HTMLDivElement, TItemElement extends Element = HTMLTableRowElement> = Virtualizer<TScrollElement, TItemElement> & {
    virtualRows: MRT_VirtualItem[];
};
type MRT_ColumnHelper<TData extends MRT_RowData> = {
    accessor: <TAccessor extends AccessorFn<TData> | DeepKeys<TData>, TValue extends TAccessor extends AccessorFn<TData, infer TReturn> ? TReturn : TAccessor extends DeepKeys<TData> ? DeepValue<TData, TAccessor> : never>(accessor: TAccessor, column: MRT_DisplayColumnDef<TData, TValue>) => MRT_ColumnDef<TData, TValue>;
    display: (column: MRT_DisplayColumnDef<TData>) => MRT_ColumnDef<TData>;
    group: (column: MRT_GroupColumnDef<TData>) => MRT_ColumnDef<TData>;
};
interface MRT_Localization {
    actions: string;
    and: string;
    cancel: string;
    changeFilterMode: string;
    changeSearchMode: string;
    clearFilter: string;
    clearSearch: string;
    clearSelection: string;
    clearSort: string;
    clickToCopy: string;
    collapse: string;
    collapseAll: string;
    columnActions: string;
    copiedToClipboard: string;
    dropToGroupBy: string;
    edit: string;
    expand: string;
    expandAll: string;
    filterArrIncludes: string;
    filterArrIncludesAll: string;
    filterArrIncludesSome: string;
    filterBetween: string;
    filterBetweenInclusive: string;
    filterByColumn: string;
    filterContains: string;
    filterEmpty: string;
    filterEndsWith: string;
    filterEquals: string;
    filterEqualsString: string;
    filterFuzzy: string;
    filterGreaterThan: string;
    filterGreaterThanOrEqualTo: string;
    filterInNumberRange: string;
    filterIncludesString: string;
    filterIncludesStringSensitive: string;
    filterLessThan: string;
    filterLessThanOrEqualTo: string;
    filterMode: string;
    filterNotEmpty: string;
    filterNotEquals: string;
    filterStartsWith: string;
    filterWeakEquals: string;
    filteringByColumn: string;
    goToFirstPage: string;
    goToLastPage: string;
    goToNextPage: string;
    goToPreviousPage: string;
    grab: string;
    groupByColumn: string;
    groupedBy: string;
    hideAll: string;
    hideColumn: string;
    max: string;
    min: string;
    move: string;
    noRecordsToDisplay: string;
    noResultsFound: string;
    of: string;
    or: string;
    pin: string;
    pinToLeft: string;
    pinToRight: string;
    resetColumnSize: string;
    resetOrder: string;
    rowActions: string;
    rowNumber: string;
    rowNumbers: string;
    rowsPerPage: string;
    save: string;
    search: string;
    select: string;
    selectedCountOfRowCountRowsSelected: string;
    showAll: string;
    showAllColumns: string;
    showHideColumns: string;
    showHideFilters: string;
    showHideSearch: string;
    sortByColumnAsc: string;
    sortByColumnDesc: string;
    sortedByColumnAsc: string;
    sortedByColumnDesc: string;
    thenBy: string;
    toggleDensity: string;
    toggleFullScreen: string;
    toggleSelectAll: string;
    toggleSelectRow: string;
    toggleVisibility: string;
    ungroupByColumn: string;
    unpin: string;
    unpinAll: string;
}
interface MRT_RowModel<TData extends MRT_RowData> {
    flatRows: MRT_Row<TData>[];
    rows: MRT_Row<TData>[];
    rowsById: {
        [key: string]: MRT_Row<TData>;
    };
}
type MRT_TableInstance<TData extends MRT_RowData> = Omit<Table<TData>, 'getAllColumns' | 'getAllFlatColumns' | 'getAllLeafColumns' | 'getBottomRows' | 'getCenterLeafColumns' | 'getCenterRows' | 'getColumn' | 'getExpandedRowModel' | 'getFlatHeaders' | 'getHeaderGroups' | 'getLeftLeafColumns' | 'getPaginationRowModel' | 'getPreFilteredRowModel' | 'getPrePaginationRowModel' | 'getRightLeafColumns' | 'getRowModel' | 'getSelectedRowModel' | 'getState' | 'getTopRows' | 'options'> & {
    getAllColumns: () => MRT_Column<TData>[];
    getAllFlatColumns: () => MRT_Column<TData>[];
    getAllLeafColumns: () => MRT_Column<TData>[];
    getBottomRows: () => MRT_Row<TData>[];
    getCenterLeafColumns: () => MRT_Column<TData>[];
    getCenterRows: () => MRT_Row<TData>[];
    getColumn: (columnId: string) => MRT_Column<TData>;
    getExpandedRowModel: () => MRT_RowModel<TData>;
    getFlatHeaders: () => MRT_Header<TData>[];
    getHeaderGroups: () => MRT_HeaderGroup<TData>[];
    getLeftLeafColumns: () => MRT_Column<TData>[];
    getPaginationRowModel: () => MRT_RowModel<TData>;
    getPreFilteredRowModel: () => MRT_RowModel<TData>;
    getPrePaginationRowModel: () => MRT_RowModel<TData>;
    getRightLeafColumns: () => MRT_Column<TData>[];
    getRowModel: () => MRT_RowModel<TData>;
    getSelectedRowModel: () => MRT_RowModel<TData>;
    getState: () => MRT_TableState<TData>;
    getTopRows: () => MRT_Row<TData>[];
    options: MRT_StatefulTableOptions<TData>;
    refs: {
        bottomToolbarRef: MutableRefObject<HTMLDivElement | null>;
        editInputRefs: MutableRefObject<Record<string, HTMLInputElement>>;
        filterInputRefs: MutableRefObject<Record<string, HTMLInputElement>>;
        lastSelectedRowId: MutableRefObject<null | string>;
        searchInputRef: MutableRefObject<HTMLInputElement | null>;
        tableContainerRef: MutableRefObject<HTMLDivElement | null>;
        tableFooterRef: MutableRefObject<HTMLTableSectionElement | null>;
        tableHeadCellRefs: MutableRefObject<Record<string, HTMLTableCellElement>>;
        tableHeadRef: MutableRefObject<HTMLTableSectionElement | null>;
        tablePaperRef: MutableRefObject<HTMLDivElement | null>;
        topToolbarRef: MutableRefObject<HTMLDivElement | null>;
    };
    setColumnFilterFns: Dispatch<SetStateAction<MRT_ColumnFilterFnsState>>;
    setCreatingRow: Dispatch<SetStateAction<MRT_Row<TData> | null | true>>;
    setDensity: Dispatch<SetStateAction<MRT_DensityState>>;
    setDraggingColumn: Dispatch<SetStateAction<MRT_Column<TData> | null>>;
    setDraggingRow: Dispatch<SetStateAction<MRT_Row<TData> | null>>;
    setEditingCell: Dispatch<SetStateAction<MRT_Cell<TData> | null>>;
    setEditingRow: Dispatch<SetStateAction<MRT_Row<TData> | null>>;
    setGlobalFilterFn: Dispatch<SetStateAction<MRT_FilterOption>>;
    setHoveredColumn: Dispatch<SetStateAction<Partial<MRT_Column<TData>> | null>>;
    setHoveredRow: Dispatch<SetStateAction<Partial<MRT_Row<TData>> | null>>;
    setIsFullScreen: Dispatch<SetStateAction<boolean>>;
    setShowAlertBanner: Dispatch<SetStateAction<boolean>>;
    setShowColumnFilters: Dispatch<SetStateAction<boolean>>;
    setShowGlobalFilter: Dispatch<SetStateAction<boolean>>;
    setShowToolbarDropZone: Dispatch<SetStateAction<boolean>>;
};
type MRT_DefinedTableOptions<TData extends MRT_RowData> = Omit<MRT_TableOptions<TData>, 'icons' | 'localization'> & {
    icons: MRT_Icons;
    localization: MRT_Localization;
};
type MRT_StatefulTableOptions<TData extends MRT_RowData> = MRT_DefinedTableOptions<TData> & {
    state: Pick<MRT_TableState<TData>, 'columnFilterFns' | 'columnOrder' | 'columnSizingInfo' | 'creatingRow' | 'density' | 'draggingColumn' | 'draggingRow' | 'editingCell' | 'editingRow' | 'globalFilterFn' | 'grouping' | 'hoveredColumn' | 'hoveredRow' | 'isFullScreen' | 'pagination' | 'showAlertBanner' | 'showColumnFilters' | 'showGlobalFilter' | 'showToolbarDropZone'>;
};
type MRT_TableState<TData extends MRT_RowData> = Prettify<TableState & {
    columnFilterFns: MRT_ColumnFilterFnsState;
    creatingRow: MRT_Row<TData> | null;
    density: MRT_DensityState;
    draggingColumn: MRT_Column<TData> | null;
    draggingRow: MRT_Row<TData> | null;
    editingCell: MRT_Cell<TData> | null;
    editingRow: MRT_Row<TData> | null;
    globalFilterFn: MRT_FilterOption;
    hoveredColumn: Partial<MRT_Column<TData>> | null;
    hoveredRow: Partial<MRT_Row<TData>> | null;
    isFullScreen: boolean;
    isLoading: boolean;
    isSaving: boolean;
    showAlertBanner: boolean;
    showColumnFilters: boolean;
    showGlobalFilter: boolean;
    showLoadingOverlay: boolean;
    showProgressBars: boolean;
    showSkeletons: boolean;
    showToolbarDropZone: boolean;
}>;
type MRT_ColumnDef<TData extends MRT_RowData, TValue = unknown> = Omit<ColumnDef<TData, TValue>, 'accessorKey' | 'aggregatedCell' | 'aggregationFn' | 'cell' | 'columns' | 'filterFn' | 'footer' | 'header' | 'id' | 'sortingFn'> & {
    AggregatedCell?: (props: {
        cell: MRT_Cell<TData, TValue>;
        column: MRT_Column<TData, TValue>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    Cell?: (props: {
        cell: MRT_Cell<TData, TValue>;
        column: MRT_Column<TData, TValue>;
        renderedCellValue: ReactNode | number | string;
        renderedColumnIndex?: number;
        renderedRowIndex?: number;
        row: MRT_Row<TData>;
        rowRef?: RefObject<HTMLTableRowElement>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    Edit?: (props: {
        cell: MRT_Cell<TData, TValue>;
        column: MRT_Column<TData, TValue>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    Filter?: (props: {
        column: MRT_Column<TData, TValue>;
        header: MRT_Header<TData>;
        rangeFilterIndex?: number;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    Footer?: ((props: {
        column: MRT_Column<TData, TValue>;
        footer: MRT_Header<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode) | ReactNode;
    GroupedCell?: (props: {
        cell: MRT_Cell<TData, TValue>;
        column: MRT_Column<TData, TValue>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    Header?: ((props: {
        column: MRT_Column<TData, TValue>;
        header: MRT_Header<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode) | ReactNode;
    PlaceholderCell?: (props: {
        cell: MRT_Cell<TData, TValue>;
        column: MRT_Column<TData, TValue>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    /**
     * Either an `accessorKey` or a combination of an `accessorFn` and `id` are required for a data column definition.
     * Specify a function here to point to the correct property in the data object.
     *
     * @example accessorFn: (row) => row.username
     */
    accessorFn?: (originalRow: TData) => any;
    /**
     * Either an `accessorKey` or a combination of an `accessorFn` and `id` are required for a data column definition.
     * Specify which key in the row this column should use to access the correct data.
     * Also supports Deep Key Dot Notation.
     *
     * @example accessorKey: 'username' //simple
     * @example accessorKey: 'name.firstName' //deep key dot notation
     */
    accessorKey?: DeepKeys<TData> | (string & {});
    aggregationFn?: Array<MRT_AggregationFn<TData>> | MRT_AggregationFn<TData>;
    /**
     * Specify what type of column this is. Either `data`, `display`, or `group`. Defaults to `data`.
     * Leave this blank if you are just creating a normal data column.
     *
     * @default 'data'
     *
     * @example columnDefType: 'display'
     */
    columnDefType?: 'data' | 'display' | 'group';
    columnFilterModeOptions?: Array<LiteralUnion<string & MRT_FilterOption>> | null;
    columns?: MRT_ColumnDef<TData>[];
    editVariant?: 'select' | 'text';
    enableClickToCopy?: ((cell: MRT_Cell<TData>) => boolean) | boolean;
    enableColumnActions?: boolean;
    enableColumnDragging?: boolean;
    enableColumnFilterModes?: boolean;
    enableColumnOrdering?: boolean;
    enableEditing?: ((row: MRT_Row<TData>) => boolean) | boolean;
    enableFilterMatchHighlighting?: boolean;
    filterFn?: MRT_FilterFn<TData>;
    filterVariant?: 'autocomplete' | 'checkbox' | 'date' | 'date-range' | 'multi-select' | 'range' | 'range-slider' | 'select' | 'text';
    /**
     * footer must be a string. If you want custom JSX to render the footer, you can also specify a `Footer` option. (Capital F)
     */
    footer?: string;
    /**
     * If `layoutMode` is `'grid'` or `'grid-no-grow'`, you can specify the flex grow value for individual columns to still grow and take up remaining space, or set to `false`/0 to not grow.
     */
    grow?: boolean | number;
    /**
     * header must be a string. If you want custom JSX to render the header, you can also specify a `Header` option. (Capital H)
     */
    header: string;
    /**
     * Either an `accessorKey` or a combination of an `accessorFn` and `id` are required for a data column definition.
     *
     * If you have also specified an `accessorFn`, MRT still needs to have a valid `id` to be able to identify the column uniquely.
     *
     * `id` defaults to the `accessorKey` or `header` if not specified.
     *
     * @default gets set to the same value as `accessorKey` by default
     */
    id?: LiteralUnion<string & keyof TData>;
    mantineColumnActionsButtonProps?: ((props: {
        column: MRT_Column<TData, TValue>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>) | (HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>);
    mantineColumnDragHandleProps?: ((props: {
        column: MRT_Column<TData, TValue>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>) | (HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>);
    mantineCopyButtonProps?: ((props: {
        cell: MRT_Cell<TData, TValue>;
        column: MRT_Column<TData, TValue>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLButtonElement> & Partial<UnstyledButtonProps>) | (HTMLPropsRef<HTMLButtonElement> & Partial<UnstyledButtonProps>);
    mantineEditSelectProps?: ((props: {
        cell: MRT_Cell<TData, TValue>;
        column: MRT_Column<TData, TValue>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<MultiSelectProps>) | (HTMLPropsRef<HTMLInputElement> & Partial<MultiSelectProps>);
    mantineEditTextInputProps?: ((props: {
        cell: MRT_Cell<TData, TValue>;
        column: MRT_Column<TData, TValue>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>) | (HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>);
    mantineFilterAutocompleteProps?: ((props: {
        column: MRT_Column<TData, TValue>;
        rangeFilterIndex?: number;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<AutocompleteProps>) | (HTMLPropsRef<HTMLInputElement> & Partial<AutocompleteProps>);
    mantineFilterCheckboxProps?: ((props: {
        column: MRT_Column<TData, TValue>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>) | (HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>);
    mantineFilterDateInputProps?: ((props: {
        column: MRT_Column<TData, TValue>;
        rangeFilterIndex?: number;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<DateInputProps>) | (HTMLPropsRef<HTMLInputElement> & Partial<DateInputProps>);
    mantineFilterMultiSelectProps?: ((props: {
        column: MRT_Column<TData, TValue>;
        rangeFilterIndex?: number;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<MultiSelectProps>) | (HTMLPropsRef<HTMLInputElement> & Partial<MultiSelectProps>);
    mantineFilterRangeSliderProps?: ((props: {
        column: MRT_Column<TData, TValue>;
        rangeFilterIndex?: number;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<RangeSliderProps>) | (HTMLPropsRef<HTMLInputElement> & Partial<RangeSliderProps>);
    mantineFilterSelectProps?: ((props: {
        column: MRT_Column<TData, TValue>;
        rangeFilterIndex?: number;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<SelectProps>) | (HTMLPropsRef<HTMLInputElement> & Partial<SelectProps>);
    mantineFilterTextInputProps?: ((props: {
        column: MRT_Column<TData, TValue>;
        rangeFilterIndex?: number;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>) | (HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>);
    mantineTableBodyCellProps?: ((props: {
        cell: MRT_Cell<TData, TValue>;
        column: MRT_Column<TData, TValue>;
        renderedRowIndex?: number;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLTableCellElement> & TableTdProps) | (HTMLPropsRef<HTMLTableCellElement> & TableTdProps);
    mantineTableFooterCellProps?: ((props: {
        column: MRT_Column<TData, TValue>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLTableCellElement> & TableThProps) | (HTMLPropsRef<HTMLTableCellElement> & TableThProps);
    mantineTableHeadCellProps?: ((props: {
        column: MRT_Column<TData, TValue>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLTableCellElement> & TableThProps) | (HTMLPropsRef<HTMLTableCellElement> & TableThProps);
    renderColumnActionsMenuItems?: (props: {
        column: MRT_Column<TData, TValue>;
        internalColumnMenuItems: ReactNode;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderColumnFilterModeMenuItems?: (props: {
        column: MRT_Column<TData, TValue>;
        internalFilterOptions: MRT_InternalFilterOption[];
        onSelectFilterMode: (filterMode: MRT_FilterOption) => void;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    sortingFn?: MRT_SortingFn<TData>;
    visibleInShowHideMenu?: boolean;
};
type MRT_DisplayColumnDef<TData extends MRT_RowData, TValue = unknown> = Omit<MRT_ColumnDef<TData, TValue>, 'accessorFn' | 'accessorKey'>;
type MRT_GroupColumnDef<TData extends MRT_RowData> = MRT_DisplayColumnDef<TData, any> & {
    columns: MRT_ColumnDef<TData>[];
};
type MRT_DefinedColumnDef<TData extends MRT_RowData, TValue = unknown> = Omit<MRT_ColumnDef<TData, TValue>, 'defaultDisplayColumn' | 'id'> & {
    _filterFn: MRT_FilterOption;
    defaultDisplayColumn: Partial<MRT_ColumnDef<TData, TValue>>;
    id: string;
};
type MRT_Column<TData extends MRT_RowData, TValue = unknown> = Omit<Column<TData, MRT_CellValue>, 'columnDef' | 'columns' | 'filterFn' | 'footer' | 'header'> & {
    columnDef: MRT_DefinedColumnDef<TData, TValue>;
    columns?: MRT_Column<TData>[];
    filterFn?: MRT_FilterFn<TData>;
    footer: string;
    header: string;
};
type MRT_Header<TData extends MRT_RowData, TValue = unknown> = Omit<Header<TData, MRT_CellValue>, 'column'> & {
    column: MRT_Column<TData, TValue>;
};
type MRT_HeaderGroup<TData extends MRT_RowData> = Omit<HeaderGroup<TData>, 'headers'> & {
    headers: MRT_Header<TData>[];
};
type MRT_Row<TData extends MRT_RowData> = Omit<Row<TData>, '_valuesCache' | 'getAllCells' | 'getVisibleCells' | 'subRows'> & {
    _valuesCache: Record<LiteralUnion<string & DeepKeys<TData>>, any>;
    getAllCells: () => MRT_Cell<TData>[];
    getVisibleCells: () => MRT_Cell<TData>[];
    subRows?: MRT_Row<TData>[];
};
type MRT_Cell<TData extends MRT_RowData, TValue = unknown> = Omit<Cell<TData, TValue>, 'column' | 'row'> & {
    column: MRT_Column<TData, TValue>;
    row: MRT_Row<TData>;
};
type MRT_AggregationOption = string & keyof typeof MRT_AggregationFns;
type MRT_AggregationFn<TData extends MRT_RowData> = AggregationFn<TData> | MRT_AggregationOption;
type MRT_SortingOption = LiteralUnion<string & keyof typeof MRT_SortingFns>;
type MRT_SortingFn<TData extends MRT_RowData> = MRT_SortingOption | SortingFn<TData>;
type MRT_FilterOption = LiteralUnion<string & keyof typeof MRT_FilterFns>;
type MRT_FilterFn<TData extends MRT_RowData> = FilterFn<TData> | MRT_FilterOption;
type MRT_InternalFilterOption = {
    divider: boolean;
    label: string;
    option: string;
    symbol: string;
};
type MRT_DisplayColumnIds = 'mrt-row-actions' | 'mrt-row-drag' | 'mrt-row-expand' | 'mrt-row-numbers' | 'mrt-row-pin' | 'mrt-row-select' | 'mrt-row-spacer';
type MRT_CreateTableFeature<TData extends MRT_RowData, TFeature = any> = (table: MRT_TableInstance<TData>) => TFeature;
/**
 * `columns` and `data` props are the only required props, but there are over 150 other optional props.
 *
 * See more info on creating columns and data on the official docs site:
 * @link https://www.mantine-react-table.com/docs/getting-started/usage
 *
 * See the full props list on the official docs site:
 * @link https://www.mantine-react-table.com/docs/api/table-options
 */
type MRT_TableOptions<TData extends MRT_RowData> = Omit<Partial<TableOptions<TData>>, 'columns' | 'data' | 'defaultColumn' | 'enableRowSelection' | 'expandRowsFn' | 'getRowId' | 'globalFilterFn' | 'initialState' | 'onStateChange' | 'state'> & {
    columnFilterDisplayMode?: 'custom' | 'popover' | 'subheader';
    columnFilterModeOptions?: Array<LiteralUnion<string & MRT_FilterOption>> | null;
    columnVirtualizerInstanceRef?: MutableRefObject<Virtualizer<HTMLDivElement, HTMLTableCellElement> | null>;
    columnVirtualizerOptions?: ((props: {
        table: MRT_TableInstance<TData>;
    }) => Partial<VirtualizerOptions<HTMLDivElement, HTMLTableCellElement>>) | Partial<VirtualizerOptions<HTMLDivElement, HTMLTableCellElement>>;
    /**
     * The columns to display in the table. `accessorKey`s or `accessorFn`s must match keys in the `data` prop.
     *
     * See more info on creating columns on the official docs site:
     * @link https://www.mantine-react-table.com/docs/guides/data-columns
     * @link https://www.mantine-react-table.com/docs/guides/display-columns
     *
     * See all Columns Options on the official docs site:
     * @link https://www.mantine-react-table.com/docs/api/column-options
     */
    columns: MRT_ColumnDef<TData>[];
    createDisplayMode?: 'custom' | 'modal' | 'row';
    /**
     * Pass your data as an array of objects. Objects can theoretically be any shape, but it's best to keep them consistent.
     *
     * See the usage guide for more info on creating columns and data:
     * @link https://www.mantine-react-table.com/docs/getting-started/usage
     */
    data: TData[];
    /**
     * Instead of specifying a bunch of the same options for each column, you can just change an option in the `defaultColumn` prop to change a default option for all columns.
     */
    defaultColumn?: Partial<MRT_ColumnDef<TData>>;
    /**
     * Change the default options for display columns.
     */
    defaultDisplayColumn?: Partial<MRT_DisplayColumnDef<TData>>;
    displayColumnDefOptions?: Partial<{
        [key in MRT_DisplayColumnIds]: Partial<MRT_DisplayColumnDef<TData>>;
    }>;
    editDisplayMode?: 'cell' | 'custom' | 'modal' | 'row' | 'table';
    enableBatchRowSelection?: boolean;
    enableBottomToolbar?: boolean;
    enableClickToCopy?: ((cell: MRT_Cell<TData>) => boolean) | boolean;
    enableColumnActions?: boolean;
    enableColumnDragging?: boolean;
    enableColumnFilterModes?: boolean;
    enableColumnOrdering?: boolean;
    enableColumnVirtualization?: boolean;
    enableDensityToggle?: boolean;
    enableEditing?: ((row: MRT_Row<TData>) => boolean) | boolean;
    enableExpandAll?: boolean;
    enableFacetedValues?: boolean;
    enableFilterMatchHighlighting?: boolean;
    enableFullScreenToggle?: boolean;
    enableGlobalFilterModes?: boolean;
    enableGlobalFilterRankedResults?: boolean;
    enablePagination?: boolean;
    enableRowActions?: boolean;
    enableRowDragging?: boolean;
    enableRowNumbers?: boolean;
    enableRowOrdering?: boolean;
    enableRowSelection?: ((row: MRT_Row<TData>) => boolean) | boolean;
    enableRowVirtualization?: boolean;
    enableSelectAll?: boolean;
    enableStickyFooter?: boolean;
    enableStickyHeader?: boolean;
    enableTableFooter?: boolean;
    enableTableHead?: boolean;
    enableToolbarInternalActions?: boolean;
    enableTopToolbar?: boolean;
    expandRowsFn?: (dataRow: TData) => TData[];
    getRowId?: (originalRow: TData, index: number, parentRow: MRT_Row<TData>) => string | undefined;
    globalFilterFn?: MRT_FilterOption;
    globalFilterModeOptions?: MRT_FilterOption[] | null;
    icons?: Partial<MRT_Icons>;
    initialState?: Partial<MRT_TableState<TData>>;
    /**
     * Changes which kind of CSS layout is used to render the table. `semantic` uses default semantic HTML elements, while `grid` adds CSS grid and flexbox styles
     */
    layoutMode?: 'grid' | 'grid-no-grow' | 'semantic';
    /**
     * Pass in either a locale imported from `mantine-react-table/locales/*` or a custom locale object.
     *
     * See the localization (i18n) guide for more info:
     * @link https://www.mantine-react-table.com/docs/guides/localization
     */
    localization?: Partial<MRT_Localization>;
    mantineBottomToolbarProps?: ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & BoxProps) | (HTMLPropsRef<HTMLDivElement> & BoxProps);
    mantineColumnActionsButtonProps?: ((props: {
        column: MRT_Column<TData, MRT_CellValue>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>) | (HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>);
    mantineColumnDragHandleProps?: ((props: {
        column: MRT_Column<TData, MRT_CellValue>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>) | (HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>);
    mantineCopyButtonProps?: ((props: {
        cell: MRT_Cell<TData, MRT_CellValue>;
        column: MRT_Column<TData, MRT_CellValue>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLButtonElement> & Partial<UnstyledButtonProps>) | (HTMLPropsRef<HTMLButtonElement> & Partial<UnstyledButtonProps>);
    mantineCreateRowModalProps?: ((props: {
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & Partial<ModalProps>) | (HTMLPropsRef<HTMLDivElement> & Partial<ModalProps>);
    mantineDetailPanelProps?: ((props: {
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLTableCellElement> & BoxProps) | (HTMLPropsRef<HTMLTableCellElement> & BoxProps);
    mantineEditRowModalProps?: ((props: {
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & Partial<ModalProps>) | (HTMLPropsRef<HTMLDivElement> & Partial<ModalProps>);
    mantineEditSelectProps?: ((props: {
        cell: MRT_Cell<TData, MRT_CellValue>;
        column: MRT_Column<TData, MRT_CellValue>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<SelectProps>) | (HTMLPropsRef<HTMLInputElement> & Partial<SelectProps>);
    mantineEditTextInputProps?: ((props: {
        cell: MRT_Cell<TData, MRT_CellValue>;
        column: MRT_Column<TData, MRT_CellValue>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>) | (HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>);
    mantineExpandAllButtonProps?: ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>) | (HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>);
    mantineExpandButtonProps?: ((props: {
        renderedRowIndex?: number;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>) | (HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>);
    mantineFilterAutocompleteProps?: ((props: {
        column: MRT_Column<TData, MRT_CellValue>;
        rangeFilterIndex?: number;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<AutocompleteProps>) | (HTMLPropsRef<HTMLInputElement> & Partial<AutocompleteProps>);
    mantineFilterCheckboxProps?: ((props: {
        column: MRT_Column<TData, MRT_CellValue>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<CheckboxProps>) | (HTMLPropsRef<HTMLInputElement> & Partial<CheckboxProps>);
    mantineFilterDateInputProps?: ((props: {
        column: MRT_Column<TData, MRT_CellValue>;
        rangeFilterIndex?: number;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<DateInputProps>) | (HTMLPropsRef<HTMLInputElement> & Partial<DateInputProps>);
    mantineFilterMultiSelectProps?: ((props: {
        column: MRT_Column<TData, MRT_CellValue>;
        rangeFilterIndex?: number;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<MultiSelectProps>) | (HTMLPropsRef<HTMLInputElement> & Partial<MultiSelectProps>);
    mantineFilterRangeSliderProps?: ((props: {
        column: MRT_Column<TData, MRT_CellValue>;
        rangeFilterIndex?: number;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<RangeSliderProps>) | (HTMLPropsRef<HTMLInputElement> & Partial<RangeSliderProps>);
    mantineFilterSelectProps?: ((props: {
        column: MRT_Column<TData, MRT_CellValue>;
        rangeFilterIndex?: number;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<SelectProps>) | (HTMLPropsRef<HTMLInputElement> & Partial<SelectProps>);
    mantineFilterTextInputProps?: ((props: {
        column: MRT_Column<TData, MRT_CellValue>;
        rangeFilterIndex?: number;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>) | (HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>);
    mantineHighlightProps?: ((props: {
        cell: MRT_Cell<TData, MRT_CellValue>;
        column: MRT_Column<TData, MRT_CellValue>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLSpanElement> & Partial<HighlightProps>) | (HTMLPropsRef<HTMLSpanElement> & Partial<HighlightProps>);
    mantineLoadingOverlayProps?: ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & Partial<LoadingOverlayProps>) | (HTMLPropsRef<HTMLDivElement> & Partial<LoadingOverlayProps>);
    mantinePaginationProps?: ((props: {
        table: MRT_TableInstance<TData>;
    }) => Partial<HTMLPropsRef<HTMLDivElement> & MRT_PaginationProps>) | Partial<HTMLPropsRef<HTMLDivElement> & MRT_PaginationProps>;
    mantinePaperProps?: ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & PaperProps) | (HTMLPropsRef<HTMLDivElement> & PaperProps);
    mantineProgressProps?: ((props: {
        isTopToolbar: boolean;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & ProgressProps) | (HTMLPropsRef<HTMLDivElement> & ProgressProps);
    mantineRowDragHandleProps?: ((props: {
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>) | (HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>);
    mantineSearchTextInputProps?: ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>) | (HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>);
    mantineSelectAllCheckboxProps?: ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & (CheckboxProps | RadioProps | SwitchProps)) | (HTMLPropsRef<HTMLInputElement> & (CheckboxProps | RadioProps | SwitchProps));
    mantineSelectCheckboxProps?: ((props: {
        renderedRowIndex?: number;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & (CheckboxProps | RadioProps | SwitchProps)) | (HTMLPropsRef<HTMLInputElement> & (CheckboxProps | RadioProps | SwitchProps));
    mantineSkeletonProps?: ((props: {
        cell: MRT_Cell<TData, MRT_CellValue>;
        column: MRT_Column<TData, MRT_CellValue>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & SkeletonProps) | (HTMLPropsRef<HTMLDivElement> & SkeletonProps);
    mantineTableBodyCellProps?: ((props: {
        cell: MRT_Cell<TData, MRT_CellValue>;
        column: MRT_Column<TData, MRT_CellValue>;
        renderedColumnIndex?: number;
        renderedRowIndex?: number;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLTableCellElement> & TableTdProps) | (HTMLPropsRef<HTMLTableCellElement> & TableTdProps);
    mantineTableBodyProps?: ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLTableSectionElement> & TableTbodyProps) | (HTMLPropsRef<HTMLTableSectionElement> & TableTbodyProps);
    mantineTableBodyRowProps?: ((props: {
        isDetailPanel?: boolean;
        renderedRowIndex?: number;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLTableRowElement> & TableTrProps) | (HTMLPropsRef<HTMLTableRowElement> & TableTrProps);
    mantineTableContainerProps?: ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & BoxProps) | (HTMLPropsRef<HTMLDivElement> & BoxProps);
    mantineTableFooterCellProps?: ((props: {
        column: MRT_Column<TData, MRT_CellValue>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLTableCellElement> & TableThProps) | (HTMLPropsRef<HTMLTableCellElement> & TableThProps);
    mantineTableFooterProps?: ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLTableSectionElement> & TableTfootProps) | (HTMLPropsRef<HTMLTableSectionElement> & TableTfootProps);
    mantineTableFooterRowProps?: ((props: {
        footerGroup: MRT_HeaderGroup<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLTableRowElement> & TableTrProps) | (HTMLPropsRef<HTMLTableRowElement> & TableTrProps);
    mantineTableHeadCellProps?: ((props: {
        column: MRT_Column<TData, MRT_CellValue>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLTableCellElement> & TableThProps) | (HTMLPropsRef<HTMLTableCellElement> & TableThProps);
    mantineTableHeadProps?: ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLTableSectionElement> & TableTheadProps) | (HTMLPropsRef<HTMLTableSectionElement> & TableTheadProps);
    mantineTableHeadRowProps?: ((props: {
        headerGroup: MRT_HeaderGroup<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLTableRowElement> & TableTrProps) | (HTMLPropsRef<HTMLTableRowElement> & TableTrProps);
    mantineTableProps?: ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLTableElement> & TableProps) | (HTMLPropsRef<HTMLTableElement> & TableProps);
    mantineToolbarAlertBannerBadgeProps?: ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & Partial<BadgeProps>) | (HTMLPropsRef<HTMLDivElement> & Partial<BadgeProps>);
    mantineToolbarAlertBannerProps?: ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & Partial<AlertProps>) | (HTMLPropsRef<HTMLDivElement> & Partial<AlertProps>);
    mantineTopToolbarProps?: ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & BoxProps) | (HTMLPropsRef<HTMLDivElement> & BoxProps);
    /**
     * Memoize cells, rows, or the entire table body to potentially improve render performance.
     *
     * @warning This will break some dynamic rendering features. See the memoization guide for more info:
     * @link https://www.mantine-react-table.com/docs/guides/memoize-components
     */
    memoMode?: 'cells' | 'rows' | 'table-body';
    onColumnFilterFnsChange?: OnChangeFn<{
        [key: string]: MRT_FilterOption;
    }>;
    onCreatingRowCancel?: (props: {
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => void;
    onCreatingRowChange?: OnChangeFn<MRT_Row<TData> | null>;
    onCreatingRowSave?: (props: {
        exitCreatingMode: () => void;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
        values: Record<LiteralUnion<string & DeepKeys<TData>>, any>;
    }) => void;
    onDensityChange?: OnChangeFn<MRT_DensityState>;
    onDraggingColumnChange?: OnChangeFn<MRT_Column<TData> | null>;
    onDraggingRowChange?: OnChangeFn<MRT_Row<TData> | null>;
    onEditingCellChange?: OnChangeFn<MRT_Cell<TData> | null>;
    onEditingRowCancel?: (props: {
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => void;
    onEditingRowChange?: OnChangeFn<MRT_Row<TData> | null>;
    onEditingRowSave?: (props: {
        exitEditingMode: () => void;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
        values: Record<LiteralUnion<string & DeepKeys<TData>>, any>;
    }) => Promise<void> | void;
    onGlobalFilterFnChange?: OnChangeFn<MRT_FilterOption>;
    onHoveredColumnChange?: OnChangeFn<Partial<MRT_Column<TData>> | null>;
    onHoveredRowChange?: OnChangeFn<Partial<MRT_Row<TData>> | null>;
    onIsFullScreenChange?: OnChangeFn<boolean>;
    onShowAlertBannerChange?: OnChangeFn<boolean>;
    onShowColumnFiltersChange?: OnChangeFn<boolean>;
    onShowGlobalFilterChange?: OnChangeFn<boolean>;
    onShowToolbarDropZoneChange?: OnChangeFn<boolean>;
    paginationDisplayMode?: 'custom' | 'default' | 'pages';
    positionActionsColumn?: 'first' | 'last';
    positionCreatingRow?: 'bottom' | 'top' | number;
    positionExpandColumn?: 'first' | 'last';
    positionGlobalFilter?: 'left' | 'none' | 'right';
    positionPagination?: 'both' | 'bottom' | 'none' | 'top';
    positionToolbarAlertBanner?: 'bottom' | 'head-overlay' | 'none' | 'top';
    positionToolbarDropZone?: 'both' | 'bottom' | 'none' | 'top';
    renderBottomToolbar?: ((props: {
        table: MRT_TableInstance<TData>;
    }) => ReactNode) | ReactNode;
    renderBottomToolbarCustomActions?: (props: {
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderColumnActionsMenuItems?: (props: {
        column: MRT_Column<TData, MRT_CellValue>;
        internalColumnMenuItems: ReactNode;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderColumnFilterModeMenuItems?: (props: {
        column: MRT_Column<TData, MRT_CellValue>;
        internalFilterOptions: MRT_InternalFilterOption[];
        onSelectFilterMode: (filterMode: MRT_FilterOption) => void;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderCreateRowModalContent?: (props: {
        internalEditComponents: ReactNode[];
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderDetailPanel?: (props: {
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderEditRowModalContent?: (props: {
        internalEditComponents: ReactNode[];
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderEmptyRowsFallback?: (props: {
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderGlobalFilterModeMenuItems?: (props: {
        internalFilterOptions: MRT_InternalFilterOption[];
        onSelectFilterMode: (filterMode: MRT_FilterOption) => void;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderRowActionMenuItems?: (props: {
        renderedRowIndex?: number;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderRowActions?: (props: {
        cell: MRT_Cell<TData, MRT_CellValue>;
        renderedRowIndex?: number;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderToolbarAlertBannerContent?: (props: {
        groupedAlert: ReactNode | null;
        selectedAlert: ReactNode | null;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderToolbarInternalActions?: (props: {
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderTopToolbar?: ((props: {
        table: MRT_TableInstance<TData>;
    }) => ReactNode) | ReactNode;
    renderTopToolbarCustomActions?: (props: {
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    rowCount?: number;
    rowNumberDisplayMode?: 'original' | 'static';
    rowPinningDisplayMode?: 'bottom' | 'select-bottom' | 'select-sticky' | 'select-top' | 'sticky' | 'top' | 'top-and-bottom';
    rowVirtualizerInstanceRef?: MutableRefObject<Virtualizer<HTMLDivElement, HTMLTableRowElement> | null>;
    rowVirtualizerOptions?: ((props: {
        table: MRT_TableInstance<TData>;
    }) => Partial<VirtualizerOptions<HTMLDivElement, HTMLTableRowElement>>) | Partial<VirtualizerOptions<HTMLDivElement, HTMLTableRowElement>>;
    selectAllMode?: 'all' | 'page';
    selectDisplayMode?: 'checkbox' | 'radio' | 'switch';
    /**
     * Manage state externally any way you want, then pass it back into MRT.
     */
    state?: Partial<MRT_TableState<TData>>;
};

declare const flexRender: (Comp: Renderable<any>, props: any) => JSX.Element | ReactNode;
declare function createMRTColumnHelper<TData extends MRT_RowData>(): MRT_ColumnHelper<TData>;
declare const createRow: <TData extends MRT_RowData>(table: MRT_TableInstance<TData>, originalRow?: TData, rowIndex?: number, depth?: number, subRows?: MRT_Row<TData>[], parentId?: string) => MRT_Row<TData>;

declare const getColumnId: <TData extends MRT_RowData>(columnDef: MRT_ColumnDef<TData>) => string;
declare const getAllLeafColumnDefs: <TData extends MRT_RowData>(columns: MRT_ColumnDef<TData>[]) => MRT_ColumnDef<TData>[];
declare const prepareColumns: <TData extends MRT_RowData>({ columnDefs, tableOptions, }: {
    columnDefs: MRT_ColumnDef<TData>[];
    tableOptions: MRT_DefinedTableOptions<TData>;
}) => MRT_DefinedColumnDef<TData>[];
declare const reorderColumn: <TData extends MRT_RowData>(draggedColumn: MRT_Column<TData>, targetColumn: MRT_Column<TData>, columnOrder: _tanstack_react_table.ColumnOrderState) => _tanstack_react_table.ColumnOrderState;
declare const getDefaultColumnFilterFn: <TData extends MRT_RowData>(columnDef: MRT_ColumnDef<TData>) => MRT_FilterOption;

declare function defaultDisplayColumnProps<TData extends MRT_RowData>({ header, id, size, tableOptions, }: {
    header?: keyof MRT_Localization;
    id: MRT_DisplayColumnIds;
    size: number;
    tableOptions: MRT_DefinedTableOptions<TData>;
}): MRT_ColumnDef<TData>;
declare const showRowPinningColumn: <TData extends MRT_RowData>(tableOptions: MRT_StatefulTableOptions<TData>) => boolean;
declare const showRowDragColumn: <TData extends MRT_RowData>(tableOptions: MRT_StatefulTableOptions<TData>) => boolean;
declare const showRowExpandColumn: <TData extends MRT_RowData>(tableOptions: MRT_StatefulTableOptions<TData>) => boolean;
declare const showRowActionsColumn: <TData extends MRT_RowData>(tableOptions: MRT_StatefulTableOptions<TData>) => boolean;
declare const showRowSelectionColumn: <TData extends MRT_RowData>(tableOptions: MRT_StatefulTableOptions<TData>) => boolean;
declare const showRowNumbersColumn: <TData extends MRT_RowData>(tableOptions: MRT_StatefulTableOptions<TData>) => boolean;
declare const showRowSpacerColumn: <TData extends MRT_RowData>(tableOptions: MRT_StatefulTableOptions<TData>) => boolean;
declare const getLeadingDisplayColumnIds: <TData extends MRT_RowData>(tableOptions: MRT_StatefulTableOptions<TData>) => MRT_DisplayColumnIds[];
declare const getTrailingDisplayColumnIds: <TData extends MRT_RowData>(tableOptions: MRT_StatefulTableOptions<TData>) => MRT_DisplayColumnIds[];
declare const getDefaultColumnOrderIds: <TData extends MRT_RowData>(tableOptions: MRT_StatefulTableOptions<TData>, reset?: boolean) => string[];

declare const getMRT_Rows: <TData extends MRT_RowData>(table: MRT_TableInstance<TData>, all?: boolean) => MRT_Row<TData>[];
declare const getCanRankRows: <TData extends MRT_RowData>(table: MRT_TableInstance<TData>) => boolean | undefined;
declare const getIsRankingRows: <TData extends MRT_RowData>(table: MRT_TableInstance<TData>) => any;
declare const getIsRowSelected: <TData extends MRT_RowData>({ row, table, }: {
    row: MRT_Row<TData>;
    table: MRT_TableInstance<TData>;
}) => boolean | undefined;
declare const getMRT_RowSelectionHandler: <TData extends MRT_RowData>({ renderedRowIndex, row, table, }: {
    renderedRowIndex?: number | undefined;
    row: MRT_Row<TData>;
    table: MRT_TableInstance<TData>;
}) => (event: ChangeEvent<HTMLInputElement> | MouseEvent<HTMLTableRowElement>, value?: boolean) => void;
declare const getMRT_SelectAllHandler: <TData extends MRT_RowData>({ table }: {
    table: MRT_TableInstance<TData>;
}) => (event: ChangeEvent<HTMLInputElement> | MouseEvent<HTMLButtonElement>, value?: boolean, forceAll?: boolean) => void;

declare const parseCSSVarId: (id: string) => string;
declare const getPrimaryShade: (theme: MantineTheme) => number;
declare const getPrimaryColor: (theme: MantineTheme, shade?: MantineShade) => string;
declare function dataVariable(name: string, value: boolean | number | string | undefined): {
    [x: string]: string;
} | null;

declare const useMantineReactTable: <TData extends MRT_RowData>(tableOptions: MRT_TableOptions<TData>) => MRT_TableInstance<TData>;

declare const useMRT_ColumnVirtualizer: <TData extends MRT_RowData, TScrollElement extends Element | Window = HTMLDivElement, TItemElement extends Element = HTMLTableCellElement>(table: MRT_TableInstance<TData>) => MRT_ColumnVirtualizer | undefined;

declare const useMRT_Effects: <TData extends MRT_RowData>(table: MRT_TableInstance<TData>) => void;

declare const useMRT_RowVirtualizer: <TData extends MRT_RowData, TScrollElement extends Element | Window = HTMLDivElement, TItemElement extends Element = HTMLTableRowElement>(table: MRT_TableInstance<TData>, rows?: MRT_Row<TData>[]) => MRT_RowVirtualizer<TScrollElement, TItemElement> | undefined;

declare const useMRT_Rows: <TData extends MRT_RowData>(table: MRT_TableInstance<TData>) => MRT_Row<TData>[];

/**
 * The MRT hook that wraps the TanStack useReactTable hook and adds additional functionality
 * @param definedTableOptions - table options with proper defaults set
 * @returns the MRT table instance
 */
declare const useMRT_TableInstance: <TData extends MRT_RowData>(definedTableOptions: MRT_DefinedTableOptions<TData>) => MRT_TableInstance<TData>;

declare const MRT_DefaultColumn: {
    readonly filterVariant: "text";
    readonly maxSize: 1000;
    readonly minSize: 40;
    readonly size: 180;
};
declare const MRT_DefaultDisplayColumn: {
    readonly columnDefType: "display";
    readonly enableClickToCopy: false;
    readonly enableColumnActions: false;
    readonly enableColumnDragging: false;
    readonly enableColumnFilter: false;
    readonly enableColumnOrdering: false;
    readonly enableEditing: false;
    readonly enableGlobalFilter: false;
    readonly enableGrouping: false;
    readonly enableHiding: false;
    readonly enableResizing: false;
    readonly enableSorting: false;
};
declare const useMRT_TableOptions: <TData extends MRT_RowData>(tableOptions: MRT_TableOptions<TData>) => MRT_DefinedTableOptions<TData>;

type TableInstanceProp<TData extends MRT_RowData> = {
    table: MRT_TableInstance<TData>;
};
type Props$R<TData extends MRT_RowData> = Xor<TableInstanceProp<TData>, MRT_TableOptions<TData>>;
declare const MantineReactTable: <TData extends MRT_RowData>(props: Props$R<TData>) => react_jsx_runtime.JSX.Element;

interface MRT_TableBodyProps<TData extends MRT_RowData> extends TableTbodyProps {
    columnVirtualizer?: MRT_ColumnVirtualizer;
    table: MRT_TableInstance<TData>;
    tableProps: Partial<TableProps>;
}
declare const MRT_TableBody: <TData extends MRT_RowData>({ columnVirtualizer, table, tableProps, ...rest }: MRT_TableBodyProps<TData>) => react_jsx_runtime.JSX.Element;
declare const Memo_MRT_TableBody: <TData extends MRT_RowData>({ columnVirtualizer, table, tableProps, ...rest }: MRT_TableBodyProps<TData>) => react_jsx_runtime.JSX.Element;

interface Props$Q<TData extends MRT_RowData, TValue = MRT_CellValue> extends TableTdProps {
    cell: MRT_Cell<TData, TValue>;
    numRows?: number;
    renderedColumnIndex?: number;
    renderedRowIndex?: number;
    rowRef: RefObject<HTMLTableRowElement>;
    table: MRT_TableInstance<TData>;
    virtualCell?: MRT_VirtualItem;
}
declare const MRT_TableBodyCell: <TData extends MRT_RowData>({ cell, numRows, renderedColumnIndex, renderedRowIndex, rowRef, table, virtualCell, ...rest }: Props$Q<TData>) => react_jsx_runtime.JSX.Element;
declare const Memo_MRT_TableBodyCell: <TData extends MRT_RowData>({ cell, numRows, renderedColumnIndex, renderedRowIndex, rowRef, table, virtualCell, ...rest }: Props$Q<TData>) => react_jsx_runtime.JSX.Element;

interface Props$P<TData extends MRT_RowData, TValue = MRT_CellValue> {
    cell: MRT_Cell<TData, TValue>;
    renderedColumnIndex?: number;
    renderedRowIndex?: number;
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableBodyCellValue: <TData extends MRT_RowData>({ cell, renderedColumnIndex, renderedRowIndex, table, }: Props$P<TData>) => react.ReactNode;

interface Props$O<TData extends MRT_RowData> extends TableTrProps {
    columnVirtualizer?: MRT_ColumnVirtualizer;
    numRows?: number;
    pinnedRowIds?: string[];
    renderedRowIndex?: number;
    row: MRT_Row<TData>;
    rowVirtualizer?: MRT_RowVirtualizer;
    table: MRT_TableInstance<TData>;
    tableProps: Partial<TableProps>;
    virtualRow?: MRT_VirtualItem;
}
declare const MRT_TableBodyRow: <TData extends MRT_RowData>({ columnVirtualizer, numRows, pinnedRowIds, renderedRowIndex, row, rowVirtualizer, table, tableProps, virtualRow, ...rest }: Props$O<TData>) => react_jsx_runtime.JSX.Element;
declare const Memo_MRT_TableBodyRow: <TData extends MRT_RowData>({ columnVirtualizer, numRows, pinnedRowIds, renderedRowIndex, row, rowVirtualizer, table, tableProps, virtualRow, ...rest }: Props$O<TData>) => react_jsx_runtime.JSX.Element;

interface Props$N<TData extends MRT_RowData> extends ActionIconProps {
    row: MRT_Row<TData>;
    rowRef: RefObject<HTMLTableRowElement>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableBodyRowGrabHandle: <TData extends MRT_RowData>({ row, rowRef, table, ...rest }: Props$N<TData>) => react_jsx_runtime.JSX.Element;

interface Props$M<TData extends MRT_RowData> extends ActionIconProps {
    row: MRT_Row<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableBodyRowPinButton: <TData extends MRT_RowData>({ row, table, ...rest }: Props$M<TData>) => react_jsx_runtime.JSX.Element | null;

interface Props$L<TData extends MRT_RowData> extends TableTdProps {
    parentRowRef: RefObject<HTMLTableRowElement>;
    renderedRowIndex?: number;
    row: MRT_Row<TData>;
    rowVirtualizer?: MRT_RowVirtualizer;
    striped?: false | string;
    table: MRT_TableInstance<TData>;
    virtualRow?: MRT_VirtualItem;
}
declare const MRT_TableDetailPanel: <TData extends MRT_RowData>({ parentRowRef, renderedRowIndex, row, rowVirtualizer, striped, table, virtualRow, ...rest }: Props$L<TData>) => react_jsx_runtime.JSX.Element;

interface Props$K<TData extends MRT_RowData> {
    column: MRT_Column<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_ColumnPinningButtons: <TData extends MRT_RowData>({ column, table, }: Props$K<TData>) => react_jsx_runtime.JSX.Element;

interface Props$J<TData extends MRT_RowData, TValue = MRT_CellValue> extends UnstyledButtonProps {
    cell: MRT_Cell<TData, TValue>;
    children: ReactNode;
    table: MRT_TableInstance<TData>;
}
declare const MRT_CopyButton: <TData extends MRT_RowData>({ cell, children, table, ...rest }: Props$J<TData>) => react_jsx_runtime.JSX.Element;

interface Props$I<TData extends MRT_RowData> extends BoxProps {
    row: MRT_Row<TData>;
    table: MRT_TableInstance<TData>;
    variant?: 'icon' | 'text';
}
declare const MRT_EditActionButtons: <TData extends MRT_RowData>({ row, table, variant, ...rest }: Props$I<TData>) => react_jsx_runtime.JSX.Element;

interface Props$H<TData extends MRT_RowData> extends ActionIconProps {
    table: MRT_TableInstance<TData>;
}
declare const MRT_ExpandAllButton: <TData extends MRT_RowData>({ table, ...rest }: Props$H<TData>) => react_jsx_runtime.JSX.Element;

interface Props$G<TData extends MRT_RowData> extends ActionIconProps {
    row: MRT_Row<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_ExpandButton: <TData extends MRT_RowData>({ row, table, ...rest }: Props$G<TData>) => react_jsx_runtime.JSX.Element;

interface Props$F<TData extends MRT_RowData> {
    actionIconProps?: ActionIconProps & HTMLPropsRef<HTMLButtonElement>;
    onDragEnd: DragEventHandler<HTMLButtonElement>;
    onDragStart: DragEventHandler<HTMLButtonElement>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_GrabHandleButton: <TData extends MRT_RowData>({ actionIconProps, onDragEnd, onDragStart, table: { options: { icons: { IconGripHorizontal }, localization: { move }, }, }, }: Props$F<TData>) => react_jsx_runtime.JSX.Element;

interface Props$E<TData extends MRT_RowData> extends ActionIconProps {
    pinningPosition: RowPinningPosition;
    row: MRT_Row<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_RowPinButton: <TData extends MRT_RowData>({ pinningPosition, row, table, ...rest }: Props$E<TData>) => react_jsx_runtime.JSX.Element;

interface Props$D<TData extends MRT_RowData> extends ActionIconProps, HTMLPropsRef<HTMLButtonElement> {
    table: MRT_TableInstance<TData>;
}
declare const MRT_ShowHideColumnsButton: <TData extends MRT_RowData>({ table, title, ...rest }: Props$D<TData>) => react_jsx_runtime.JSX.Element;

interface Props$C<TData extends MRT_RowData> extends ActionIconProps, HTMLPropsRef<HTMLButtonElement> {
    table: MRT_TableInstance<TData>;
}
declare const MRT_ToggleDensePaddingButton: <TData extends MRT_RowData>({ table: { getState, options: { icons: { IconBaselineDensityLarge, IconBaselineDensityMedium, IconBaselineDensitySmall, }, localization: { toggleDensity }, }, setDensity, }, title, ...rest }: Props$C<TData>) => react_jsx_runtime.JSX.Element;

interface Props$B<TData extends MRT_RowData> extends ActionIconProps, HTMLPropsRef<HTMLButtonElement> {
    table: MRT_TableInstance<TData>;
}
declare const MRT_ToggleFiltersButton: <TData extends MRT_RowData>({ table: { getState, options: { icons: { IconFilter, IconFilterOff }, localization: { showHideFilters }, }, setShowColumnFilters, }, title, ...rest }: Props$B<TData>) => react_jsx_runtime.JSX.Element;

interface Props$A<TData extends MRT_RowData> extends ActionIconProps, HTMLPropsRef<HTMLButtonElement> {
    table: MRT_TableInstance<TData>;
}
declare const MRT_ToggleFullScreenButton: <TData extends MRT_RowData>({ table: { getState, options: { icons: { IconMaximize, IconMinimize }, localization: { toggleFullScreen }, }, setIsFullScreen, }, title, ...rest }: Props$A<TData>) => react_jsx_runtime.JSX.Element;

interface Props$z<TData extends MRT_RowData> extends ActionIconProps, HTMLPropsRef<HTMLButtonElement> {
    table: MRT_TableInstance<TData>;
}
declare const MRT_ToggleGlobalFilterButton: <TData extends MRT_RowData>({ table: { getState, options: { icons: { IconSearch, IconSearchOff }, localization: { showHideSearch }, }, refs: { searchInputRef }, setShowGlobalFilter, }, title, ...rest }: Props$z<TData>) => react_jsx_runtime.JSX.Element;

interface Props$y<TData extends MRT_RowData, TValue = MRT_CellValue> {
    cell: MRT_Cell<TData, TValue>;
    row: MRT_Row<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_ToggleRowActionMenuButton: <TData extends MRT_RowData>({ cell, row, table, }: Props$y<TData>) => react_jsx_runtime.JSX.Element;

interface Props$x<TData extends MRT_RowData> extends TableTfootProps {
    columnVirtualizer?: MRT_ColumnVirtualizer;
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableFooter: <TData extends MRT_RowData>({ columnVirtualizer, table, ...rest }: Props$x<TData>) => react_jsx_runtime.JSX.Element;

interface Props$w<TData extends MRT_RowData> extends TableThProps {
    footer: MRT_Header<TData>;
    renderedColumnIndex?: number;
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableFooterCell: <TData extends MRT_RowData>({ footer, renderedColumnIndex, table, ...rest }: Props$w<TData>) => react_jsx_runtime.JSX.Element;

interface Props$v<TData extends MRT_RowData> extends TableTrProps {
    columnVirtualizer?: MRT_ColumnVirtualizer;
    footerGroup: MRT_HeaderGroup<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableFooterRow: <TData extends MRT_RowData>({ columnVirtualizer, footerGroup, table, ...rest }: Props$v<TData>) => react_jsx_runtime.JSX.Element | null;

interface Props$u<TData extends MRT_RowData> extends TableTheadProps {
    columnVirtualizer?: MRT_ColumnVirtualizer;
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableHead: <TData extends MRT_RowData>({ columnVirtualizer, table, ...rest }: Props$u<TData>) => react_jsx_runtime.JSX.Element;

interface Props$t<TData extends MRT_RowData> extends TableThProps {
    columnVirtualizer?: MRT_ColumnVirtualizer;
    header: MRT_Header<TData>;
    renderedHeaderIndex?: number;
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableHeadCell: <TData extends MRT_RowData>({ columnVirtualizer, header, renderedHeaderIndex, table, ...rest }: Props$t<TData>) => react_jsx_runtime.JSX.Element;

interface Props$s<TData extends MRT_RowData> extends FlexProps {
    header: MRT_Header<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableHeadCellFilterContainer: <TData extends MRT_RowData>({ header, table, ...rest }: Props$s<TData>) => react_jsx_runtime.JSX.Element;

interface Props$r<TData extends MRT_RowData> extends ActionIconProps {
    header: MRT_Header<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableHeadCellFilterLabel: <TData extends MRT_RowData>({ header, table, ...rest }: Props$r<TData>) => react_jsx_runtime.JSX.Element;

interface Props$q<TData extends MRT_RowData, TValue = MRT_CellValue> extends ActionIconProps {
    column: MRT_Column<TData, TValue>;
    table: MRT_TableInstance<TData>;
    tableHeadCellRef: RefObject<HTMLTableCellElement>;
}
declare const MRT_TableHeadCellGrabHandle: <TData extends MRT_RowData>({ column, table, tableHeadCellRef, ...rest }: Props$q<TData>) => react_jsx_runtime.JSX.Element;

interface Props$p<TData extends MRT_RowData> extends BoxProps {
    header: MRT_Header<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableHeadCellResizeHandle: <TData extends MRT_RowData>({ header, table, ...rest }: Props$p<TData>) => react_jsx_runtime.JSX.Element;

interface Props$o<TData extends MRT_RowData> extends ActionIconProps {
    header: MRT_Header<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableHeadCellSortLabel: <TData extends MRT_RowData>({ header, table, ...rest }: Props$o<TData>) => react_jsx_runtime.JSX.Element;

interface Props$n<TData extends MRT_RowData> extends TableTrProps {
    columnVirtualizer?: MRT_ColumnVirtualizer;
    headerGroup: MRT_HeaderGroup<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableHeadRow: <TData extends MRT_RowData>({ columnVirtualizer, headerGroup, table, ...rest }: Props$n<TData>) => react_jsx_runtime.JSX.Element;

interface Props$m<TData extends MRT_RowData, TValue = MRT_CellValue> extends TextInputProps {
    cell: MRT_Cell<TData, TValue>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_EditCellTextInput: <TData extends MRT_RowData>({ cell, table, ...rest }: Props$m<TData>) => string | number | boolean | Iterable<react.ReactNode> | react_jsx_runtime.JSX.Element | null | undefined;

interface Props$l<TData extends MRT_RowData, TValue = MRT_CellValue> extends CheckboxProps {
    column: MRT_Column<TData, TValue>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_FilterCheckbox: <TData extends MRT_RowData>({ column, table, ...rest }: Props$l<TData>) => react_jsx_runtime.JSX.Element;

interface Props$k<TData extends MRT_RowData> extends BoxProps {
    header: MRT_Header<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_FilterRangeFields: <TData extends MRT_RowData>({ header, table, ...rest }: Props$k<TData>) => react_jsx_runtime.JSX.Element;

interface Props$j<TData extends MRT_RowData> extends RangeSliderProps {
    header: MRT_Header<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_FilterRangeSlider: <TData extends MRT_RowData>({ header, table, ...rest }: Props$j<TData>) => react_jsx_runtime.JSX.Element;

interface Props$i<TData extends MRT_RowData> extends TextInputProps {
    header: MRT_Header<TData>;
    rangeFilterIndex?: number;
    table: MRT_TableInstance<TData>;
}
declare const MRT_FilterTextInput: <TData extends MRT_RowData>({ header, rangeFilterIndex, table, ...rest }: Props$i<TData>) => react_jsx_runtime.JSX.Element;

interface Props$h<TData extends MRT_RowData> extends TextInputProps {
    table: MRT_TableInstance<TData>;
}
declare const MRT_GlobalFilterTextInput: <TData extends MRT_RowData>({ table, ...rest }: Props$h<TData>) => react_jsx_runtime.JSX.Element;

interface Props$g<TData extends MRT_RowData> extends CheckboxProps {
    renderedRowIndex?: number;
    row?: MRT_Row<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_SelectCheckbox: <TData extends MRT_RowData>({ renderedRowIndex, row, table, ...rest }: Props$g<TData>) => react_jsx_runtime.JSX.Element;

interface Props$f<TData extends MRT_RowData> extends MenuProps {
    header: MRT_Header<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_ColumnActionMenu: <TData extends MRT_RowData>({ header, table, ...rest }: Props$f<TData>) => react_jsx_runtime.JSX.Element;

declare const mrtFilterOptions: (localization: MRT_Localization) => MRT_InternalFilterOption[];
interface Props$e<TData extends MRT_RowData> {
    header?: MRT_Header<TData>;
    onSelect?: () => void;
    table: MRT_TableInstance<TData>;
}
declare const MRT_FilterOptionMenu: <TData extends MRT_RowData>({ header, onSelect, table, }: Props$e<TData>) => react_jsx_runtime.JSX.Element;

interface Props$d<TData extends MRT_RowData> extends ActionIconProps {
    handleEdit: (event: MouseEvent) => void;
    row: MRT_Row<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_RowActionMenu: <TData extends MRT_RowData>({ handleEdit, row, table, ...rest }: Props$d<TData>) => react_jsx_runtime.JSX.Element;

interface Props$c<TData extends MRT_RowData> {
    table: MRT_TableInstance<TData>;
}
declare const MRT_ShowHideColumnsMenu: <TData extends MRT_RowData>({ table, }: Props$c<TData>) => react_jsx_runtime.JSX.Element;

interface Props$b<TData extends MRT_RowData, TValue = MRT_CellValue> {
    allColumns: MRT_Column<TData>[];
    column: MRT_Column<TData, TValue>;
    hoveredColumn: MRT_Column<TData> | null;
    setHoveredColumn: Dispatch<SetStateAction<MRT_Column<TData> | null>>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_ShowHideColumnsMenuItems: <TData extends MRT_RowData>({ allColumns, column, hoveredColumn, setHoveredColumn, table, }: Props$b<TData>) => react_jsx_runtime.JSX.Element | null;

interface Props$a<TData extends MRT_RowData> extends Partial<ModalProps> {
    open: boolean;
    table: MRT_TableInstance<TData>;
}
declare const MRT_EditRowModal: <TData extends MRT_RowData>({ open, table, ...rest }: Props$a<TData>) => react_jsx_runtime.JSX.Element;

interface Props$9<TData extends MRT_RowData> extends TableProps {
    table: MRT_TableInstance<TData>;
}
declare const MRT_Table: <TData extends MRT_RowData>({ table, ...rest }: Props$9<TData>) => react_jsx_runtime.JSX.Element;

interface Props$8<TData extends MRT_RowData> extends BoxProps {
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableContainer: <TData extends MRT_RowData>({ table, ...rest }: Props$8<TData>) => react_jsx_runtime.JSX.Element;

interface Props$7<TData extends MRT_RowData> extends PaperProps {
    table: MRT_TableInstance<TData>;
}
declare const MRT_TablePaper: <TData extends MRT_RowData>({ table, ...rest }: Props$7<TData>) => react_jsx_runtime.JSX.Element;

interface Props$6<TData extends MRT_RowData> extends BoxProps {
    table: MRT_TableInstance<TData>;
}
declare const MRT_BottomToolbar: <TData extends MRT_RowData>({ table, ...rest }: Props$6<TData>) => react_jsx_runtime.JSX.Element;

interface Props$5<TData extends MRT_RowData> extends Partial<ProgressProps> {
    isTopToolbar: boolean;
    table: MRT_TableInstance<TData>;
}
declare const MRT_ProgressBar: <TData extends MRT_RowData>({ isTopToolbar, table, ...rest }: Props$5<TData>) => react_jsx_runtime.JSX.Element;

interface Props$4<TData extends MRT_RowData> extends Partial<PaginationProps> {
    position?: 'bottom' | 'top';
    table: MRT_TableInstance<TData>;
}
declare const MRT_TablePagination: <TData extends MRT_RowData>({ position, table, ...props }: Props$4<TData>) => react_jsx_runtime.JSX.Element;

interface Props$3<TData extends MRT_RowData> extends Partial<AlertProps> {
    stackAlertBanner?: boolean;
    table: MRT_TableInstance<TData>;
}
declare const MRT_ToolbarAlertBanner: <TData extends MRT_RowData>({ stackAlertBanner, table, ...rest }: Props$3<TData>) => react_jsx_runtime.JSX.Element;

interface Props$2<TData extends MRT_RowData> extends FlexProps {
    table: MRT_TableInstance<TData>;
}
declare const MRT_ToolbarDropZone: <TData extends MRT_RowData>({ table, ...rest }: Props$2<TData>) => react_jsx_runtime.JSX.Element;

interface Props$1<TData extends MRT_RowData> extends FlexProps {
    table: MRT_TableInstance<TData>;
}
declare const MRT_ToolbarInternalButtons: <TData extends MRT_RowData>({ table, ...rest }: Props$1<TData>) => react_jsx_runtime.JSX.Element;

interface Props<TData extends MRT_RowData> extends BoxProps {
    table: MRT_TableInstance<TData>;
}
declare const MRT_TopToolbar: <TData extends MRT_RowData>({ table, ...rest }: Props<TData>) => react_jsx_runtime.JSX.Element;

export { type HTMLPropsRef, type LiteralUnion, type MRT_AggregationFn, MRT_AggregationFns, type MRT_AggregationOption, MRT_BottomToolbar, type MRT_Cell, type MRT_CellValue, type MRT_Column, MRT_ColumnActionMenu, type MRT_ColumnDef, type MRT_ColumnFilterFnsState, type MRT_ColumnFiltersState, type MRT_ColumnHelper, type MRT_ColumnOrderState, MRT_ColumnPinningButtons, type MRT_ColumnPinningState, type MRT_ColumnSizingInfoState, type MRT_ColumnSizingState, type MRT_ColumnVirtualizer, MRT_CopyButton, type MRT_CreateTableFeature, MRT_DefaultColumn, MRT_DefaultDisplayColumn, type MRT_DefinedColumnDef, type MRT_DefinedTableOptions, type MRT_DensityState, type MRT_DisplayColumnDef, type MRT_DisplayColumnIds, MRT_EditActionButtons, MRT_EditCellTextInput, MRT_EditRowModal, MRT_ExpandAllButton, MRT_ExpandButton, type MRT_ExpandedState, MRT_FilterCheckbox, type MRT_FilterFn, MRT_FilterFns, type MRT_FilterOption, MRT_FilterOptionMenu, MRT_FilterRangeFields, MRT_FilterRangeSlider, MRT_FilterTextInput, MRT_GlobalFilterTextInput, MRT_GrabHandleButton, type MRT_GroupColumnDef, type MRT_GroupingState, type MRT_Header, type MRT_HeaderGroup, type MRT_Icons, type MRT_InternalFilterOption, type MRT_Localization, type MRT_PaginationProps, type MRT_PaginationState, MRT_ProgressBar, type MRT_Row, MRT_RowActionMenu, type MRT_RowData, type MRT_RowModel, MRT_RowPinButton, type MRT_RowSelectionState, type MRT_RowVirtualizer, MRT_SelectCheckbox, MRT_ShowHideColumnsButton, MRT_ShowHideColumnsMenu, MRT_ShowHideColumnsMenuItems, type MRT_SortingFn, MRT_SortingFns, type MRT_SortingOption, type MRT_SortingState, type MRT_StatefulTableOptions, MRT_Table, MRT_TableBody, MRT_TableBodyCell, MRT_TableBodyCellValue, type MRT_TableBodyProps, MRT_TableBodyRow, MRT_TableBodyRowGrabHandle, MRT_TableBodyRowPinButton, MRT_TableContainer, MRT_TableDetailPanel, MRT_TableFooter, MRT_TableFooterCell, MRT_TableFooterRow, MRT_TableHead, MRT_TableHeadCell, MRT_TableHeadCellFilterContainer, MRT_TableHeadCellFilterLabel, MRT_TableHeadCellGrabHandle, MRT_TableHeadCellResizeHandle, MRT_TableHeadCellSortLabel, MRT_TableHeadRow, type MRT_TableInstance, type MRT_TableOptions, MRT_TablePagination, MRT_TablePaper, type MRT_TableState, MRT_ToggleDensePaddingButton, MRT_ToggleFiltersButton, MRT_ToggleFullScreenButton, MRT_ToggleGlobalFilterButton, MRT_ToggleRowActionMenuButton, MRT_ToolbarAlertBanner, MRT_ToolbarDropZone, MRT_ToolbarInternalButtons, MRT_TopToolbar, type MRT_Updater, type MRT_VirtualItem, type MRT_VirtualizerOptions, type MRT_VisibilityState, MantineReactTable, type MantineShade, Memo_MRT_TableBody, Memo_MRT_TableBodyCell, Memo_MRT_TableBodyRow, type Prettify, type Xor, createMRTColumnHelper, createRow, dataVariable, defaultDisplayColumnProps, flexRender, getAllLeafColumnDefs, getCanRankRows, getColumnId, getDefaultColumnFilterFn, getDefaultColumnOrderIds, getIsRankingRows, getIsRowSelected, getLeadingDisplayColumnIds, getMRT_RowSelectionHandler, getMRT_Rows, getMRT_SelectAllHandler, getPrimaryColor, getPrimaryShade, getTrailingDisplayColumnIds, localizedFilterOption, mrtFilterOptions, parseCSSVarId, prepareColumns, rankGlobalFuzzy, reorderColumn, showRowActionsColumn, showRowDragColumn, showRowExpandColumn, showRowNumbersColumn, showRowPinningColumn, showRowSelectionColumn, showRowSpacerColumn, useMRT_ColumnVirtualizer, useMRT_Effects, useMRT_RowVirtualizer, useMRT_Rows, useMRT_TableInstance, useMRT_TableOptions, useMantineReactTable };
